
using System;
using EdFi.Ods.Common;
using EdFi.Ods.Api.ETag;
using EdFi.Ods.Api.Extensions;
// Aggregate: AcademicHonorCategoryType

namespace EdFi.Ods.Entities.Common //.AcademicHonorCategoryTypeAggregate
{ 
    public static class AcademicHonorCategoryTypeMapper 
    {
        public static bool SynchronizeTo(this IAcademicHonorCategoryType source, IAcademicHonorCategoryType target)
        {
            bool isModified = false;

            var sourceSupport = source as IAcademicHonorCategoryTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AcademicHonorCategoryTypeId != target.AcademicHonorCategoryTypeId)
            {
                source.AcademicHonorCategoryTypeId = target.AcademicHonorCategoryTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IAcademicHonorCategoryType source, IAcademicHonorCategoryType target, Action<IAcademicHonorCategoryType, IAcademicHonorCategoryType> onMapped)
        {
            var sourceSynchSupport = source as IAcademicHonorCategoryTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IAcademicHonorCategoryTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.AcademicHonorCategoryTypeId = source.AcademicHonorCategoryTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IAcademicHonorCategoryTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: AcademicSubjectDescriptor

namespace EdFi.Ods.Entities.Common //.AcademicSubjectDescriptorAggregate
{ 
    public static class AcademicSubjectDescriptorMapper 
    {
        public static bool SynchronizeTo(this IAcademicSubjectDescriptor source, IAcademicSubjectDescriptor target)
        {
            bool isModified = false;

            var sourceSupport = source as IAcademicSubjectDescriptorSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AcademicSubjectDescriptorId != target.AcademicSubjectDescriptorId)
            {
                source.AcademicSubjectDescriptorId = target.AcademicSubjectDescriptorId;
            }

            // Copy inherited non-PK properties


            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveBeginDateSupported)
                && target.EffectiveBeginDate != source.EffectiveBeginDate)
            {
                target.EffectiveBeginDate = source.EffectiveBeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveEndDateSupported)
                && target.EffectiveEndDate != source.EffectiveEndDate)
            {
                target.EffectiveEndDate = source.EffectiveEndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNamespaceSupported)
                && target.Namespace != source.Namespace)
            {
                target.Namespace = source.Namespace;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPriorDescriptorIdSupported)
                && target.PriorDescriptorId != source.PriorDescriptorId)
            {
                target.PriorDescriptorId = source.PriorDescriptorId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsAcademicSubjectTypeSupported)
                && target.AcademicSubjectType != source.AcademicSubjectType)
            {
                target.AcademicSubjectType = source.AcademicSubjectType;
                isModified = true;
            }

            // Synch inherited lists


            // Sync lists

            return isModified;
        }



        public static void MapTo(this IAcademicSubjectDescriptor source, IAcademicSubjectDescriptor target, Action<IAcademicSubjectDescriptor, IAcademicSubjectDescriptor> onMapped)
        {
            var sourceSynchSupport = source as IAcademicSubjectDescriptorSynchronizationSourceSupport;
            var targetSynchSupport = target as IAcademicSubjectDescriptorSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.AcademicSubjectDescriptorId = source.AcademicSubjectDescriptorId;

            // Copy inherited non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsEffectiveBeginDateSupported)
                target.EffectiveBeginDate = source.EffectiveBeginDate;
            else
                targetSynchSupport.IsEffectiveBeginDateSupported = false;

            if (sourceSynchSupport.IsEffectiveEndDateSupported)
                target.EffectiveEndDate = source.EffectiveEndDate;
            else
                targetSynchSupport.IsEffectiveEndDateSupported = false;

            if (sourceSynchSupport.IsNamespaceSupported)
                target.Namespace = source.Namespace;
            else
                targetSynchSupport.IsNamespaceSupported = false;

            if (sourceSynchSupport.IsPriorDescriptorIdSupported)
                target.PriorDescriptorId = source.PriorDescriptorId;
            else
                targetSynchSupport.IsPriorDescriptorIdSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Copy non-PK properties

            if (sourceSynchSupport.IsAcademicSubjectTypeSupported)
                target.AcademicSubjectType = source.AcademicSubjectType;
            else
                targetSynchSupport.IsAcademicSubjectTypeSupported = false;

            // Map inherited lists

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IAcademicSubjectDescriptorSynchronizationSourceSupport
    {
        bool IsAcademicSubjectTypeSupported { get; set; }
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsEffectiveBeginDateSupported { get; set; }
        bool IsEffectiveEndDateSupported { get; set; }
        bool IsNamespaceSupported { get; set; }
        bool IsPriorDescriptorIdSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: AcademicSubjectType

namespace EdFi.Ods.Entities.Common //.AcademicSubjectTypeAggregate
{ 
    public static class AcademicSubjectTypeMapper 
    {
        public static bool SynchronizeTo(this IAcademicSubjectType source, IAcademicSubjectType target)
        {
            bool isModified = false;

            var sourceSupport = source as IAcademicSubjectTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AcademicSubjectTypeId != target.AcademicSubjectTypeId)
            {
                source.AcademicSubjectTypeId = target.AcademicSubjectTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IAcademicSubjectType source, IAcademicSubjectType target, Action<IAcademicSubjectType, IAcademicSubjectType> onMapped)
        {
            var sourceSynchSupport = source as IAcademicSubjectTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IAcademicSubjectTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.AcademicSubjectTypeId = source.AcademicSubjectTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IAcademicSubjectTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: AcademicWeek

namespace EdFi.Ods.Entities.Common //.AcademicWeekAggregate
{ 
    public static class AcademicWeekMapper 
    {
        public static bool SynchronizeTo(this IAcademicWeek source, IAcademicWeek target)
        {
            bool isModified = false;

            var sourceSupport = source as IAcademicWeekSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.SchoolId != target.SchoolId)
            {
                source.SchoolId = target.SchoolId;
            }
            if (source.WeekIdentifier != target.WeekIdentifier)
            {
                source.WeekIdentifier = target.WeekIdentifier;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsBeginDateSupported)
                && target.BeginDate != source.BeginDate)
            {
                target.BeginDate = source.BeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEndDateSupported)
                && target.EndDate != source.EndDate)
            {
                target.EndDate = source.EndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsTotalInstructionalDaysSupported)
                && target.TotalInstructionalDays != source.TotalInstructionalDays)
            {
                target.TotalInstructionalDays = source.TotalInstructionalDays;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IAcademicWeek source, IAcademicWeek target, Action<IAcademicWeek, IAcademicWeek> onMapped)
        {
            var sourceSynchSupport = source as IAcademicWeekSynchronizationSourceSupport;
            var targetSynchSupport = target as IAcademicWeekSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.SchoolId = source.SchoolId;
            target.WeekIdentifier = source.WeekIdentifier;

            // Copy non-PK properties

            if (sourceSynchSupport.IsBeginDateSupported)
                target.BeginDate = source.BeginDate;
            else
                targetSynchSupport.IsBeginDateSupported = false;

            if (sourceSynchSupport.IsEndDateSupported)
                target.EndDate = source.EndDate;
            else
                targetSynchSupport.IsEndDateSupported = false;

            if (sourceSynchSupport.IsTotalInstructionalDaysSupported)
                target.TotalInstructionalDays = source.TotalInstructionalDays;
            else
                targetSynchSupport.IsTotalInstructionalDaysSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IAcademicWeekSynchronizationSourceSupport
    {
        bool IsBeginDateSupported { get; set; }
        bool IsEndDateSupported { get; set; }
        bool IsTotalInstructionalDaysSupported { get; set; }
    }
 
}
// Aggregate: AccommodationDescriptor

namespace EdFi.Ods.Entities.Common //.AccommodationDescriptorAggregate
{ 
    public static class AccommodationDescriptorMapper 
    {
        public static bool SynchronizeTo(this IAccommodationDescriptor source, IAccommodationDescriptor target)
        {
            bool isModified = false;

            var sourceSupport = source as IAccommodationDescriptorSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AccommodationDescriptorId != target.AccommodationDescriptorId)
            {
                source.AccommodationDescriptorId = target.AccommodationDescriptorId;
            }

            // Copy inherited non-PK properties


            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveBeginDateSupported)
                && target.EffectiveBeginDate != source.EffectiveBeginDate)
            {
                target.EffectiveBeginDate = source.EffectiveBeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveEndDateSupported)
                && target.EffectiveEndDate != source.EffectiveEndDate)
            {
                target.EffectiveEndDate = source.EffectiveEndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNamespaceSupported)
                && target.Namespace != source.Namespace)
            {
                target.Namespace = source.Namespace;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPriorDescriptorIdSupported)
                && target.PriorDescriptorId != source.PriorDescriptorId)
            {
                target.PriorDescriptorId = source.PriorDescriptorId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsAccommodationTypeSupported)
                && target.AccommodationType != source.AccommodationType)
            {
                target.AccommodationType = source.AccommodationType;
                isModified = true;
            }

            // Synch inherited lists


            // Sync lists

            return isModified;
        }



        public static void MapTo(this IAccommodationDescriptor source, IAccommodationDescriptor target, Action<IAccommodationDescriptor, IAccommodationDescriptor> onMapped)
        {
            var sourceSynchSupport = source as IAccommodationDescriptorSynchronizationSourceSupport;
            var targetSynchSupport = target as IAccommodationDescriptorSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.AccommodationDescriptorId = source.AccommodationDescriptorId;

            // Copy inherited non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsEffectiveBeginDateSupported)
                target.EffectiveBeginDate = source.EffectiveBeginDate;
            else
                targetSynchSupport.IsEffectiveBeginDateSupported = false;

            if (sourceSynchSupport.IsEffectiveEndDateSupported)
                target.EffectiveEndDate = source.EffectiveEndDate;
            else
                targetSynchSupport.IsEffectiveEndDateSupported = false;

            if (sourceSynchSupport.IsNamespaceSupported)
                target.Namespace = source.Namespace;
            else
                targetSynchSupport.IsNamespaceSupported = false;

            if (sourceSynchSupport.IsPriorDescriptorIdSupported)
                target.PriorDescriptorId = source.PriorDescriptorId;
            else
                targetSynchSupport.IsPriorDescriptorIdSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Copy non-PK properties

            if (sourceSynchSupport.IsAccommodationTypeSupported)
                target.AccommodationType = source.AccommodationType;
            else
                targetSynchSupport.IsAccommodationTypeSupported = false;

            // Map inherited lists

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IAccommodationDescriptorSynchronizationSourceSupport
    {
        bool IsAccommodationTypeSupported { get; set; }
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsEffectiveBeginDateSupported { get; set; }
        bool IsEffectiveEndDateSupported { get; set; }
        bool IsNamespaceSupported { get; set; }
        bool IsPriorDescriptorIdSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: AccommodationType

namespace EdFi.Ods.Entities.Common //.AccommodationTypeAggregate
{ 
    public static class AccommodationTypeMapper 
    {
        public static bool SynchronizeTo(this IAccommodationType source, IAccommodationType target)
        {
            bool isModified = false;

            var sourceSupport = source as IAccommodationTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AccommodationTypeId != target.AccommodationTypeId)
            {
                source.AccommodationTypeId = target.AccommodationTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IAccommodationType source, IAccommodationType target, Action<IAccommodationType, IAccommodationType> onMapped)
        {
            var sourceSynchSupport = source as IAccommodationTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IAccommodationTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.AccommodationTypeId = source.AccommodationTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IAccommodationTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: Account

namespace EdFi.Ods.Entities.Common //.AccountAggregate
{ 
    public static class AccountMapper 
    {
        public static bool SynchronizeTo(this IAccount source, IAccount target)
        {
            bool isModified = false;

            var sourceSupport = source as IAccountSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AccountNumber != target.AccountNumber)
            {
                source.AccountNumber = target.AccountNumber;
            }
            if (source.EducationOrganizationId != target.EducationOrganizationId)
            {
                source.EducationOrganizationId = target.EducationOrganizationId;
            }
            if (source.FiscalYear != target.FiscalYear)
            {
                source.FiscalYear = target.FiscalYear;
            }

            // Copy non-PK properties



            // Sync lists
            if (sourceSupport == null || sourceSupport.IsAccountCodesSupported)
                isModified |= source.AccountCodes.SynchronizeListTo(target.AccountCodes, child => child.Account = target,
                                sourceSupport == null ? null : sourceSupport.IsAccountCodeIncluded);


            return isModified;
        }



        public static void MapTo(this IAccount source, IAccount target, Action<IAccount, IAccount> onMapped)
        {
            var sourceSynchSupport = source as IAccountSynchronizationSourceSupport;
            var targetSynchSupport = target as IAccountSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.AccountNumber = source.AccountNumber;
            target.EducationOrganizationId = source.EducationOrganizationId;
            target.FiscalYear = source.FiscalYear;

            // Copy non-PK properties

            // Map lists

            if (sourceSynchSupport.IsAccountCodesSupported)
            {    
                targetSynchSupport.IsAccountCodeIncluded = sourceSynchSupport.IsAccountCodeIncluded;
                source.AccountCodes.MapListTo(target.AccountCodes);
            }
            else
            {
                targetSynchSupport.IsAccountCodesSupported = false;
            }

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IAccountSynchronizationSourceSupport
    {
        bool IsAccountCodesSupported { get; set; }
        Func<IAccountCode, bool> IsAccountCodeIncluded { get; set; }
    }
 
    public static class AccountCodeMapper 
    {
        public static bool SynchronizeTo(this IAccountCode source, IAccountCode target)
        {
            bool isModified = false;

            var sourceSupport = source as IAccountCodeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AccountCodeDescriptor != target.AccountCodeDescriptor)
            {
                source.AccountCodeDescriptor = target.AccountCodeDescriptor;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IAccountCode source, IAccountCode target, Action<IAccountCode, IAccountCode> onMapped)
        {
            var sourceSynchSupport = source as IAccountCodeSynchronizationSourceSupport;
            var targetSynchSupport = target as IAccountCodeSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.AccountCodeDescriptor = source.AccountCodeDescriptor;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IAccountCodeSynchronizationSourceSupport
    {
    }
 
}
// Aggregate: AccountabilityRating

namespace EdFi.Ods.Entities.Common //.AccountabilityRatingAggregate
{ 
    public static class AccountabilityRatingMapper 
    {
        public static bool SynchronizeTo(this IAccountabilityRating source, IAccountabilityRating target)
        {
            bool isModified = false;

            var sourceSupport = source as IAccountabilityRatingSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.EducationOrganizationId != target.EducationOrganizationId)
            {
                source.EducationOrganizationId = target.EducationOrganizationId;
            }
            if (source.RatingTitle != target.RatingTitle)
            {
                source.RatingTitle = target.RatingTitle;
            }
            if (source.SchoolYear != target.SchoolYear)
            {
                source.SchoolYear = target.SchoolYear;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsRatingSupported)
                && target.Rating != source.Rating)
            {
                target.Rating = source.Rating;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsRatingDateSupported)
                && target.RatingDate != source.RatingDate)
            {
                target.RatingDate = source.RatingDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsRatingOrganizationSupported)
                && target.RatingOrganization != source.RatingOrganization)
            {
                target.RatingOrganization = source.RatingOrganization;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsRatingProgramSupported)
                && target.RatingProgram != source.RatingProgram)
            {
                target.RatingProgram = source.RatingProgram;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IAccountabilityRating source, IAccountabilityRating target, Action<IAccountabilityRating, IAccountabilityRating> onMapped)
        {
            var sourceSynchSupport = source as IAccountabilityRatingSynchronizationSourceSupport;
            var targetSynchSupport = target as IAccountabilityRatingSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.EducationOrganizationId = source.EducationOrganizationId;
            target.RatingTitle = source.RatingTitle;
            target.SchoolYear = source.SchoolYear;

            // Copy non-PK properties

            if (sourceSynchSupport.IsRatingSupported)
                target.Rating = source.Rating;
            else
                targetSynchSupport.IsRatingSupported = false;

            if (sourceSynchSupport.IsRatingDateSupported)
                target.RatingDate = source.RatingDate;
            else
                targetSynchSupport.IsRatingDateSupported = false;

            if (sourceSynchSupport.IsRatingOrganizationSupported)
                target.RatingOrganization = source.RatingOrganization;
            else
                targetSynchSupport.IsRatingOrganizationSupported = false;

            if (sourceSynchSupport.IsRatingProgramSupported)
                target.RatingProgram = source.RatingProgram;
            else
                targetSynchSupport.IsRatingProgramSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IAccountabilityRatingSynchronizationSourceSupport
    {
        bool IsRatingSupported { get; set; }
        bool IsRatingDateSupported { get; set; }
        bool IsRatingOrganizationSupported { get; set; }
        bool IsRatingProgramSupported { get; set; }
    }
 
}
// Aggregate: AccountCodeDescriptor

namespace EdFi.Ods.Entities.Common //.AccountCodeDescriptorAggregate
{ 
    public static class AccountCodeDescriptorMapper 
    {
        public static bool SynchronizeTo(this IAccountCodeDescriptor source, IAccountCodeDescriptor target)
        {
            bool isModified = false;

            var sourceSupport = source as IAccountCodeDescriptorSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AccountCodeDescriptorId != target.AccountCodeDescriptorId)
            {
                source.AccountCodeDescriptorId = target.AccountCodeDescriptorId;
            }

            // Copy inherited non-PK properties


            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveBeginDateSupported)
                && target.EffectiveBeginDate != source.EffectiveBeginDate)
            {
                target.EffectiveBeginDate = source.EffectiveBeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveEndDateSupported)
                && target.EffectiveEndDate != source.EffectiveEndDate)
            {
                target.EffectiveEndDate = source.EffectiveEndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNamespaceSupported)
                && target.Namespace != source.Namespace)
            {
                target.Namespace = source.Namespace;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPriorDescriptorIdSupported)
                && target.PriorDescriptorId != source.PriorDescriptorId)
            {
                target.PriorDescriptorId = source.PriorDescriptorId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsAccountCodeCategorySupported)
                && target.AccountCodeCategory != source.AccountCodeCategory)
            {
                target.AccountCodeCategory = source.AccountCodeCategory;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsBeginDateSupported)
                && target.BeginDate != source.BeginDate)
            {
                target.BeginDate = source.BeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEndDateSupported)
                && target.EndDate != source.EndDate)
            {
                target.EndDate = source.EndDate;
                isModified = true;
            }

            // Synch inherited lists


            // Sync lists

            return isModified;
        }



        public static void MapTo(this IAccountCodeDescriptor source, IAccountCodeDescriptor target, Action<IAccountCodeDescriptor, IAccountCodeDescriptor> onMapped)
        {
            var sourceSynchSupport = source as IAccountCodeDescriptorSynchronizationSourceSupport;
            var targetSynchSupport = target as IAccountCodeDescriptorSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.AccountCodeDescriptorId = source.AccountCodeDescriptorId;

            // Copy inherited non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsEffectiveBeginDateSupported)
                target.EffectiveBeginDate = source.EffectiveBeginDate;
            else
                targetSynchSupport.IsEffectiveBeginDateSupported = false;

            if (sourceSynchSupport.IsEffectiveEndDateSupported)
                target.EffectiveEndDate = source.EffectiveEndDate;
            else
                targetSynchSupport.IsEffectiveEndDateSupported = false;

            if (sourceSynchSupport.IsNamespaceSupported)
                target.Namespace = source.Namespace;
            else
                targetSynchSupport.IsNamespaceSupported = false;

            if (sourceSynchSupport.IsPriorDescriptorIdSupported)
                target.PriorDescriptorId = source.PriorDescriptorId;
            else
                targetSynchSupport.IsPriorDescriptorIdSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Copy non-PK properties

            if (sourceSynchSupport.IsAccountCodeCategorySupported)
                target.AccountCodeCategory = source.AccountCodeCategory;
            else
                targetSynchSupport.IsAccountCodeCategorySupported = false;

            if (sourceSynchSupport.IsBeginDateSupported)
                target.BeginDate = source.BeginDate;
            else
                targetSynchSupport.IsBeginDateSupported = false;

            if (sourceSynchSupport.IsEndDateSupported)
                target.EndDate = source.EndDate;
            else
                targetSynchSupport.IsEndDateSupported = false;

            // Map inherited lists

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IAccountCodeDescriptorSynchronizationSourceSupport
    {
        bool IsAccountCodeCategorySupported { get; set; }
        bool IsBeginDateSupported { get; set; }
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsEffectiveBeginDateSupported { get; set; }
        bool IsEffectiveEndDateSupported { get; set; }
        bool IsEndDateSupported { get; set; }
        bool IsNamespaceSupported { get; set; }
        bool IsPriorDescriptorIdSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: AchievementCategoryDescriptor

namespace EdFi.Ods.Entities.Common //.AchievementCategoryDescriptorAggregate
{ 
    public static class AchievementCategoryDescriptorMapper 
    {
        public static bool SynchronizeTo(this IAchievementCategoryDescriptor source, IAchievementCategoryDescriptor target)
        {
            bool isModified = false;

            var sourceSupport = source as IAchievementCategoryDescriptorSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AchievementCategoryDescriptorId != target.AchievementCategoryDescriptorId)
            {
                source.AchievementCategoryDescriptorId = target.AchievementCategoryDescriptorId;
            }

            // Copy inherited non-PK properties


            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveBeginDateSupported)
                && target.EffectiveBeginDate != source.EffectiveBeginDate)
            {
                target.EffectiveBeginDate = source.EffectiveBeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveEndDateSupported)
                && target.EffectiveEndDate != source.EffectiveEndDate)
            {
                target.EffectiveEndDate = source.EffectiveEndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNamespaceSupported)
                && target.Namespace != source.Namespace)
            {
                target.Namespace = source.Namespace;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPriorDescriptorIdSupported)
                && target.PriorDescriptorId != source.PriorDescriptorId)
            {
                target.PriorDescriptorId = source.PriorDescriptorId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsAchievementCategoryTypeSupported)
                && target.AchievementCategoryType != source.AchievementCategoryType)
            {
                target.AchievementCategoryType = source.AchievementCategoryType;
                isModified = true;
            }

            // Synch inherited lists


            // Sync lists

            return isModified;
        }



        public static void MapTo(this IAchievementCategoryDescriptor source, IAchievementCategoryDescriptor target, Action<IAchievementCategoryDescriptor, IAchievementCategoryDescriptor> onMapped)
        {
            var sourceSynchSupport = source as IAchievementCategoryDescriptorSynchronizationSourceSupport;
            var targetSynchSupport = target as IAchievementCategoryDescriptorSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.AchievementCategoryDescriptorId = source.AchievementCategoryDescriptorId;

            // Copy inherited non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsEffectiveBeginDateSupported)
                target.EffectiveBeginDate = source.EffectiveBeginDate;
            else
                targetSynchSupport.IsEffectiveBeginDateSupported = false;

            if (sourceSynchSupport.IsEffectiveEndDateSupported)
                target.EffectiveEndDate = source.EffectiveEndDate;
            else
                targetSynchSupport.IsEffectiveEndDateSupported = false;

            if (sourceSynchSupport.IsNamespaceSupported)
                target.Namespace = source.Namespace;
            else
                targetSynchSupport.IsNamespaceSupported = false;

            if (sourceSynchSupport.IsPriorDescriptorIdSupported)
                target.PriorDescriptorId = source.PriorDescriptorId;
            else
                targetSynchSupport.IsPriorDescriptorIdSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Copy non-PK properties

            if (sourceSynchSupport.IsAchievementCategoryTypeSupported)
                target.AchievementCategoryType = source.AchievementCategoryType;
            else
                targetSynchSupport.IsAchievementCategoryTypeSupported = false;

            // Map inherited lists

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IAchievementCategoryDescriptorSynchronizationSourceSupport
    {
        bool IsAchievementCategoryTypeSupported { get; set; }
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsEffectiveBeginDateSupported { get; set; }
        bool IsEffectiveEndDateSupported { get; set; }
        bool IsNamespaceSupported { get; set; }
        bool IsPriorDescriptorIdSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: AchievementCategoryType

namespace EdFi.Ods.Entities.Common //.AchievementCategoryTypeAggregate
{ 
    public static class AchievementCategoryTypeMapper 
    {
        public static bool SynchronizeTo(this IAchievementCategoryType source, IAchievementCategoryType target)
        {
            bool isModified = false;

            var sourceSupport = source as IAchievementCategoryTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AchievementCategoryTypeId != target.AchievementCategoryTypeId)
            {
                source.AchievementCategoryTypeId = target.AchievementCategoryTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IAchievementCategoryType source, IAchievementCategoryType target, Action<IAchievementCategoryType, IAchievementCategoryType> onMapped)
        {
            var sourceSynchSupport = source as IAchievementCategoryTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IAchievementCategoryTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.AchievementCategoryTypeId = source.AchievementCategoryTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IAchievementCategoryTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: Actual

namespace EdFi.Ods.Entities.Common //.ActualAggregate
{ 
    public static class ActualMapper 
    {
        public static bool SynchronizeTo(this IActual source, IActual target)
        {
            bool isModified = false;

            var sourceSupport = source as IActualSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AccountNumber != target.AccountNumber)
            {
                source.AccountNumber = target.AccountNumber;
            }
            if (source.AsOfDate != target.AsOfDate)
            {
                source.AsOfDate = target.AsOfDate;
            }
            if (source.EducationOrganizationId != target.EducationOrganizationId)
            {
                source.EducationOrganizationId = target.EducationOrganizationId;
            }
            if (source.FiscalYear != target.FiscalYear)
            {
                source.FiscalYear = target.FiscalYear;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsAmountToDateSupported)
                && target.AmountToDate != source.AmountToDate)
            {
                target.AmountToDate = source.AmountToDate;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IActual source, IActual target, Action<IActual, IActual> onMapped)
        {
            var sourceSynchSupport = source as IActualSynchronizationSourceSupport;
            var targetSynchSupport = target as IActualSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.AccountNumber = source.AccountNumber;
            target.AsOfDate = source.AsOfDate;
            target.EducationOrganizationId = source.EducationOrganizationId;
            target.FiscalYear = source.FiscalYear;

            // Copy non-PK properties

            if (sourceSynchSupport.IsAmountToDateSupported)
                target.AmountToDate = source.AmountToDate;
            else
                targetSynchSupport.IsAmountToDateSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IActualSynchronizationSourceSupport
    {
        bool IsAmountToDateSupported { get; set; }
    }
 
}
// Aggregate: AdditionalCreditType

namespace EdFi.Ods.Entities.Common //.AdditionalCreditTypeAggregate
{ 
    public static class AdditionalCreditTypeMapper 
    {
        public static bool SynchronizeTo(this IAdditionalCreditType source, IAdditionalCreditType target)
        {
            bool isModified = false;

            var sourceSupport = source as IAdditionalCreditTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AdditionalCreditTypeId != target.AdditionalCreditTypeId)
            {
                source.AdditionalCreditTypeId = target.AdditionalCreditTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IAdditionalCreditType source, IAdditionalCreditType target, Action<IAdditionalCreditType, IAdditionalCreditType> onMapped)
        {
            var sourceSynchSupport = source as IAdditionalCreditTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IAdditionalCreditTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.AdditionalCreditTypeId = source.AdditionalCreditTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IAdditionalCreditTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: AddressType

namespace EdFi.Ods.Entities.Common //.AddressTypeAggregate
{ 
    public static class AddressTypeMapper 
    {
        public static bool SynchronizeTo(this IAddressType source, IAddressType target)
        {
            bool isModified = false;

            var sourceSupport = source as IAddressTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AddressTypeId != target.AddressTypeId)
            {
                source.AddressTypeId = target.AddressTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IAddressType source, IAddressType target, Action<IAddressType, IAddressType> onMapped)
        {
            var sourceSynchSupport = source as IAddressTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IAddressTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.AddressTypeId = source.AddressTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IAddressTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: AdministrationEnvironmentType

namespace EdFi.Ods.Entities.Common //.AdministrationEnvironmentTypeAggregate
{ 
    public static class AdministrationEnvironmentTypeMapper 
    {
        public static bool SynchronizeTo(this IAdministrationEnvironmentType source, IAdministrationEnvironmentType target)
        {
            bool isModified = false;

            var sourceSupport = source as IAdministrationEnvironmentTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AdministrationEnvironmentTypeId != target.AdministrationEnvironmentTypeId)
            {
                source.AdministrationEnvironmentTypeId = target.AdministrationEnvironmentTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IAdministrationEnvironmentType source, IAdministrationEnvironmentType target, Action<IAdministrationEnvironmentType, IAdministrationEnvironmentType> onMapped)
        {
            var sourceSynchSupport = source as IAdministrationEnvironmentTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IAdministrationEnvironmentTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.AdministrationEnvironmentTypeId = source.AdministrationEnvironmentTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IAdministrationEnvironmentTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: AdministrativeFundingControlDescriptor

namespace EdFi.Ods.Entities.Common //.AdministrativeFundingControlDescriptorAggregate
{ 
    public static class AdministrativeFundingControlDescriptorMapper 
    {
        public static bool SynchronizeTo(this IAdministrativeFundingControlDescriptor source, IAdministrativeFundingControlDescriptor target)
        {
            bool isModified = false;

            var sourceSupport = source as IAdministrativeFundingControlDescriptorSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AdministrativeFundingControlDescriptorId != target.AdministrativeFundingControlDescriptorId)
            {
                source.AdministrativeFundingControlDescriptorId = target.AdministrativeFundingControlDescriptorId;
            }

            // Copy inherited non-PK properties


            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveBeginDateSupported)
                && target.EffectiveBeginDate != source.EffectiveBeginDate)
            {
                target.EffectiveBeginDate = source.EffectiveBeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveEndDateSupported)
                && target.EffectiveEndDate != source.EffectiveEndDate)
            {
                target.EffectiveEndDate = source.EffectiveEndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNamespaceSupported)
                && target.Namespace != source.Namespace)
            {
                target.Namespace = source.Namespace;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPriorDescriptorIdSupported)
                && target.PriorDescriptorId != source.PriorDescriptorId)
            {
                target.PriorDescriptorId = source.PriorDescriptorId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsAdministrativeFundingControlTypeSupported)
                && target.AdministrativeFundingControlType != source.AdministrativeFundingControlType)
            {
                target.AdministrativeFundingControlType = source.AdministrativeFundingControlType;
                isModified = true;
            }

            // Synch inherited lists


            // Sync lists

            return isModified;
        }



        public static void MapTo(this IAdministrativeFundingControlDescriptor source, IAdministrativeFundingControlDescriptor target, Action<IAdministrativeFundingControlDescriptor, IAdministrativeFundingControlDescriptor> onMapped)
        {
            var sourceSynchSupport = source as IAdministrativeFundingControlDescriptorSynchronizationSourceSupport;
            var targetSynchSupport = target as IAdministrativeFundingControlDescriptorSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.AdministrativeFundingControlDescriptorId = source.AdministrativeFundingControlDescriptorId;

            // Copy inherited non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsEffectiveBeginDateSupported)
                target.EffectiveBeginDate = source.EffectiveBeginDate;
            else
                targetSynchSupport.IsEffectiveBeginDateSupported = false;

            if (sourceSynchSupport.IsEffectiveEndDateSupported)
                target.EffectiveEndDate = source.EffectiveEndDate;
            else
                targetSynchSupport.IsEffectiveEndDateSupported = false;

            if (sourceSynchSupport.IsNamespaceSupported)
                target.Namespace = source.Namespace;
            else
                targetSynchSupport.IsNamespaceSupported = false;

            if (sourceSynchSupport.IsPriorDescriptorIdSupported)
                target.PriorDescriptorId = source.PriorDescriptorId;
            else
                targetSynchSupport.IsPriorDescriptorIdSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Copy non-PK properties

            if (sourceSynchSupport.IsAdministrativeFundingControlTypeSupported)
                target.AdministrativeFundingControlType = source.AdministrativeFundingControlType;
            else
                targetSynchSupport.IsAdministrativeFundingControlTypeSupported = false;

            // Map inherited lists

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IAdministrativeFundingControlDescriptorSynchronizationSourceSupport
    {
        bool IsAdministrativeFundingControlTypeSupported { get; set; }
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsEffectiveBeginDateSupported { get; set; }
        bool IsEffectiveEndDateSupported { get; set; }
        bool IsNamespaceSupported { get; set; }
        bool IsPriorDescriptorIdSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: AdministrativeFundingControlType

namespace EdFi.Ods.Entities.Common //.AdministrativeFundingControlTypeAggregate
{ 
    public static class AdministrativeFundingControlTypeMapper 
    {
        public static bool SynchronizeTo(this IAdministrativeFundingControlType source, IAdministrativeFundingControlType target)
        {
            bool isModified = false;

            var sourceSupport = source as IAdministrativeFundingControlTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AdministrativeFundingControlTypeId != target.AdministrativeFundingControlTypeId)
            {
                source.AdministrativeFundingControlTypeId = target.AdministrativeFundingControlTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IAdministrativeFundingControlType source, IAdministrativeFundingControlType target, Action<IAdministrativeFundingControlType, IAdministrativeFundingControlType> onMapped)
        {
            var sourceSynchSupport = source as IAdministrativeFundingControlTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IAdministrativeFundingControlTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.AdministrativeFundingControlTypeId = source.AdministrativeFundingControlTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IAdministrativeFundingControlTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: Assessment

namespace EdFi.Ods.Entities.Common //.AssessmentAggregate
{ 
    public static class AssessmentMapper 
    {
        public static bool SynchronizeTo(this IAssessment source, IAssessment target)
        {
            bool isModified = false;

            var sourceSupport = source as IAssessmentSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AssessmentIdentifier != target.AssessmentIdentifier)
            {
                source.AssessmentIdentifier = target.AssessmentIdentifier;
            }
            if (source.Namespace != target.Namespace)
            {
                source.Namespace = target.Namespace;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsAdaptiveAssessmentSupported)
                && target.AdaptiveAssessment != source.AdaptiveAssessment)
            {
                target.AdaptiveAssessment = source.AdaptiveAssessment;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsAssessmentCategoryDescriptorSupported)
                && target.AssessmentCategoryDescriptor != source.AssessmentCategoryDescriptor)
            {
                target.AssessmentCategoryDescriptor = source.AssessmentCategoryDescriptor;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsAssessmentFamilyTitleSupported)
                && target.AssessmentFamilyTitle != source.AssessmentFamilyTitle)
            {
                target.AssessmentFamilyTitle = source.AssessmentFamilyTitle;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsAssessmentFormSupported)
                && target.AssessmentForm != source.AssessmentForm)
            {
                target.AssessmentForm = source.AssessmentForm;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsAssessmentPeriodDescriptorSupported)
                && target.AssessmentPeriodDescriptor != source.AssessmentPeriodDescriptor)
            {
                target.AssessmentPeriodDescriptor = source.AssessmentPeriodDescriptor;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsAssessmentTitleSupported)
                && target.AssessmentTitle != source.AssessmentTitle)
            {
                target.AssessmentTitle = source.AssessmentTitle;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEducationOrganizationIdSupported)
                && target.EducationOrganizationId != source.EducationOrganizationId)
            {
                target.EducationOrganizationId = source.EducationOrganizationId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsMaxRawScoreSupported)
                && target.MaxRawScore != source.MaxRawScore)
            {
                target.MaxRawScore = source.MaxRawScore;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNomenclatureSupported)
                && target.Nomenclature != source.Nomenclature)
            {
                target.Nomenclature = source.Nomenclature;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsRevisionDateSupported)
                && target.RevisionDate != source.RevisionDate)
            {
                target.RevisionDate = source.RevisionDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsVersionSupported)
                && target.Version != source.Version)
            {
                target.Version = source.Version;
                isModified = true;
            }

            // ----------------------------------            
            //   Synch One-to-one relationships
            // ----------------------------------            
            // AssessmentContentStandard
            if (sourceSupport == null || sourceSupport.IsAssessmentContentStandardSupported)
            {
                if (source.AssessmentContentStandard == null)
                {
                    if (target.AssessmentContentStandard != null)
                    {
                        target.AssessmentContentStandard = null;
                        isModified = true;
                    }
                }
                else
                {
                    if (target.AssessmentContentStandard == null)
                    {
                        var itemType = target.GetType().GetProperty("AssessmentContentStandard").PropertyType;
                        var newItem = Activator.CreateInstance(itemType);
                        target.AssessmentContentStandard = (IAssessmentContentStandard) newItem;
                    }

                    isModified |= source.AssessmentContentStandard.Synchronize(target.AssessmentContentStandard);
                }
            }
            
            // -------------------------------------------------------------



            // Sync lists
            if (sourceSupport == null || sourceSupport.IsAssessmentAcademicSubjectsSupported)
                isModified |= source.AssessmentAcademicSubjects.SynchronizeListTo(target.AssessmentAcademicSubjects, child => child.Assessment = target,
                                sourceSupport == null ? null : sourceSupport.IsAssessmentAcademicSubjectIncluded);

            if (sourceSupport == null || sourceSupport.IsAssessmentAssessedGradeLevelsSupported)
                isModified |= source.AssessmentAssessedGradeLevels.SynchronizeListTo(target.AssessmentAssessedGradeLevels, child => child.Assessment = target,
                                sourceSupport == null ? null : sourceSupport.IsAssessmentAssessedGradeLevelIncluded);

            if (sourceSupport == null || sourceSupport.IsAssessmentIdentificationCodesSupported)
                isModified |= source.AssessmentIdentificationCodes.SynchronizeListTo(target.AssessmentIdentificationCodes, child => child.Assessment = target,
                                sourceSupport == null ? null : sourceSupport.IsAssessmentIdentificationCodeIncluded);

            if (sourceSupport == null || sourceSupport.IsAssessmentLanguagesSupported)
                isModified |= source.AssessmentLanguages.SynchronizeListTo(target.AssessmentLanguages, child => child.Assessment = target,
                                sourceSupport == null ? null : sourceSupport.IsAssessmentLanguageIncluded);

            if (sourceSupport == null || sourceSupport.IsAssessmentPerformanceLevelsSupported)
                isModified |= source.AssessmentPerformanceLevels.SynchronizeListTo(target.AssessmentPerformanceLevels, child => child.Assessment = target,
                                sourceSupport == null ? null : sourceSupport.IsAssessmentPerformanceLevelIncluded);

            if (sourceSupport == null || sourceSupport.IsAssessmentProgramsSupported)
                isModified |= source.AssessmentPrograms.SynchronizeListTo(target.AssessmentPrograms, child => child.Assessment = target,
                                sourceSupport == null ? null : sourceSupport.IsAssessmentProgramIncluded);

            if (sourceSupport == null || sourceSupport.IsAssessmentScoresSupported)
                isModified |= source.AssessmentScores.SynchronizeListTo(target.AssessmentScores, child => child.Assessment = target,
                                sourceSupport == null ? null : sourceSupport.IsAssessmentScoreIncluded);

            if (sourceSupport == null || sourceSupport.IsAssessmentSectionsSupported)
                isModified |= source.AssessmentSections.SynchronizeListTo(target.AssessmentSections, child => child.Assessment = target,
                                sourceSupport == null ? null : sourceSupport.IsAssessmentSectionIncluded);


            return isModified;
        }



        public static void MapTo(this IAssessment source, IAssessment target, Action<IAssessment, IAssessment> onMapped)
        {
            var sourceSynchSupport = source as IAssessmentSynchronizationSourceSupport;
            var targetSynchSupport = target as IAssessmentSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.AssessmentIdentifier = source.AssessmentIdentifier;
            target.Namespace = source.Namespace;

            // Copy non-PK properties

            if (sourceSynchSupport.IsAdaptiveAssessmentSupported)
                target.AdaptiveAssessment = source.AdaptiveAssessment;
            else
                targetSynchSupport.IsAdaptiveAssessmentSupported = false;

            if (sourceSynchSupport.IsAssessmentCategoryDescriptorSupported)
                target.AssessmentCategoryDescriptor = source.AssessmentCategoryDescriptor;
            else
                targetSynchSupport.IsAssessmentCategoryDescriptorSupported = false;

            if (sourceSynchSupport.IsAssessmentFamilyTitleSupported)
                target.AssessmentFamilyTitle = source.AssessmentFamilyTitle;
            else
                targetSynchSupport.IsAssessmentFamilyTitleSupported = false;

            if (sourceSynchSupport.IsAssessmentFormSupported)
                target.AssessmentForm = source.AssessmentForm;
            else
                targetSynchSupport.IsAssessmentFormSupported = false;

            if (sourceSynchSupport.IsAssessmentPeriodDescriptorSupported)
                target.AssessmentPeriodDescriptor = source.AssessmentPeriodDescriptor;
            else
                targetSynchSupport.IsAssessmentPeriodDescriptorSupported = false;

            if (sourceSynchSupport.IsAssessmentTitleSupported)
                target.AssessmentTitle = source.AssessmentTitle;
            else
                targetSynchSupport.IsAssessmentTitleSupported = false;

            if (sourceSynchSupport.IsEducationOrganizationIdSupported)
                target.EducationOrganizationId = source.EducationOrganizationId;
            else
                targetSynchSupport.IsEducationOrganizationIdSupported = false;

            if (sourceSynchSupport.IsMaxRawScoreSupported)
                target.MaxRawScore = source.MaxRawScore;
            else
                targetSynchSupport.IsMaxRawScoreSupported = false;

            if (sourceSynchSupport.IsNomenclatureSupported)
                target.Nomenclature = source.Nomenclature;
            else
                targetSynchSupport.IsNomenclatureSupported = false;

            if (sourceSynchSupport.IsRevisionDateSupported)
                target.RevisionDate = source.RevisionDate;
            else
                targetSynchSupport.IsRevisionDateSupported = false;

            if (sourceSynchSupport.IsVersionSupported)
                target.Version = source.Version;
            else
                targetSynchSupport.IsVersionSupported = false;

            // ----------------------------------
            //   Map One-to-one relationships
            // ----------------------------------
            // AssessmentContentStandard (Source)
            if (sourceSynchSupport.IsAssessmentContentStandardSupported)
            {
                var itemProperty = target.GetType().GetProperty("AssessmentContentStandard");
                
                if (itemProperty != null)
                {                    
                    if (source.AssessmentContentStandard == null)
                    {
                        target.AssessmentContentStandard = null;
                    }
                    else
                    {
                        var itemType = itemProperty.PropertyType;
                        object targetAssessmentContentStandard = Activator.CreateInstance(itemType);

                        source.AssessmentContentStandard.Map(targetAssessmentContentStandard);
                        
                        // Update the target reference appropriately
                        target.AssessmentContentStandard = (IAssessmentContentStandard) targetAssessmentContentStandard;
                    }
                }
            }
            else
            {
                targetSynchSupport.IsAssessmentContentStandardSupported = false; 
            }
            // -------------------------------------------------------------

            // Map lists

            if (sourceSynchSupport.IsAssessmentAcademicSubjectsSupported)
            {    
                targetSynchSupport.IsAssessmentAcademicSubjectIncluded = sourceSynchSupport.IsAssessmentAcademicSubjectIncluded;
                source.AssessmentAcademicSubjects.MapListTo(target.AssessmentAcademicSubjects);
            }
            else
            {
                targetSynchSupport.IsAssessmentAcademicSubjectsSupported = false;
            }

            if (sourceSynchSupport.IsAssessmentAssessedGradeLevelsSupported)
            {    
                targetSynchSupport.IsAssessmentAssessedGradeLevelIncluded = sourceSynchSupport.IsAssessmentAssessedGradeLevelIncluded;
                source.AssessmentAssessedGradeLevels.MapListTo(target.AssessmentAssessedGradeLevels);
            }
            else
            {
                targetSynchSupport.IsAssessmentAssessedGradeLevelsSupported = false;
            }

            if (sourceSynchSupport.IsAssessmentIdentificationCodesSupported)
            {    
                targetSynchSupport.IsAssessmentIdentificationCodeIncluded = sourceSynchSupport.IsAssessmentIdentificationCodeIncluded;
                source.AssessmentIdentificationCodes.MapListTo(target.AssessmentIdentificationCodes);
            }
            else
            {
                targetSynchSupport.IsAssessmentIdentificationCodesSupported = false;
            }

            if (sourceSynchSupport.IsAssessmentLanguagesSupported)
            {    
                targetSynchSupport.IsAssessmentLanguageIncluded = sourceSynchSupport.IsAssessmentLanguageIncluded;
                source.AssessmentLanguages.MapListTo(target.AssessmentLanguages);
            }
            else
            {
                targetSynchSupport.IsAssessmentLanguagesSupported = false;
            }

            if (sourceSynchSupport.IsAssessmentPerformanceLevelsSupported)
            {    
                targetSynchSupport.IsAssessmentPerformanceLevelIncluded = sourceSynchSupport.IsAssessmentPerformanceLevelIncluded;
                source.AssessmentPerformanceLevels.MapListTo(target.AssessmentPerformanceLevels);
            }
            else
            {
                targetSynchSupport.IsAssessmentPerformanceLevelsSupported = false;
            }

            if (sourceSynchSupport.IsAssessmentProgramsSupported)
            {    
                targetSynchSupport.IsAssessmentProgramIncluded = sourceSynchSupport.IsAssessmentProgramIncluded;
                source.AssessmentPrograms.MapListTo(target.AssessmentPrograms);
            }
            else
            {
                targetSynchSupport.IsAssessmentProgramsSupported = false;
            }

            if (sourceSynchSupport.IsAssessmentScoresSupported)
            {    
                targetSynchSupport.IsAssessmentScoreIncluded = sourceSynchSupport.IsAssessmentScoreIncluded;
                source.AssessmentScores.MapListTo(target.AssessmentScores);
            }
            else
            {
                targetSynchSupport.IsAssessmentScoresSupported = false;
            }

            if (sourceSynchSupport.IsAssessmentSectionsSupported)
            {    
                targetSynchSupport.IsAssessmentSectionIncluded = sourceSynchSupport.IsAssessmentSectionIncluded;
                source.AssessmentSections.MapListTo(target.AssessmentSections);
            }
            else
            {
                targetSynchSupport.IsAssessmentSectionsSupported = false;
            }

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IAssessmentSynchronizationSourceSupport
    {
        bool IsAdaptiveAssessmentSupported { get; set; }
        bool IsAssessmentAcademicSubjectsSupported { get; set; }
        bool IsAssessmentAssessedGradeLevelsSupported { get; set; }
        bool IsAssessmentCategoryDescriptorSupported { get; set; }
        bool IsAssessmentContentStandardSupported { get; set; }
        bool IsAssessmentFamilyTitleSupported { get; set; }
        bool IsAssessmentFormSupported { get; set; }
        bool IsAssessmentIdentificationCodesSupported { get; set; }
        bool IsAssessmentLanguagesSupported { get; set; }
        bool IsAssessmentPerformanceLevelsSupported { get; set; }
        bool IsAssessmentPeriodDescriptorSupported { get; set; }
        bool IsAssessmentProgramsSupported { get; set; }
        bool IsAssessmentScoresSupported { get; set; }
        bool IsAssessmentSectionsSupported { get; set; }
        bool IsAssessmentTitleSupported { get; set; }
        bool IsEducationOrganizationIdSupported { get; set; }
        bool IsMaxRawScoreSupported { get; set; }
        bool IsNomenclatureSupported { get; set; }
        bool IsRevisionDateSupported { get; set; }
        bool IsVersionSupported { get; set; }
        Func<IAssessmentAcademicSubject, bool> IsAssessmentAcademicSubjectIncluded { get; set; }
        Func<IAssessmentAssessedGradeLevel, bool> IsAssessmentAssessedGradeLevelIncluded { get; set; }
        Func<IAssessmentIdentificationCode, bool> IsAssessmentIdentificationCodeIncluded { get; set; }
        Func<IAssessmentLanguage, bool> IsAssessmentLanguageIncluded { get; set; }
        Func<IAssessmentPerformanceLevel, bool> IsAssessmentPerformanceLevelIncluded { get; set; }
        Func<IAssessmentProgram, bool> IsAssessmentProgramIncluded { get; set; }
        Func<IAssessmentScore, bool> IsAssessmentScoreIncluded { get; set; }
        Func<IAssessmentSection, bool> IsAssessmentSectionIncluded { get; set; }
    }
 
    public static class AssessmentAcademicSubjectMapper 
    {
        public static bool SynchronizeTo(this IAssessmentAcademicSubject source, IAssessmentAcademicSubject target)
        {
            bool isModified = false;

            var sourceSupport = source as IAssessmentAcademicSubjectSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AcademicSubjectDescriptor != target.AcademicSubjectDescriptor)
            {
                source.AcademicSubjectDescriptor = target.AcademicSubjectDescriptor;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IAssessmentAcademicSubject source, IAssessmentAcademicSubject target, Action<IAssessmentAcademicSubject, IAssessmentAcademicSubject> onMapped)
        {
            var sourceSynchSupport = source as IAssessmentAcademicSubjectSynchronizationSourceSupport;
            var targetSynchSupport = target as IAssessmentAcademicSubjectSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.AcademicSubjectDescriptor = source.AcademicSubjectDescriptor;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IAssessmentAcademicSubjectSynchronizationSourceSupport
    {
    }
 
    public static class AssessmentAssessedGradeLevelMapper 
    {
        public static bool SynchronizeTo(this IAssessmentAssessedGradeLevel source, IAssessmentAssessedGradeLevel target)
        {
            bool isModified = false;

            var sourceSupport = source as IAssessmentAssessedGradeLevelSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.GradeLevelDescriptor != target.GradeLevelDescriptor)
            {
                source.GradeLevelDescriptor = target.GradeLevelDescriptor;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IAssessmentAssessedGradeLevel source, IAssessmentAssessedGradeLevel target, Action<IAssessmentAssessedGradeLevel, IAssessmentAssessedGradeLevel> onMapped)
        {
            var sourceSynchSupport = source as IAssessmentAssessedGradeLevelSynchronizationSourceSupport;
            var targetSynchSupport = target as IAssessmentAssessedGradeLevelSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.GradeLevelDescriptor = source.GradeLevelDescriptor;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IAssessmentAssessedGradeLevelSynchronizationSourceSupport
    {
    }
 
    public static class AssessmentContentStandardMapper 
    {
        public static bool SynchronizeTo(this IAssessmentContentStandard source, IAssessmentContentStandard target)
        {
            bool isModified = false;

            var sourceSupport = source as IAssessmentContentStandardSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsBeginDateSupported)
                && target.BeginDate != source.BeginDate)
            {
                target.BeginDate = source.BeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEndDateSupported)
                && target.EndDate != source.EndDate)
            {
                target.EndDate = source.EndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsMandatingEducationOrganizationIdSupported)
                && target.MandatingEducationOrganizationId != source.MandatingEducationOrganizationId)
            {
                target.MandatingEducationOrganizationId = source.MandatingEducationOrganizationId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPublicationDateSupported)
                && target.PublicationDate != source.PublicationDate)
            {
                target.PublicationDate = source.PublicationDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPublicationStatusTypeSupported)
                && target.PublicationStatusType != source.PublicationStatusType)
            {
                target.PublicationStatusType = source.PublicationStatusType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPublicationYearSupported)
                && target.PublicationYear != source.PublicationYear)
            {
                target.PublicationYear = source.PublicationYear;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsTitleSupported)
                && target.Title != source.Title)
            {
                target.Title = source.Title;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsURISupported)
                && target.URI != source.URI)
            {
                target.URI = source.URI;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsVersionSupported)
                && target.Version != source.Version)
            {
                target.Version = source.Version;
                isModified = true;
            }



            // Sync lists
            if (sourceSupport == null || sourceSupport.IsAssessmentContentStandardAuthorsSupported)
                isModified |= source.AssessmentContentStandardAuthors.SynchronizeListTo(target.AssessmentContentStandardAuthors, child => child.AssessmentContentStandard = target,
                                sourceSupport == null ? null : sourceSupport.IsAssessmentContentStandardAuthorIncluded);


            return isModified;
        }



        public static void MapTo(this IAssessmentContentStandard source, IAssessmentContentStandard target, Action<IAssessmentContentStandard, IAssessmentContentStandard> onMapped)
        {
            var sourceSynchSupport = source as IAssessmentContentStandardSynchronizationSourceSupport;
            var targetSynchSupport = target as IAssessmentContentStandardSynchronizationSourceSupport;

            // Copy contextual primary key values

            // Copy non-PK properties

            if (sourceSynchSupport.IsBeginDateSupported)
                target.BeginDate = source.BeginDate;
            else
                targetSynchSupport.IsBeginDateSupported = false;

            if (sourceSynchSupport.IsEndDateSupported)
                target.EndDate = source.EndDate;
            else
                targetSynchSupport.IsEndDateSupported = false;

            if (sourceSynchSupport.IsMandatingEducationOrganizationIdSupported)
                target.MandatingEducationOrganizationId = source.MandatingEducationOrganizationId;
            else
                targetSynchSupport.IsMandatingEducationOrganizationIdSupported = false;

            if (sourceSynchSupport.IsPublicationDateSupported)
                target.PublicationDate = source.PublicationDate;
            else
                targetSynchSupport.IsPublicationDateSupported = false;

            if (sourceSynchSupport.IsPublicationStatusTypeSupported)
                target.PublicationStatusType = source.PublicationStatusType;
            else
                targetSynchSupport.IsPublicationStatusTypeSupported = false;

            if (sourceSynchSupport.IsPublicationYearSupported)
                target.PublicationYear = source.PublicationYear;
            else
                targetSynchSupport.IsPublicationYearSupported = false;

            if (sourceSynchSupport.IsTitleSupported)
                target.Title = source.Title;
            else
                targetSynchSupport.IsTitleSupported = false;

            if (sourceSynchSupport.IsURISupported)
                target.URI = source.URI;
            else
                targetSynchSupport.IsURISupported = false;

            if (sourceSynchSupport.IsVersionSupported)
                target.Version = source.Version;
            else
                targetSynchSupport.IsVersionSupported = false;

            // Map lists

            if (sourceSynchSupport.IsAssessmentContentStandardAuthorsSupported)
            {    
                targetSynchSupport.IsAssessmentContentStandardAuthorIncluded = sourceSynchSupport.IsAssessmentContentStandardAuthorIncluded;
                source.AssessmentContentStandardAuthors.MapListTo(target.AssessmentContentStandardAuthors);
            }
            else
            {
                targetSynchSupport.IsAssessmentContentStandardAuthorsSupported = false;
            }

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IAssessmentContentStandardSynchronizationSourceSupport
    {
        bool IsAssessmentContentStandardAuthorsSupported { get; set; }
        bool IsBeginDateSupported { get; set; }
        bool IsEndDateSupported { get; set; }
        bool IsMandatingEducationOrganizationIdSupported { get; set; }
        bool IsPublicationDateSupported { get; set; }
        bool IsPublicationStatusTypeSupported { get; set; }
        bool IsPublicationYearSupported { get; set; }
        bool IsTitleSupported { get; set; }
        bool IsURISupported { get; set; }
        bool IsVersionSupported { get; set; }
        Func<IAssessmentContentStandardAuthor, bool> IsAssessmentContentStandardAuthorIncluded { get; set; }
    }
 
    public static class AssessmentContentStandardAuthorMapper 
    {
        public static bool SynchronizeTo(this IAssessmentContentStandardAuthor source, IAssessmentContentStandardAuthor target)
        {
            bool isModified = false;

            var sourceSupport = source as IAssessmentContentStandardAuthorSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.Author != target.Author)
            {
                source.Author = target.Author;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IAssessmentContentStandardAuthor source, IAssessmentContentStandardAuthor target, Action<IAssessmentContentStandardAuthor, IAssessmentContentStandardAuthor> onMapped)
        {
            var sourceSynchSupport = source as IAssessmentContentStandardAuthorSynchronizationSourceSupport;
            var targetSynchSupport = target as IAssessmentContentStandardAuthorSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.Author = source.Author;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IAssessmentContentStandardAuthorSynchronizationSourceSupport
    {
    }
 
    public static class AssessmentIdentificationCodeMapper 
    {
        public static bool SynchronizeTo(this IAssessmentIdentificationCode source, IAssessmentIdentificationCode target)
        {
            bool isModified = false;

            var sourceSupport = source as IAssessmentIdentificationCodeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AssessmentIdentificationSystemDescriptor != target.AssessmentIdentificationSystemDescriptor)
            {
                source.AssessmentIdentificationSystemDescriptor = target.AssessmentIdentificationSystemDescriptor;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsAssigningOrganizationIdentificationCodeSupported)
                && target.AssigningOrganizationIdentificationCode != source.AssigningOrganizationIdentificationCode)
            {
                target.AssigningOrganizationIdentificationCode = source.AssigningOrganizationIdentificationCode;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsIdentificationCodeSupported)
                && target.IdentificationCode != source.IdentificationCode)
            {
                target.IdentificationCode = source.IdentificationCode;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IAssessmentIdentificationCode source, IAssessmentIdentificationCode target, Action<IAssessmentIdentificationCode, IAssessmentIdentificationCode> onMapped)
        {
            var sourceSynchSupport = source as IAssessmentIdentificationCodeSynchronizationSourceSupport;
            var targetSynchSupport = target as IAssessmentIdentificationCodeSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.AssessmentIdentificationSystemDescriptor = source.AssessmentIdentificationSystemDescriptor;

            // Copy non-PK properties

            if (sourceSynchSupport.IsAssigningOrganizationIdentificationCodeSupported)
                target.AssigningOrganizationIdentificationCode = source.AssigningOrganizationIdentificationCode;
            else
                targetSynchSupport.IsAssigningOrganizationIdentificationCodeSupported = false;

            if (sourceSynchSupport.IsIdentificationCodeSupported)
                target.IdentificationCode = source.IdentificationCode;
            else
                targetSynchSupport.IsIdentificationCodeSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IAssessmentIdentificationCodeSynchronizationSourceSupport
    {
        bool IsAssigningOrganizationIdentificationCodeSupported { get; set; }
        bool IsIdentificationCodeSupported { get; set; }
    }
 
    public static class AssessmentLanguageMapper 
    {
        public static bool SynchronizeTo(this IAssessmentLanguage source, IAssessmentLanguage target)
        {
            bool isModified = false;

            var sourceSupport = source as IAssessmentLanguageSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.LanguageDescriptor != target.LanguageDescriptor)
            {
                source.LanguageDescriptor = target.LanguageDescriptor;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IAssessmentLanguage source, IAssessmentLanguage target, Action<IAssessmentLanguage, IAssessmentLanguage> onMapped)
        {
            var sourceSynchSupport = source as IAssessmentLanguageSynchronizationSourceSupport;
            var targetSynchSupport = target as IAssessmentLanguageSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.LanguageDescriptor = source.LanguageDescriptor;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IAssessmentLanguageSynchronizationSourceSupport
    {
    }
 
    public static class AssessmentPerformanceLevelMapper 
    {
        public static bool SynchronizeTo(this IAssessmentPerformanceLevel source, IAssessmentPerformanceLevel target)
        {
            bool isModified = false;

            var sourceSupport = source as IAssessmentPerformanceLevelSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AssessmentReportingMethodType != target.AssessmentReportingMethodType)
            {
                source.AssessmentReportingMethodType = target.AssessmentReportingMethodType;
            }
            if (source.PerformanceLevelDescriptor != target.PerformanceLevelDescriptor)
            {
                source.PerformanceLevelDescriptor = target.PerformanceLevelDescriptor;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsMaximumScoreSupported)
                && target.MaximumScore != source.MaximumScore)
            {
                target.MaximumScore = source.MaximumScore;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsMinimumScoreSupported)
                && target.MinimumScore != source.MinimumScore)
            {
                target.MinimumScore = source.MinimumScore;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsResultDatatypeTypeSupported)
                && target.ResultDatatypeType != source.ResultDatatypeType)
            {
                target.ResultDatatypeType = source.ResultDatatypeType;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IAssessmentPerformanceLevel source, IAssessmentPerformanceLevel target, Action<IAssessmentPerformanceLevel, IAssessmentPerformanceLevel> onMapped)
        {
            var sourceSynchSupport = source as IAssessmentPerformanceLevelSynchronizationSourceSupport;
            var targetSynchSupport = target as IAssessmentPerformanceLevelSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.AssessmentReportingMethodType = source.AssessmentReportingMethodType;
            target.PerformanceLevelDescriptor = source.PerformanceLevelDescriptor;

            // Copy non-PK properties

            if (sourceSynchSupport.IsMaximumScoreSupported)
                target.MaximumScore = source.MaximumScore;
            else
                targetSynchSupport.IsMaximumScoreSupported = false;

            if (sourceSynchSupport.IsMinimumScoreSupported)
                target.MinimumScore = source.MinimumScore;
            else
                targetSynchSupport.IsMinimumScoreSupported = false;

            if (sourceSynchSupport.IsResultDatatypeTypeSupported)
                target.ResultDatatypeType = source.ResultDatatypeType;
            else
                targetSynchSupport.IsResultDatatypeTypeSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IAssessmentPerformanceLevelSynchronizationSourceSupport
    {
        bool IsMaximumScoreSupported { get; set; }
        bool IsMinimumScoreSupported { get; set; }
        bool IsResultDatatypeTypeSupported { get; set; }
    }
 
    public static class AssessmentProgramMapper 
    {
        public static bool SynchronizeTo(this IAssessmentProgram source, IAssessmentProgram target)
        {
            bool isModified = false;

            var sourceSupport = source as IAssessmentProgramSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.EducationOrganizationId != target.EducationOrganizationId)
            {
                source.EducationOrganizationId = target.EducationOrganizationId;
            }
            if (source.ProgramName != target.ProgramName)
            {
                source.ProgramName = target.ProgramName;
            }
            if (source.ProgramType != target.ProgramType)
            {
                source.ProgramType = target.ProgramType;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IAssessmentProgram source, IAssessmentProgram target, Action<IAssessmentProgram, IAssessmentProgram> onMapped)
        {
            var sourceSynchSupport = source as IAssessmentProgramSynchronizationSourceSupport;
            var targetSynchSupport = target as IAssessmentProgramSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.EducationOrganizationId = source.EducationOrganizationId;
            target.ProgramName = source.ProgramName;
            target.ProgramType = source.ProgramType;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IAssessmentProgramSynchronizationSourceSupport
    {
    }
 
    public static class AssessmentScoreMapper 
    {
        public static bool SynchronizeTo(this IAssessmentScore source, IAssessmentScore target)
        {
            bool isModified = false;

            var sourceSupport = source as IAssessmentScoreSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AssessmentReportingMethodType != target.AssessmentReportingMethodType)
            {
                source.AssessmentReportingMethodType = target.AssessmentReportingMethodType;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsMaximumScoreSupported)
                && target.MaximumScore != source.MaximumScore)
            {
                target.MaximumScore = source.MaximumScore;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsMinimumScoreSupported)
                && target.MinimumScore != source.MinimumScore)
            {
                target.MinimumScore = source.MinimumScore;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsResultDatatypeTypeSupported)
                && target.ResultDatatypeType != source.ResultDatatypeType)
            {
                target.ResultDatatypeType = source.ResultDatatypeType;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IAssessmentScore source, IAssessmentScore target, Action<IAssessmentScore, IAssessmentScore> onMapped)
        {
            var sourceSynchSupport = source as IAssessmentScoreSynchronizationSourceSupport;
            var targetSynchSupport = target as IAssessmentScoreSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.AssessmentReportingMethodType = source.AssessmentReportingMethodType;

            // Copy non-PK properties

            if (sourceSynchSupport.IsMaximumScoreSupported)
                target.MaximumScore = source.MaximumScore;
            else
                targetSynchSupport.IsMaximumScoreSupported = false;

            if (sourceSynchSupport.IsMinimumScoreSupported)
                target.MinimumScore = source.MinimumScore;
            else
                targetSynchSupport.IsMinimumScoreSupported = false;

            if (sourceSynchSupport.IsResultDatatypeTypeSupported)
                target.ResultDatatypeType = source.ResultDatatypeType;
            else
                targetSynchSupport.IsResultDatatypeTypeSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IAssessmentScoreSynchronizationSourceSupport
    {
        bool IsMaximumScoreSupported { get; set; }
        bool IsMinimumScoreSupported { get; set; }
        bool IsResultDatatypeTypeSupported { get; set; }
    }
 
    public static class AssessmentSectionMapper 
    {
        public static bool SynchronizeTo(this IAssessmentSection source, IAssessmentSection target)
        {
            bool isModified = false;

            var sourceSupport = source as IAssessmentSectionSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.ClassPeriodName != target.ClassPeriodName)
            {
                source.ClassPeriodName = target.ClassPeriodName;
            }
            if (source.ClassroomIdentificationCode != target.ClassroomIdentificationCode)
            {
                source.ClassroomIdentificationCode = target.ClassroomIdentificationCode;
            }
            if (source.LocalCourseCode != target.LocalCourseCode)
            {
                source.LocalCourseCode = target.LocalCourseCode;
            }
            if (source.SchoolId != target.SchoolId)
            {
                source.SchoolId = target.SchoolId;
            }
            if (source.SchoolYear != target.SchoolYear)
            {
                source.SchoolYear = target.SchoolYear;
            }
            if (source.SequenceOfCourse != target.SequenceOfCourse)
            {
                source.SequenceOfCourse = target.SequenceOfCourse;
            }
            if (source.TermDescriptor != target.TermDescriptor)
            {
                source.TermDescriptor = target.TermDescriptor;
            }
            if (source.UniqueSectionCode != target.UniqueSectionCode)
            {
                source.UniqueSectionCode = target.UniqueSectionCode;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IAssessmentSection source, IAssessmentSection target, Action<IAssessmentSection, IAssessmentSection> onMapped)
        {
            var sourceSynchSupport = source as IAssessmentSectionSynchronizationSourceSupport;
            var targetSynchSupport = target as IAssessmentSectionSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.ClassPeriodName = source.ClassPeriodName;
            target.ClassroomIdentificationCode = source.ClassroomIdentificationCode;
            target.LocalCourseCode = source.LocalCourseCode;
            target.SchoolId = source.SchoolId;
            target.SchoolYear = source.SchoolYear;
            target.SequenceOfCourse = source.SequenceOfCourse;
            target.TermDescriptor = source.TermDescriptor;
            target.UniqueSectionCode = source.UniqueSectionCode;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IAssessmentSectionSynchronizationSourceSupport
    {
    }
 
}
// Aggregate: AssessmentCategoryDescriptor

namespace EdFi.Ods.Entities.Common //.AssessmentCategoryDescriptorAggregate
{ 
    public static class AssessmentCategoryDescriptorMapper 
    {
        public static bool SynchronizeTo(this IAssessmentCategoryDescriptor source, IAssessmentCategoryDescriptor target)
        {
            bool isModified = false;

            var sourceSupport = source as IAssessmentCategoryDescriptorSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AssessmentCategoryDescriptorId != target.AssessmentCategoryDescriptorId)
            {
                source.AssessmentCategoryDescriptorId = target.AssessmentCategoryDescriptorId;
            }

            // Copy inherited non-PK properties


            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveBeginDateSupported)
                && target.EffectiveBeginDate != source.EffectiveBeginDate)
            {
                target.EffectiveBeginDate = source.EffectiveBeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveEndDateSupported)
                && target.EffectiveEndDate != source.EffectiveEndDate)
            {
                target.EffectiveEndDate = source.EffectiveEndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNamespaceSupported)
                && target.Namespace != source.Namespace)
            {
                target.Namespace = source.Namespace;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPriorDescriptorIdSupported)
                && target.PriorDescriptorId != source.PriorDescriptorId)
            {
                target.PriorDescriptorId = source.PriorDescriptorId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsAssessmentCategoryTypeSupported)
                && target.AssessmentCategoryType != source.AssessmentCategoryType)
            {
                target.AssessmentCategoryType = source.AssessmentCategoryType;
                isModified = true;
            }

            // Synch inherited lists


            // Sync lists

            return isModified;
        }



        public static void MapTo(this IAssessmentCategoryDescriptor source, IAssessmentCategoryDescriptor target, Action<IAssessmentCategoryDescriptor, IAssessmentCategoryDescriptor> onMapped)
        {
            var sourceSynchSupport = source as IAssessmentCategoryDescriptorSynchronizationSourceSupport;
            var targetSynchSupport = target as IAssessmentCategoryDescriptorSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.AssessmentCategoryDescriptorId = source.AssessmentCategoryDescriptorId;

            // Copy inherited non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsEffectiveBeginDateSupported)
                target.EffectiveBeginDate = source.EffectiveBeginDate;
            else
                targetSynchSupport.IsEffectiveBeginDateSupported = false;

            if (sourceSynchSupport.IsEffectiveEndDateSupported)
                target.EffectiveEndDate = source.EffectiveEndDate;
            else
                targetSynchSupport.IsEffectiveEndDateSupported = false;

            if (sourceSynchSupport.IsNamespaceSupported)
                target.Namespace = source.Namespace;
            else
                targetSynchSupport.IsNamespaceSupported = false;

            if (sourceSynchSupport.IsPriorDescriptorIdSupported)
                target.PriorDescriptorId = source.PriorDescriptorId;
            else
                targetSynchSupport.IsPriorDescriptorIdSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Copy non-PK properties

            if (sourceSynchSupport.IsAssessmentCategoryTypeSupported)
                target.AssessmentCategoryType = source.AssessmentCategoryType;
            else
                targetSynchSupport.IsAssessmentCategoryTypeSupported = false;

            // Map inherited lists

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IAssessmentCategoryDescriptorSynchronizationSourceSupport
    {
        bool IsAssessmentCategoryTypeSupported { get; set; }
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsEffectiveBeginDateSupported { get; set; }
        bool IsEffectiveEndDateSupported { get; set; }
        bool IsNamespaceSupported { get; set; }
        bool IsPriorDescriptorIdSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: AssessmentCategoryType

namespace EdFi.Ods.Entities.Common //.AssessmentCategoryTypeAggregate
{ 
    public static class AssessmentCategoryTypeMapper 
    {
        public static bool SynchronizeTo(this IAssessmentCategoryType source, IAssessmentCategoryType target)
        {
            bool isModified = false;

            var sourceSupport = source as IAssessmentCategoryTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AssessmentCategoryTypeId != target.AssessmentCategoryTypeId)
            {
                source.AssessmentCategoryTypeId = target.AssessmentCategoryTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IAssessmentCategoryType source, IAssessmentCategoryType target, Action<IAssessmentCategoryType, IAssessmentCategoryType> onMapped)
        {
            var sourceSynchSupport = source as IAssessmentCategoryTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IAssessmentCategoryTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.AssessmentCategoryTypeId = source.AssessmentCategoryTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IAssessmentCategoryTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: AssessmentFamily

namespace EdFi.Ods.Entities.Common //.AssessmentFamilyAggregate
{ 
    public static class AssessmentFamilyMapper 
    {
        public static bool SynchronizeTo(this IAssessmentFamily source, IAssessmentFamily target)
        {
            bool isModified = false;

            var sourceSupport = source as IAssessmentFamilySynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AssessmentFamilyTitle != target.AssessmentFamilyTitle)
            {
                source.AssessmentFamilyTitle = target.AssessmentFamilyTitle;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsAcademicSubjectDescriptorSupported)
                && target.AcademicSubjectDescriptor != source.AcademicSubjectDescriptor)
            {
                target.AcademicSubjectDescriptor = source.AcademicSubjectDescriptor;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsAssessedGradeLevelDescriptorSupported)
                && target.AssessedGradeLevelDescriptor != source.AssessedGradeLevelDescriptor)
            {
                target.AssessedGradeLevelDescriptor = source.AssessedGradeLevelDescriptor;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsAssessmentCategoryDescriptorSupported)
                && target.AssessmentCategoryDescriptor != source.AssessmentCategoryDescriptor)
            {
                target.AssessmentCategoryDescriptor = source.AssessmentCategoryDescriptor;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsLowestAssessedGradeLevelDescriptorSupported)
                && target.LowestAssessedGradeLevelDescriptor != source.LowestAssessedGradeLevelDescriptor)
            {
                target.LowestAssessedGradeLevelDescriptor = source.LowestAssessedGradeLevelDescriptor;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNamespaceSupported)
                && target.Namespace != source.Namespace)
            {
                target.Namespace = source.Namespace;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNomenclatureSupported)
                && target.Nomenclature != source.Nomenclature)
            {
                target.Nomenclature = source.Nomenclature;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsParentAssessmentFamilyTitleSupported)
                && target.ParentAssessmentFamilyTitle != source.ParentAssessmentFamilyTitle)
            {
                target.ParentAssessmentFamilyTitle = source.ParentAssessmentFamilyTitle;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsRevisionDateSupported)
                && target.RevisionDate != source.RevisionDate)
            {
                target.RevisionDate = source.RevisionDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsVersionSupported)
                && target.Version != source.Version)
            {
                target.Version = source.Version;
                isModified = true;
            }

            // ----------------------------------            
            //   Synch One-to-one relationships
            // ----------------------------------            
            // AssessmentFamilyContentStandard
            if (sourceSupport == null || sourceSupport.IsAssessmentFamilyContentStandardSupported)
            {
                if (source.AssessmentFamilyContentStandard == null)
                {
                    if (target.AssessmentFamilyContentStandard != null)
                    {
                        target.AssessmentFamilyContentStandard = null;
                        isModified = true;
                    }
                }
                else
                {
                    if (target.AssessmentFamilyContentStandard == null)
                    {
                        var itemType = target.GetType().GetProperty("AssessmentFamilyContentStandard").PropertyType;
                        var newItem = Activator.CreateInstance(itemType);
                        target.AssessmentFamilyContentStandard = (IAssessmentFamilyContentStandard) newItem;
                    }

                    isModified |= source.AssessmentFamilyContentStandard.Synchronize(target.AssessmentFamilyContentStandard);
                }
            }
            
            // -------------------------------------------------------------



            // Sync lists
            if (sourceSupport == null || sourceSupport.IsAssessmentFamilyAssessmentPeriodsSupported)
                isModified |= source.AssessmentFamilyAssessmentPeriods.SynchronizeListTo(target.AssessmentFamilyAssessmentPeriods, child => child.AssessmentFamily = target,
                                sourceSupport == null ? null : sourceSupport.IsAssessmentFamilyAssessmentPeriodIncluded);

            if (sourceSupport == null || sourceSupport.IsAssessmentFamilyIdentificationCodesSupported)
                isModified |= source.AssessmentFamilyIdentificationCodes.SynchronizeListTo(target.AssessmentFamilyIdentificationCodes, child => child.AssessmentFamily = target,
                                sourceSupport == null ? null : sourceSupport.IsAssessmentFamilyIdentificationCodeIncluded);

            if (sourceSupport == null || sourceSupport.IsAssessmentFamilyLanguagesSupported)
                isModified |= source.AssessmentFamilyLanguages.SynchronizeListTo(target.AssessmentFamilyLanguages, child => child.AssessmentFamily = target,
                                sourceSupport == null ? null : sourceSupport.IsAssessmentFamilyLanguageIncluded);


            return isModified;
        }



        public static void MapTo(this IAssessmentFamily source, IAssessmentFamily target, Action<IAssessmentFamily, IAssessmentFamily> onMapped)
        {
            var sourceSynchSupport = source as IAssessmentFamilySynchronizationSourceSupport;
            var targetSynchSupport = target as IAssessmentFamilySynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.AssessmentFamilyTitle = source.AssessmentFamilyTitle;

            // Copy non-PK properties

            if (sourceSynchSupport.IsAcademicSubjectDescriptorSupported)
                target.AcademicSubjectDescriptor = source.AcademicSubjectDescriptor;
            else
                targetSynchSupport.IsAcademicSubjectDescriptorSupported = false;

            if (sourceSynchSupport.IsAssessedGradeLevelDescriptorSupported)
                target.AssessedGradeLevelDescriptor = source.AssessedGradeLevelDescriptor;
            else
                targetSynchSupport.IsAssessedGradeLevelDescriptorSupported = false;

            if (sourceSynchSupport.IsAssessmentCategoryDescriptorSupported)
                target.AssessmentCategoryDescriptor = source.AssessmentCategoryDescriptor;
            else
                targetSynchSupport.IsAssessmentCategoryDescriptorSupported = false;

            if (sourceSynchSupport.IsLowestAssessedGradeLevelDescriptorSupported)
                target.LowestAssessedGradeLevelDescriptor = source.LowestAssessedGradeLevelDescriptor;
            else
                targetSynchSupport.IsLowestAssessedGradeLevelDescriptorSupported = false;

            if (sourceSynchSupport.IsNamespaceSupported)
                target.Namespace = source.Namespace;
            else
                targetSynchSupport.IsNamespaceSupported = false;

            if (sourceSynchSupport.IsNomenclatureSupported)
                target.Nomenclature = source.Nomenclature;
            else
                targetSynchSupport.IsNomenclatureSupported = false;

            if (sourceSynchSupport.IsParentAssessmentFamilyTitleSupported)
                target.ParentAssessmentFamilyTitle = source.ParentAssessmentFamilyTitle;
            else
                targetSynchSupport.IsParentAssessmentFamilyTitleSupported = false;

            if (sourceSynchSupport.IsRevisionDateSupported)
                target.RevisionDate = source.RevisionDate;
            else
                targetSynchSupport.IsRevisionDateSupported = false;

            if (sourceSynchSupport.IsVersionSupported)
                target.Version = source.Version;
            else
                targetSynchSupport.IsVersionSupported = false;

            // ----------------------------------
            //   Map One-to-one relationships
            // ----------------------------------
            // AssessmentFamilyContentStandard (Source)
            if (sourceSynchSupport.IsAssessmentFamilyContentStandardSupported)
            {
                var itemProperty = target.GetType().GetProperty("AssessmentFamilyContentStandard");
                
                if (itemProperty != null)
                {                    
                    if (source.AssessmentFamilyContentStandard == null)
                    {
                        target.AssessmentFamilyContentStandard = null;
                    }
                    else
                    {
                        var itemType = itemProperty.PropertyType;
                        object targetAssessmentFamilyContentStandard = Activator.CreateInstance(itemType);

                        source.AssessmentFamilyContentStandard.Map(targetAssessmentFamilyContentStandard);
                        
                        // Update the target reference appropriately
                        target.AssessmentFamilyContentStandard = (IAssessmentFamilyContentStandard) targetAssessmentFamilyContentStandard;
                    }
                }
            }
            else
            {
                targetSynchSupport.IsAssessmentFamilyContentStandardSupported = false; 
            }
            // -------------------------------------------------------------

            // Map lists

            if (sourceSynchSupport.IsAssessmentFamilyAssessmentPeriodsSupported)
            {    
                targetSynchSupport.IsAssessmentFamilyAssessmentPeriodIncluded = sourceSynchSupport.IsAssessmentFamilyAssessmentPeriodIncluded;
                source.AssessmentFamilyAssessmentPeriods.MapListTo(target.AssessmentFamilyAssessmentPeriods);
            }
            else
            {
                targetSynchSupport.IsAssessmentFamilyAssessmentPeriodsSupported = false;
            }

            if (sourceSynchSupport.IsAssessmentFamilyIdentificationCodesSupported)
            {    
                targetSynchSupport.IsAssessmentFamilyIdentificationCodeIncluded = sourceSynchSupport.IsAssessmentFamilyIdentificationCodeIncluded;
                source.AssessmentFamilyIdentificationCodes.MapListTo(target.AssessmentFamilyIdentificationCodes);
            }
            else
            {
                targetSynchSupport.IsAssessmentFamilyIdentificationCodesSupported = false;
            }

            if (sourceSynchSupport.IsAssessmentFamilyLanguagesSupported)
            {    
                targetSynchSupport.IsAssessmentFamilyLanguageIncluded = sourceSynchSupport.IsAssessmentFamilyLanguageIncluded;
                source.AssessmentFamilyLanguages.MapListTo(target.AssessmentFamilyLanguages);
            }
            else
            {
                targetSynchSupport.IsAssessmentFamilyLanguagesSupported = false;
            }

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IAssessmentFamilySynchronizationSourceSupport
    {
        bool IsAcademicSubjectDescriptorSupported { get; set; }
        bool IsAssessedGradeLevelDescriptorSupported { get; set; }
        bool IsAssessmentCategoryDescriptorSupported { get; set; }
        bool IsAssessmentFamilyAssessmentPeriodsSupported { get; set; }
        bool IsAssessmentFamilyContentStandardSupported { get; set; }
        bool IsAssessmentFamilyIdentificationCodesSupported { get; set; }
        bool IsAssessmentFamilyLanguagesSupported { get; set; }
        bool IsLowestAssessedGradeLevelDescriptorSupported { get; set; }
        bool IsNamespaceSupported { get; set; }
        bool IsNomenclatureSupported { get; set; }
        bool IsParentAssessmentFamilyTitleSupported { get; set; }
        bool IsRevisionDateSupported { get; set; }
        bool IsVersionSupported { get; set; }
        Func<IAssessmentFamilyAssessmentPeriod, bool> IsAssessmentFamilyAssessmentPeriodIncluded { get; set; }
        Func<IAssessmentFamilyIdentificationCode, bool> IsAssessmentFamilyIdentificationCodeIncluded { get; set; }
        Func<IAssessmentFamilyLanguage, bool> IsAssessmentFamilyLanguageIncluded { get; set; }
    }
 
    public static class AssessmentFamilyAssessmentPeriodMapper 
    {
        public static bool SynchronizeTo(this IAssessmentFamilyAssessmentPeriod source, IAssessmentFamilyAssessmentPeriod target)
        {
            bool isModified = false;

            var sourceSupport = source as IAssessmentFamilyAssessmentPeriodSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AssessmentPeriodDescriptor != target.AssessmentPeriodDescriptor)
            {
                source.AssessmentPeriodDescriptor = target.AssessmentPeriodDescriptor;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IAssessmentFamilyAssessmentPeriod source, IAssessmentFamilyAssessmentPeriod target, Action<IAssessmentFamilyAssessmentPeriod, IAssessmentFamilyAssessmentPeriod> onMapped)
        {
            var sourceSynchSupport = source as IAssessmentFamilyAssessmentPeriodSynchronizationSourceSupport;
            var targetSynchSupport = target as IAssessmentFamilyAssessmentPeriodSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.AssessmentPeriodDescriptor = source.AssessmentPeriodDescriptor;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IAssessmentFamilyAssessmentPeriodSynchronizationSourceSupport
    {
    }
 
    public static class AssessmentFamilyContentStandardMapper 
    {
        public static bool SynchronizeTo(this IAssessmentFamilyContentStandard source, IAssessmentFamilyContentStandard target)
        {
            bool isModified = false;

            var sourceSupport = source as IAssessmentFamilyContentStandardSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsBeginDateSupported)
                && target.BeginDate != source.BeginDate)
            {
                target.BeginDate = source.BeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEndDateSupported)
                && target.EndDate != source.EndDate)
            {
                target.EndDate = source.EndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsMandatingEducationOrganizationIdSupported)
                && target.MandatingEducationOrganizationId != source.MandatingEducationOrganizationId)
            {
                target.MandatingEducationOrganizationId = source.MandatingEducationOrganizationId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPublicationDateSupported)
                && target.PublicationDate != source.PublicationDate)
            {
                target.PublicationDate = source.PublicationDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPublicationStatusTypeSupported)
                && target.PublicationStatusType != source.PublicationStatusType)
            {
                target.PublicationStatusType = source.PublicationStatusType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPublicationYearSupported)
                && target.PublicationYear != source.PublicationYear)
            {
                target.PublicationYear = source.PublicationYear;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsTitleSupported)
                && target.Title != source.Title)
            {
                target.Title = source.Title;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsURISupported)
                && target.URI != source.URI)
            {
                target.URI = source.URI;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsVersionSupported)
                && target.Version != source.Version)
            {
                target.Version = source.Version;
                isModified = true;
            }



            // Sync lists
            if (sourceSupport == null || sourceSupport.IsAssessmentFamilyContentStandardAuthorsSupported)
                isModified |= source.AssessmentFamilyContentStandardAuthors.SynchronizeListTo(target.AssessmentFamilyContentStandardAuthors, child => child.AssessmentFamilyContentStandard = target,
                                sourceSupport == null ? null : sourceSupport.IsAssessmentFamilyContentStandardAuthorIncluded);


            return isModified;
        }



        public static void MapTo(this IAssessmentFamilyContentStandard source, IAssessmentFamilyContentStandard target, Action<IAssessmentFamilyContentStandard, IAssessmentFamilyContentStandard> onMapped)
        {
            var sourceSynchSupport = source as IAssessmentFamilyContentStandardSynchronizationSourceSupport;
            var targetSynchSupport = target as IAssessmentFamilyContentStandardSynchronizationSourceSupport;

            // Copy contextual primary key values

            // Copy non-PK properties

            if (sourceSynchSupport.IsBeginDateSupported)
                target.BeginDate = source.BeginDate;
            else
                targetSynchSupport.IsBeginDateSupported = false;

            if (sourceSynchSupport.IsEndDateSupported)
                target.EndDate = source.EndDate;
            else
                targetSynchSupport.IsEndDateSupported = false;

            if (sourceSynchSupport.IsMandatingEducationOrganizationIdSupported)
                target.MandatingEducationOrganizationId = source.MandatingEducationOrganizationId;
            else
                targetSynchSupport.IsMandatingEducationOrganizationIdSupported = false;

            if (sourceSynchSupport.IsPublicationDateSupported)
                target.PublicationDate = source.PublicationDate;
            else
                targetSynchSupport.IsPublicationDateSupported = false;

            if (sourceSynchSupport.IsPublicationStatusTypeSupported)
                target.PublicationStatusType = source.PublicationStatusType;
            else
                targetSynchSupport.IsPublicationStatusTypeSupported = false;

            if (sourceSynchSupport.IsPublicationYearSupported)
                target.PublicationYear = source.PublicationYear;
            else
                targetSynchSupport.IsPublicationYearSupported = false;

            if (sourceSynchSupport.IsTitleSupported)
                target.Title = source.Title;
            else
                targetSynchSupport.IsTitleSupported = false;

            if (sourceSynchSupport.IsURISupported)
                target.URI = source.URI;
            else
                targetSynchSupport.IsURISupported = false;

            if (sourceSynchSupport.IsVersionSupported)
                target.Version = source.Version;
            else
                targetSynchSupport.IsVersionSupported = false;

            // Map lists

            if (sourceSynchSupport.IsAssessmentFamilyContentStandardAuthorsSupported)
            {    
                targetSynchSupport.IsAssessmentFamilyContentStandardAuthorIncluded = sourceSynchSupport.IsAssessmentFamilyContentStandardAuthorIncluded;
                source.AssessmentFamilyContentStandardAuthors.MapListTo(target.AssessmentFamilyContentStandardAuthors);
            }
            else
            {
                targetSynchSupport.IsAssessmentFamilyContentStandardAuthorsSupported = false;
            }

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IAssessmentFamilyContentStandardSynchronizationSourceSupport
    {
        bool IsAssessmentFamilyContentStandardAuthorsSupported { get; set; }
        bool IsBeginDateSupported { get; set; }
        bool IsEndDateSupported { get; set; }
        bool IsMandatingEducationOrganizationIdSupported { get; set; }
        bool IsPublicationDateSupported { get; set; }
        bool IsPublicationStatusTypeSupported { get; set; }
        bool IsPublicationYearSupported { get; set; }
        bool IsTitleSupported { get; set; }
        bool IsURISupported { get; set; }
        bool IsVersionSupported { get; set; }
        Func<IAssessmentFamilyContentStandardAuthor, bool> IsAssessmentFamilyContentStandardAuthorIncluded { get; set; }
    }
 
    public static class AssessmentFamilyContentStandardAuthorMapper 
    {
        public static bool SynchronizeTo(this IAssessmentFamilyContentStandardAuthor source, IAssessmentFamilyContentStandardAuthor target)
        {
            bool isModified = false;

            var sourceSupport = source as IAssessmentFamilyContentStandardAuthorSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.Author != target.Author)
            {
                source.Author = target.Author;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IAssessmentFamilyContentStandardAuthor source, IAssessmentFamilyContentStandardAuthor target, Action<IAssessmentFamilyContentStandardAuthor, IAssessmentFamilyContentStandardAuthor> onMapped)
        {
            var sourceSynchSupport = source as IAssessmentFamilyContentStandardAuthorSynchronizationSourceSupport;
            var targetSynchSupport = target as IAssessmentFamilyContentStandardAuthorSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.Author = source.Author;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IAssessmentFamilyContentStandardAuthorSynchronizationSourceSupport
    {
    }
 
    public static class AssessmentFamilyIdentificationCodeMapper 
    {
        public static bool SynchronizeTo(this IAssessmentFamilyIdentificationCode source, IAssessmentFamilyIdentificationCode target)
        {
            bool isModified = false;

            var sourceSupport = source as IAssessmentFamilyIdentificationCodeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AssessmentIdentificationSystemDescriptor != target.AssessmentIdentificationSystemDescriptor)
            {
                source.AssessmentIdentificationSystemDescriptor = target.AssessmentIdentificationSystemDescriptor;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsAssigningOrganizationIdentificationCodeSupported)
                && target.AssigningOrganizationIdentificationCode != source.AssigningOrganizationIdentificationCode)
            {
                target.AssigningOrganizationIdentificationCode = source.AssigningOrganizationIdentificationCode;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsIdentificationCodeSupported)
                && target.IdentificationCode != source.IdentificationCode)
            {
                target.IdentificationCode = source.IdentificationCode;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IAssessmentFamilyIdentificationCode source, IAssessmentFamilyIdentificationCode target, Action<IAssessmentFamilyIdentificationCode, IAssessmentFamilyIdentificationCode> onMapped)
        {
            var sourceSynchSupport = source as IAssessmentFamilyIdentificationCodeSynchronizationSourceSupport;
            var targetSynchSupport = target as IAssessmentFamilyIdentificationCodeSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.AssessmentIdentificationSystemDescriptor = source.AssessmentIdentificationSystemDescriptor;

            // Copy non-PK properties

            if (sourceSynchSupport.IsAssigningOrganizationIdentificationCodeSupported)
                target.AssigningOrganizationIdentificationCode = source.AssigningOrganizationIdentificationCode;
            else
                targetSynchSupport.IsAssigningOrganizationIdentificationCodeSupported = false;

            if (sourceSynchSupport.IsIdentificationCodeSupported)
                target.IdentificationCode = source.IdentificationCode;
            else
                targetSynchSupport.IsIdentificationCodeSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IAssessmentFamilyIdentificationCodeSynchronizationSourceSupport
    {
        bool IsAssigningOrganizationIdentificationCodeSupported { get; set; }
        bool IsIdentificationCodeSupported { get; set; }
    }
 
    public static class AssessmentFamilyLanguageMapper 
    {
        public static bool SynchronizeTo(this IAssessmentFamilyLanguage source, IAssessmentFamilyLanguage target)
        {
            bool isModified = false;

            var sourceSupport = source as IAssessmentFamilyLanguageSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.LanguageDescriptor != target.LanguageDescriptor)
            {
                source.LanguageDescriptor = target.LanguageDescriptor;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IAssessmentFamilyLanguage source, IAssessmentFamilyLanguage target, Action<IAssessmentFamilyLanguage, IAssessmentFamilyLanguage> onMapped)
        {
            var sourceSynchSupport = source as IAssessmentFamilyLanguageSynchronizationSourceSupport;
            var targetSynchSupport = target as IAssessmentFamilyLanguageSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.LanguageDescriptor = source.LanguageDescriptor;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IAssessmentFamilyLanguageSynchronizationSourceSupport
    {
    }
 
}
// Aggregate: AssessmentIdentificationSystemDescriptor

namespace EdFi.Ods.Entities.Common //.AssessmentIdentificationSystemDescriptorAggregate
{ 
    public static class AssessmentIdentificationSystemDescriptorMapper 
    {
        public static bool SynchronizeTo(this IAssessmentIdentificationSystemDescriptor source, IAssessmentIdentificationSystemDescriptor target)
        {
            bool isModified = false;

            var sourceSupport = source as IAssessmentIdentificationSystemDescriptorSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AssessmentIdentificationSystemDescriptorId != target.AssessmentIdentificationSystemDescriptorId)
            {
                source.AssessmentIdentificationSystemDescriptorId = target.AssessmentIdentificationSystemDescriptorId;
            }

            // Copy inherited non-PK properties


            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveBeginDateSupported)
                && target.EffectiveBeginDate != source.EffectiveBeginDate)
            {
                target.EffectiveBeginDate = source.EffectiveBeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveEndDateSupported)
                && target.EffectiveEndDate != source.EffectiveEndDate)
            {
                target.EffectiveEndDate = source.EffectiveEndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNamespaceSupported)
                && target.Namespace != source.Namespace)
            {
                target.Namespace = source.Namespace;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPriorDescriptorIdSupported)
                && target.PriorDescriptorId != source.PriorDescriptorId)
            {
                target.PriorDescriptorId = source.PriorDescriptorId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsAssessmentIdentificationSystemTypeSupported)
                && target.AssessmentIdentificationSystemType != source.AssessmentIdentificationSystemType)
            {
                target.AssessmentIdentificationSystemType = source.AssessmentIdentificationSystemType;
                isModified = true;
            }

            // Synch inherited lists


            // Sync lists

            return isModified;
        }



        public static void MapTo(this IAssessmentIdentificationSystemDescriptor source, IAssessmentIdentificationSystemDescriptor target, Action<IAssessmentIdentificationSystemDescriptor, IAssessmentIdentificationSystemDescriptor> onMapped)
        {
            var sourceSynchSupport = source as IAssessmentIdentificationSystemDescriptorSynchronizationSourceSupport;
            var targetSynchSupport = target as IAssessmentIdentificationSystemDescriptorSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.AssessmentIdentificationSystemDescriptorId = source.AssessmentIdentificationSystemDescriptorId;

            // Copy inherited non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsEffectiveBeginDateSupported)
                target.EffectiveBeginDate = source.EffectiveBeginDate;
            else
                targetSynchSupport.IsEffectiveBeginDateSupported = false;

            if (sourceSynchSupport.IsEffectiveEndDateSupported)
                target.EffectiveEndDate = source.EffectiveEndDate;
            else
                targetSynchSupport.IsEffectiveEndDateSupported = false;

            if (sourceSynchSupport.IsNamespaceSupported)
                target.Namespace = source.Namespace;
            else
                targetSynchSupport.IsNamespaceSupported = false;

            if (sourceSynchSupport.IsPriorDescriptorIdSupported)
                target.PriorDescriptorId = source.PriorDescriptorId;
            else
                targetSynchSupport.IsPriorDescriptorIdSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Copy non-PK properties

            if (sourceSynchSupport.IsAssessmentIdentificationSystemTypeSupported)
                target.AssessmentIdentificationSystemType = source.AssessmentIdentificationSystemType;
            else
                targetSynchSupport.IsAssessmentIdentificationSystemTypeSupported = false;

            // Map inherited lists

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IAssessmentIdentificationSystemDescriptorSynchronizationSourceSupport
    {
        bool IsAssessmentIdentificationSystemTypeSupported { get; set; }
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsEffectiveBeginDateSupported { get; set; }
        bool IsEffectiveEndDateSupported { get; set; }
        bool IsNamespaceSupported { get; set; }
        bool IsPriorDescriptorIdSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: AssessmentIdentificationSystemType

namespace EdFi.Ods.Entities.Common //.AssessmentIdentificationSystemTypeAggregate
{ 
    public static class AssessmentIdentificationSystemTypeMapper 
    {
        public static bool SynchronizeTo(this IAssessmentIdentificationSystemType source, IAssessmentIdentificationSystemType target)
        {
            bool isModified = false;

            var sourceSupport = source as IAssessmentIdentificationSystemTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AssessmentIdentificationSystemTypeId != target.AssessmentIdentificationSystemTypeId)
            {
                source.AssessmentIdentificationSystemTypeId = target.AssessmentIdentificationSystemTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IAssessmentIdentificationSystemType source, IAssessmentIdentificationSystemType target, Action<IAssessmentIdentificationSystemType, IAssessmentIdentificationSystemType> onMapped)
        {
            var sourceSynchSupport = source as IAssessmentIdentificationSystemTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IAssessmentIdentificationSystemTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.AssessmentIdentificationSystemTypeId = source.AssessmentIdentificationSystemTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IAssessmentIdentificationSystemTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: AssessmentItem

namespace EdFi.Ods.Entities.Common //.AssessmentItemAggregate
{ 
    public static class AssessmentItemMapper 
    {
        public static bool SynchronizeTo(this IAssessmentItem source, IAssessmentItem target)
        {
            bool isModified = false;

            var sourceSupport = source as IAssessmentItemSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AssessmentIdentifier != target.AssessmentIdentifier)
            {
                source.AssessmentIdentifier = target.AssessmentIdentifier;
            }
            if (source.IdentificationCode != target.IdentificationCode)
            {
                source.IdentificationCode = target.IdentificationCode;
            }
            if (source.Namespace != target.Namespace)
            {
                source.Namespace = target.Namespace;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsAssessmentItemCategoryTypeSupported)
                && target.AssessmentItemCategoryType != source.AssessmentItemCategoryType)
            {
                target.AssessmentItemCategoryType = source.AssessmentItemCategoryType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsCorrectResponseSupported)
                && target.CorrectResponse != source.CorrectResponse)
            {
                target.CorrectResponse = source.CorrectResponse;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsExpectedTimeAssessedSupported)
                && target.ExpectedTimeAssessed != source.ExpectedTimeAssessed)
            {
                target.ExpectedTimeAssessed = source.ExpectedTimeAssessed;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsMaxRawScoreSupported)
                && target.MaxRawScore != source.MaxRawScore)
            {
                target.MaxRawScore = source.MaxRawScore;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNomenclatureSupported)
                && target.Nomenclature != source.Nomenclature)
            {
                target.Nomenclature = source.Nomenclature;
                isModified = true;
            }



            // Sync lists
            if (sourceSupport == null || sourceSupport.IsAssessmentItemLearningStandardsSupported)
                isModified |= source.AssessmentItemLearningStandards.SynchronizeListTo(target.AssessmentItemLearningStandards, child => child.AssessmentItem = target,
                                sourceSupport == null ? null : sourceSupport.IsAssessmentItemLearningStandardIncluded);


            return isModified;
        }



        public static void MapTo(this IAssessmentItem source, IAssessmentItem target, Action<IAssessmentItem, IAssessmentItem> onMapped)
        {
            var sourceSynchSupport = source as IAssessmentItemSynchronizationSourceSupport;
            var targetSynchSupport = target as IAssessmentItemSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.AssessmentIdentifier = source.AssessmentIdentifier;
            target.IdentificationCode = source.IdentificationCode;
            target.Namespace = source.Namespace;

            // Copy non-PK properties

            if (sourceSynchSupport.IsAssessmentItemCategoryTypeSupported)
                target.AssessmentItemCategoryType = source.AssessmentItemCategoryType;
            else
                targetSynchSupport.IsAssessmentItemCategoryTypeSupported = false;

            if (sourceSynchSupport.IsCorrectResponseSupported)
                target.CorrectResponse = source.CorrectResponse;
            else
                targetSynchSupport.IsCorrectResponseSupported = false;

            if (sourceSynchSupport.IsExpectedTimeAssessedSupported)
                target.ExpectedTimeAssessed = source.ExpectedTimeAssessed;
            else
                targetSynchSupport.IsExpectedTimeAssessedSupported = false;

            if (sourceSynchSupport.IsMaxRawScoreSupported)
                target.MaxRawScore = source.MaxRawScore;
            else
                targetSynchSupport.IsMaxRawScoreSupported = false;

            if (sourceSynchSupport.IsNomenclatureSupported)
                target.Nomenclature = source.Nomenclature;
            else
                targetSynchSupport.IsNomenclatureSupported = false;

            // Map lists

            if (sourceSynchSupport.IsAssessmentItemLearningStandardsSupported)
            {    
                targetSynchSupport.IsAssessmentItemLearningStandardIncluded = sourceSynchSupport.IsAssessmentItemLearningStandardIncluded;
                source.AssessmentItemLearningStandards.MapListTo(target.AssessmentItemLearningStandards);
            }
            else
            {
                targetSynchSupport.IsAssessmentItemLearningStandardsSupported = false;
            }

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IAssessmentItemSynchronizationSourceSupport
    {
        bool IsAssessmentItemCategoryTypeSupported { get; set; }
        bool IsAssessmentItemLearningStandardsSupported { get; set; }
        bool IsCorrectResponseSupported { get; set; }
        bool IsExpectedTimeAssessedSupported { get; set; }
        bool IsMaxRawScoreSupported { get; set; }
        bool IsNomenclatureSupported { get; set; }
        Func<IAssessmentItemLearningStandard, bool> IsAssessmentItemLearningStandardIncluded { get; set; }
    }
 
    public static class AssessmentItemLearningStandardMapper 
    {
        public static bool SynchronizeTo(this IAssessmentItemLearningStandard source, IAssessmentItemLearningStandard target)
        {
            bool isModified = false;

            var sourceSupport = source as IAssessmentItemLearningStandardSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.LearningStandardId != target.LearningStandardId)
            {
                source.LearningStandardId = target.LearningStandardId;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IAssessmentItemLearningStandard source, IAssessmentItemLearningStandard target, Action<IAssessmentItemLearningStandard, IAssessmentItemLearningStandard> onMapped)
        {
            var sourceSynchSupport = source as IAssessmentItemLearningStandardSynchronizationSourceSupport;
            var targetSynchSupport = target as IAssessmentItemLearningStandardSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.LearningStandardId = source.LearningStandardId;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IAssessmentItemLearningStandardSynchronizationSourceSupport
    {
    }
 
}
// Aggregate: AssessmentItemCategoryType

namespace EdFi.Ods.Entities.Common //.AssessmentItemCategoryTypeAggregate
{ 
    public static class AssessmentItemCategoryTypeMapper 
    {
        public static bool SynchronizeTo(this IAssessmentItemCategoryType source, IAssessmentItemCategoryType target)
        {
            bool isModified = false;

            var sourceSupport = source as IAssessmentItemCategoryTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AssessmentItemCategoryTypeId != target.AssessmentItemCategoryTypeId)
            {
                source.AssessmentItemCategoryTypeId = target.AssessmentItemCategoryTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IAssessmentItemCategoryType source, IAssessmentItemCategoryType target, Action<IAssessmentItemCategoryType, IAssessmentItemCategoryType> onMapped)
        {
            var sourceSynchSupport = source as IAssessmentItemCategoryTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IAssessmentItemCategoryTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.AssessmentItemCategoryTypeId = source.AssessmentItemCategoryTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IAssessmentItemCategoryTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: AssessmentItemResultType

namespace EdFi.Ods.Entities.Common //.AssessmentItemResultTypeAggregate
{ 
    public static class AssessmentItemResultTypeMapper 
    {
        public static bool SynchronizeTo(this IAssessmentItemResultType source, IAssessmentItemResultType target)
        {
            bool isModified = false;

            var sourceSupport = source as IAssessmentItemResultTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AssessmentItemResultTypeId != target.AssessmentItemResultTypeId)
            {
                source.AssessmentItemResultTypeId = target.AssessmentItemResultTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IAssessmentItemResultType source, IAssessmentItemResultType target, Action<IAssessmentItemResultType, IAssessmentItemResultType> onMapped)
        {
            var sourceSynchSupport = source as IAssessmentItemResultTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IAssessmentItemResultTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.AssessmentItemResultTypeId = source.AssessmentItemResultTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IAssessmentItemResultTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: AssessmentPeriodDescriptor

namespace EdFi.Ods.Entities.Common //.AssessmentPeriodDescriptorAggregate
{ 
    public static class AssessmentPeriodDescriptorMapper 
    {
        public static bool SynchronizeTo(this IAssessmentPeriodDescriptor source, IAssessmentPeriodDescriptor target)
        {
            bool isModified = false;

            var sourceSupport = source as IAssessmentPeriodDescriptorSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AssessmentPeriodDescriptorId != target.AssessmentPeriodDescriptorId)
            {
                source.AssessmentPeriodDescriptorId = target.AssessmentPeriodDescriptorId;
            }

            // Copy inherited non-PK properties


            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveBeginDateSupported)
                && target.EffectiveBeginDate != source.EffectiveBeginDate)
            {
                target.EffectiveBeginDate = source.EffectiveBeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveEndDateSupported)
                && target.EffectiveEndDate != source.EffectiveEndDate)
            {
                target.EffectiveEndDate = source.EffectiveEndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNamespaceSupported)
                && target.Namespace != source.Namespace)
            {
                target.Namespace = source.Namespace;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPriorDescriptorIdSupported)
                && target.PriorDescriptorId != source.PriorDescriptorId)
            {
                target.PriorDescriptorId = source.PriorDescriptorId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsBeginDateSupported)
                && target.BeginDate != source.BeginDate)
            {
                target.BeginDate = source.BeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEndDateSupported)
                && target.EndDate != source.EndDate)
            {
                target.EndDate = source.EndDate;
                isModified = true;
            }

            // Synch inherited lists


            // Sync lists

            return isModified;
        }



        public static void MapTo(this IAssessmentPeriodDescriptor source, IAssessmentPeriodDescriptor target, Action<IAssessmentPeriodDescriptor, IAssessmentPeriodDescriptor> onMapped)
        {
            var sourceSynchSupport = source as IAssessmentPeriodDescriptorSynchronizationSourceSupport;
            var targetSynchSupport = target as IAssessmentPeriodDescriptorSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.AssessmentPeriodDescriptorId = source.AssessmentPeriodDescriptorId;

            // Copy inherited non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsEffectiveBeginDateSupported)
                target.EffectiveBeginDate = source.EffectiveBeginDate;
            else
                targetSynchSupport.IsEffectiveBeginDateSupported = false;

            if (sourceSynchSupport.IsEffectiveEndDateSupported)
                target.EffectiveEndDate = source.EffectiveEndDate;
            else
                targetSynchSupport.IsEffectiveEndDateSupported = false;

            if (sourceSynchSupport.IsNamespaceSupported)
                target.Namespace = source.Namespace;
            else
                targetSynchSupport.IsNamespaceSupported = false;

            if (sourceSynchSupport.IsPriorDescriptorIdSupported)
                target.PriorDescriptorId = source.PriorDescriptorId;
            else
                targetSynchSupport.IsPriorDescriptorIdSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Copy non-PK properties

            if (sourceSynchSupport.IsBeginDateSupported)
                target.BeginDate = source.BeginDate;
            else
                targetSynchSupport.IsBeginDateSupported = false;

            if (sourceSynchSupport.IsEndDateSupported)
                target.EndDate = source.EndDate;
            else
                targetSynchSupport.IsEndDateSupported = false;

            // Map inherited lists

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IAssessmentPeriodDescriptorSynchronizationSourceSupport
    {
        bool IsBeginDateSupported { get; set; }
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsEffectiveBeginDateSupported { get; set; }
        bool IsEffectiveEndDateSupported { get; set; }
        bool IsEndDateSupported { get; set; }
        bool IsNamespaceSupported { get; set; }
        bool IsPriorDescriptorIdSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: AssessmentReportingMethodType

namespace EdFi.Ods.Entities.Common //.AssessmentReportingMethodTypeAggregate
{ 
    public static class AssessmentReportingMethodTypeMapper 
    {
        public static bool SynchronizeTo(this IAssessmentReportingMethodType source, IAssessmentReportingMethodType target)
        {
            bool isModified = false;

            var sourceSupport = source as IAssessmentReportingMethodTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AssessmentReportingMethodTypeId != target.AssessmentReportingMethodTypeId)
            {
                source.AssessmentReportingMethodTypeId = target.AssessmentReportingMethodTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IAssessmentReportingMethodType source, IAssessmentReportingMethodType target, Action<IAssessmentReportingMethodType, IAssessmentReportingMethodType> onMapped)
        {
            var sourceSynchSupport = source as IAssessmentReportingMethodTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IAssessmentReportingMethodTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.AssessmentReportingMethodTypeId = source.AssessmentReportingMethodTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IAssessmentReportingMethodTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: AttendanceEventCategoryDescriptor

namespace EdFi.Ods.Entities.Common //.AttendanceEventCategoryDescriptorAggregate
{ 
    public static class AttendanceEventCategoryDescriptorMapper 
    {
        public static bool SynchronizeTo(this IAttendanceEventCategoryDescriptor source, IAttendanceEventCategoryDescriptor target)
        {
            bool isModified = false;

            var sourceSupport = source as IAttendanceEventCategoryDescriptorSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AttendanceEventCategoryDescriptorId != target.AttendanceEventCategoryDescriptorId)
            {
                source.AttendanceEventCategoryDescriptorId = target.AttendanceEventCategoryDescriptorId;
            }

            // Copy inherited non-PK properties


            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveBeginDateSupported)
                && target.EffectiveBeginDate != source.EffectiveBeginDate)
            {
                target.EffectiveBeginDate = source.EffectiveBeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveEndDateSupported)
                && target.EffectiveEndDate != source.EffectiveEndDate)
            {
                target.EffectiveEndDate = source.EffectiveEndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNamespaceSupported)
                && target.Namespace != source.Namespace)
            {
                target.Namespace = source.Namespace;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPriorDescriptorIdSupported)
                && target.PriorDescriptorId != source.PriorDescriptorId)
            {
                target.PriorDescriptorId = source.PriorDescriptorId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsAttendanceEventCategoryTypeSupported)
                && target.AttendanceEventCategoryType != source.AttendanceEventCategoryType)
            {
                target.AttendanceEventCategoryType = source.AttendanceEventCategoryType;
                isModified = true;
            }

            // Synch inherited lists


            // Sync lists

            return isModified;
        }



        public static void MapTo(this IAttendanceEventCategoryDescriptor source, IAttendanceEventCategoryDescriptor target, Action<IAttendanceEventCategoryDescriptor, IAttendanceEventCategoryDescriptor> onMapped)
        {
            var sourceSynchSupport = source as IAttendanceEventCategoryDescriptorSynchronizationSourceSupport;
            var targetSynchSupport = target as IAttendanceEventCategoryDescriptorSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.AttendanceEventCategoryDescriptorId = source.AttendanceEventCategoryDescriptorId;

            // Copy inherited non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsEffectiveBeginDateSupported)
                target.EffectiveBeginDate = source.EffectiveBeginDate;
            else
                targetSynchSupport.IsEffectiveBeginDateSupported = false;

            if (sourceSynchSupport.IsEffectiveEndDateSupported)
                target.EffectiveEndDate = source.EffectiveEndDate;
            else
                targetSynchSupport.IsEffectiveEndDateSupported = false;

            if (sourceSynchSupport.IsNamespaceSupported)
                target.Namespace = source.Namespace;
            else
                targetSynchSupport.IsNamespaceSupported = false;

            if (sourceSynchSupport.IsPriorDescriptorIdSupported)
                target.PriorDescriptorId = source.PriorDescriptorId;
            else
                targetSynchSupport.IsPriorDescriptorIdSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Copy non-PK properties

            if (sourceSynchSupport.IsAttendanceEventCategoryTypeSupported)
                target.AttendanceEventCategoryType = source.AttendanceEventCategoryType;
            else
                targetSynchSupport.IsAttendanceEventCategoryTypeSupported = false;

            // Map inherited lists

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IAttendanceEventCategoryDescriptorSynchronizationSourceSupport
    {
        bool IsAttendanceEventCategoryTypeSupported { get; set; }
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsEffectiveBeginDateSupported { get; set; }
        bool IsEffectiveEndDateSupported { get; set; }
        bool IsNamespaceSupported { get; set; }
        bool IsPriorDescriptorIdSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: AttendanceEventCategoryType

namespace EdFi.Ods.Entities.Common //.AttendanceEventCategoryTypeAggregate
{ 
    public static class AttendanceEventCategoryTypeMapper 
    {
        public static bool SynchronizeTo(this IAttendanceEventCategoryType source, IAttendanceEventCategoryType target)
        {
            bool isModified = false;

            var sourceSupport = source as IAttendanceEventCategoryTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AttendanceEventCategoryTypeId != target.AttendanceEventCategoryTypeId)
            {
                source.AttendanceEventCategoryTypeId = target.AttendanceEventCategoryTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IAttendanceEventCategoryType source, IAttendanceEventCategoryType target, Action<IAttendanceEventCategoryType, IAttendanceEventCategoryType> onMapped)
        {
            var sourceSynchSupport = source as IAttendanceEventCategoryTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IAttendanceEventCategoryTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.AttendanceEventCategoryTypeId = source.AttendanceEventCategoryTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IAttendanceEventCategoryTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: BehaviorDescriptor

namespace EdFi.Ods.Entities.Common //.BehaviorDescriptorAggregate
{ 
    public static class BehaviorDescriptorMapper 
    {
        public static bool SynchronizeTo(this IBehaviorDescriptor source, IBehaviorDescriptor target)
        {
            bool isModified = false;

            var sourceSupport = source as IBehaviorDescriptorSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.BehaviorDescriptorId != target.BehaviorDescriptorId)
            {
                source.BehaviorDescriptorId = target.BehaviorDescriptorId;
            }

            // Copy inherited non-PK properties


            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveBeginDateSupported)
                && target.EffectiveBeginDate != source.EffectiveBeginDate)
            {
                target.EffectiveBeginDate = source.EffectiveBeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveEndDateSupported)
                && target.EffectiveEndDate != source.EffectiveEndDate)
            {
                target.EffectiveEndDate = source.EffectiveEndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNamespaceSupported)
                && target.Namespace != source.Namespace)
            {
                target.Namespace = source.Namespace;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPriorDescriptorIdSupported)
                && target.PriorDescriptorId != source.PriorDescriptorId)
            {
                target.PriorDescriptorId = source.PriorDescriptorId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsBehaviorTypeSupported)
                && target.BehaviorType != source.BehaviorType)
            {
                target.BehaviorType = source.BehaviorType;
                isModified = true;
            }

            // Synch inherited lists


            // Sync lists

            return isModified;
        }



        public static void MapTo(this IBehaviorDescriptor source, IBehaviorDescriptor target, Action<IBehaviorDescriptor, IBehaviorDescriptor> onMapped)
        {
            var sourceSynchSupport = source as IBehaviorDescriptorSynchronizationSourceSupport;
            var targetSynchSupport = target as IBehaviorDescriptorSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.BehaviorDescriptorId = source.BehaviorDescriptorId;

            // Copy inherited non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsEffectiveBeginDateSupported)
                target.EffectiveBeginDate = source.EffectiveBeginDate;
            else
                targetSynchSupport.IsEffectiveBeginDateSupported = false;

            if (sourceSynchSupport.IsEffectiveEndDateSupported)
                target.EffectiveEndDate = source.EffectiveEndDate;
            else
                targetSynchSupport.IsEffectiveEndDateSupported = false;

            if (sourceSynchSupport.IsNamespaceSupported)
                target.Namespace = source.Namespace;
            else
                targetSynchSupport.IsNamespaceSupported = false;

            if (sourceSynchSupport.IsPriorDescriptorIdSupported)
                target.PriorDescriptorId = source.PriorDescriptorId;
            else
                targetSynchSupport.IsPriorDescriptorIdSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Copy non-PK properties

            if (sourceSynchSupport.IsBehaviorTypeSupported)
                target.BehaviorType = source.BehaviorType;
            else
                targetSynchSupport.IsBehaviorTypeSupported = false;

            // Map inherited lists

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IBehaviorDescriptorSynchronizationSourceSupport
    {
        bool IsBehaviorTypeSupported { get; set; }
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsEffectiveBeginDateSupported { get; set; }
        bool IsEffectiveEndDateSupported { get; set; }
        bool IsNamespaceSupported { get; set; }
        bool IsPriorDescriptorIdSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: BehaviorType

namespace EdFi.Ods.Entities.Common //.BehaviorTypeAggregate
{ 
    public static class BehaviorTypeMapper 
    {
        public static bool SynchronizeTo(this IBehaviorType source, IBehaviorType target)
        {
            bool isModified = false;

            var sourceSupport = source as IBehaviorTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.BehaviorTypeId != target.BehaviorTypeId)
            {
                source.BehaviorTypeId = target.BehaviorTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IBehaviorType source, IBehaviorType target, Action<IBehaviorType, IBehaviorType> onMapped)
        {
            var sourceSynchSupport = source as IBehaviorTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IBehaviorTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.BehaviorTypeId = source.BehaviorTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IBehaviorTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: BellSchedule

namespace EdFi.Ods.Entities.Common //.BellScheduleAggregate
{ 
    public static class BellScheduleMapper 
    {
        public static bool SynchronizeTo(this IBellSchedule source, IBellSchedule target)
        {
            bool isModified = false;

            var sourceSupport = source as IBellScheduleSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.BellScheduleName != target.BellScheduleName)
            {
                source.BellScheduleName = target.BellScheduleName;
            }
            if (source.Date != target.Date)
            {
                source.Date = target.Date;
            }
            if (source.GradeLevelDescriptor != target.GradeLevelDescriptor)
            {
                source.GradeLevelDescriptor = target.GradeLevelDescriptor;
            }
            if (source.SchoolId != target.SchoolId)
            {
                source.SchoolId = target.SchoolId;
            }

            // Copy non-PK properties



            // Sync lists
            if (sourceSupport == null || sourceSupport.IsBellScheduleMeetingTimesSupported)
                isModified |= source.BellScheduleMeetingTimes.SynchronizeListTo(target.BellScheduleMeetingTimes, child => child.BellSchedule = target,
                                sourceSupport == null ? null : sourceSupport.IsBellScheduleMeetingTimeIncluded);


            return isModified;
        }



        public static void MapTo(this IBellSchedule source, IBellSchedule target, Action<IBellSchedule, IBellSchedule> onMapped)
        {
            var sourceSynchSupport = source as IBellScheduleSynchronizationSourceSupport;
            var targetSynchSupport = target as IBellScheduleSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.BellScheduleName = source.BellScheduleName;
            target.Date = source.Date;
            target.GradeLevelDescriptor = source.GradeLevelDescriptor;
            target.SchoolId = source.SchoolId;

            // Copy non-PK properties

            // Map lists

            if (sourceSynchSupport.IsBellScheduleMeetingTimesSupported)
            {    
                targetSynchSupport.IsBellScheduleMeetingTimeIncluded = sourceSynchSupport.IsBellScheduleMeetingTimeIncluded;
                source.BellScheduleMeetingTimes.MapListTo(target.BellScheduleMeetingTimes);
            }
            else
            {
                targetSynchSupport.IsBellScheduleMeetingTimesSupported = false;
            }

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IBellScheduleSynchronizationSourceSupport
    {
        bool IsBellScheduleMeetingTimesSupported { get; set; }
        Func<IBellScheduleMeetingTime, bool> IsBellScheduleMeetingTimeIncluded { get; set; }
    }
 
    public static class BellScheduleMeetingTimeMapper 
    {
        public static bool SynchronizeTo(this IBellScheduleMeetingTime source, IBellScheduleMeetingTime target)
        {
            bool isModified = false;

            var sourceSupport = source as IBellScheduleMeetingTimeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.ClassPeriodName != target.ClassPeriodName)
            {
                source.ClassPeriodName = target.ClassPeriodName;
            }
            if (source.StartTime != target.StartTime)
            {
                source.StartTime = target.StartTime;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsAlternateDayNameSupported)
                && target.AlternateDayName != source.AlternateDayName)
            {
                target.AlternateDayName = source.AlternateDayName;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEndTimeSupported)
                && target.EndTime != source.EndTime)
            {
                target.EndTime = source.EndTime;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsOfficialAttendancePeriodSupported)
                && target.OfficialAttendancePeriod != source.OfficialAttendancePeriod)
            {
                target.OfficialAttendancePeriod = source.OfficialAttendancePeriod;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IBellScheduleMeetingTime source, IBellScheduleMeetingTime target, Action<IBellScheduleMeetingTime, IBellScheduleMeetingTime> onMapped)
        {
            var sourceSynchSupport = source as IBellScheduleMeetingTimeSynchronizationSourceSupport;
            var targetSynchSupport = target as IBellScheduleMeetingTimeSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.ClassPeriodName = source.ClassPeriodName;
            target.StartTime = source.StartTime;

            // Copy non-PK properties

            if (sourceSynchSupport.IsAlternateDayNameSupported)
                target.AlternateDayName = source.AlternateDayName;
            else
                targetSynchSupport.IsAlternateDayNameSupported = false;

            if (sourceSynchSupport.IsEndTimeSupported)
                target.EndTime = source.EndTime;
            else
                targetSynchSupport.IsEndTimeSupported = false;

            if (sourceSynchSupport.IsOfficialAttendancePeriodSupported)
                target.OfficialAttendancePeriod = source.OfficialAttendancePeriod;
            else
                targetSynchSupport.IsOfficialAttendancePeriodSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IBellScheduleMeetingTimeSynchronizationSourceSupport
    {
        bool IsAlternateDayNameSupported { get; set; }
        bool IsEndTimeSupported { get; set; }
        bool IsOfficialAttendancePeriodSupported { get; set; }
    }
 
}
// Aggregate: Budget

namespace EdFi.Ods.Entities.Common //.BudgetAggregate
{ 
    public static class BudgetMapper 
    {
        public static bool SynchronizeTo(this IBudget source, IBudget target)
        {
            bool isModified = false;

            var sourceSupport = source as IBudgetSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AccountNumber != target.AccountNumber)
            {
                source.AccountNumber = target.AccountNumber;
            }
            if (source.AsOfDate != target.AsOfDate)
            {
                source.AsOfDate = target.AsOfDate;
            }
            if (source.EducationOrganizationId != target.EducationOrganizationId)
            {
                source.EducationOrganizationId = target.EducationOrganizationId;
            }
            if (source.FiscalYear != target.FiscalYear)
            {
                source.FiscalYear = target.FiscalYear;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsAmountSupported)
                && target.Amount != source.Amount)
            {
                target.Amount = source.Amount;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IBudget source, IBudget target, Action<IBudget, IBudget> onMapped)
        {
            var sourceSynchSupport = source as IBudgetSynchronizationSourceSupport;
            var targetSynchSupport = target as IBudgetSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.AccountNumber = source.AccountNumber;
            target.AsOfDate = source.AsOfDate;
            target.EducationOrganizationId = source.EducationOrganizationId;
            target.FiscalYear = source.FiscalYear;

            // Copy non-PK properties

            if (sourceSynchSupport.IsAmountSupported)
                target.Amount = source.Amount;
            else
                targetSynchSupport.IsAmountSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IBudgetSynchronizationSourceSupport
    {
        bool IsAmountSupported { get; set; }
    }
 
}
// Aggregate: CalendarDate

namespace EdFi.Ods.Entities.Common //.CalendarDateAggregate
{ 
    public static class CalendarDateMapper 
    {
        public static bool SynchronizeTo(this ICalendarDate source, ICalendarDate target)
        {
            bool isModified = false;

            var sourceSupport = source as ICalendarDateSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.Date != target.Date)
            {
                source.Date = target.Date;
            }
            if (source.SchoolId != target.SchoolId)
            {
                source.SchoolId = target.SchoolId;
            }

            // Copy non-PK properties



            // Sync lists
            if (sourceSupport == null || sourceSupport.IsCalendarDateCalendarEventsSupported)
                isModified |= source.CalendarDateCalendarEvents.SynchronizeListTo(target.CalendarDateCalendarEvents, child => child.CalendarDate = target,
                                sourceSupport == null ? null : sourceSupport.IsCalendarDateCalendarEventIncluded);


            return isModified;
        }



        public static void MapTo(this ICalendarDate source, ICalendarDate target, Action<ICalendarDate, ICalendarDate> onMapped)
        {
            var sourceSynchSupport = source as ICalendarDateSynchronizationSourceSupport;
            var targetSynchSupport = target as ICalendarDateSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.Date = source.Date;
            target.SchoolId = source.SchoolId;

            // Copy non-PK properties

            // Map lists

            if (sourceSynchSupport.IsCalendarDateCalendarEventsSupported)
            {    
                targetSynchSupport.IsCalendarDateCalendarEventIncluded = sourceSynchSupport.IsCalendarDateCalendarEventIncluded;
                source.CalendarDateCalendarEvents.MapListTo(target.CalendarDateCalendarEvents);
            }
            else
            {
                targetSynchSupport.IsCalendarDateCalendarEventsSupported = false;
            }

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ICalendarDateSynchronizationSourceSupport
    {
        bool IsCalendarDateCalendarEventsSupported { get; set; }
        Func<ICalendarDateCalendarEvent, bool> IsCalendarDateCalendarEventIncluded { get; set; }
    }
 
    public static class CalendarDateCalendarEventMapper 
    {
        public static bool SynchronizeTo(this ICalendarDateCalendarEvent source, ICalendarDateCalendarEvent target)
        {
            bool isModified = false;

            var sourceSupport = source as ICalendarDateCalendarEventSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.CalendarEventDescriptor != target.CalendarEventDescriptor)
            {
                source.CalendarEventDescriptor = target.CalendarEventDescriptor;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsEventDurationSupported)
                && target.EventDuration != source.EventDuration)
            {
                target.EventDuration = source.EventDuration;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ICalendarDateCalendarEvent source, ICalendarDateCalendarEvent target, Action<ICalendarDateCalendarEvent, ICalendarDateCalendarEvent> onMapped)
        {
            var sourceSynchSupport = source as ICalendarDateCalendarEventSynchronizationSourceSupport;
            var targetSynchSupport = target as ICalendarDateCalendarEventSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.CalendarEventDescriptor = source.CalendarEventDescriptor;

            // Copy non-PK properties

            if (sourceSynchSupport.IsEventDurationSupported)
                target.EventDuration = source.EventDuration;
            else
                targetSynchSupport.IsEventDurationSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ICalendarDateCalendarEventSynchronizationSourceSupport
    {
        bool IsEventDurationSupported { get; set; }
    }
 
}
// Aggregate: CalendarEventDescriptor

namespace EdFi.Ods.Entities.Common //.CalendarEventDescriptorAggregate
{ 
    public static class CalendarEventDescriptorMapper 
    {
        public static bool SynchronizeTo(this ICalendarEventDescriptor source, ICalendarEventDescriptor target)
        {
            bool isModified = false;

            var sourceSupport = source as ICalendarEventDescriptorSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.CalendarEventDescriptorId != target.CalendarEventDescriptorId)
            {
                source.CalendarEventDescriptorId = target.CalendarEventDescriptorId;
            }

            // Copy inherited non-PK properties


            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveBeginDateSupported)
                && target.EffectiveBeginDate != source.EffectiveBeginDate)
            {
                target.EffectiveBeginDate = source.EffectiveBeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveEndDateSupported)
                && target.EffectiveEndDate != source.EffectiveEndDate)
            {
                target.EffectiveEndDate = source.EffectiveEndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNamespaceSupported)
                && target.Namespace != source.Namespace)
            {
                target.Namespace = source.Namespace;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPriorDescriptorIdSupported)
                && target.PriorDescriptorId != source.PriorDescriptorId)
            {
                target.PriorDescriptorId = source.PriorDescriptorId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCalendarEventTypeSupported)
                && target.CalendarEventType != source.CalendarEventType)
            {
                target.CalendarEventType = source.CalendarEventType;
                isModified = true;
            }

            // Synch inherited lists


            // Sync lists

            return isModified;
        }



        public static void MapTo(this ICalendarEventDescriptor source, ICalendarEventDescriptor target, Action<ICalendarEventDescriptor, ICalendarEventDescriptor> onMapped)
        {
            var sourceSynchSupport = source as ICalendarEventDescriptorSynchronizationSourceSupport;
            var targetSynchSupport = target as ICalendarEventDescriptorSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.CalendarEventDescriptorId = source.CalendarEventDescriptorId;

            // Copy inherited non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsEffectiveBeginDateSupported)
                target.EffectiveBeginDate = source.EffectiveBeginDate;
            else
                targetSynchSupport.IsEffectiveBeginDateSupported = false;

            if (sourceSynchSupport.IsEffectiveEndDateSupported)
                target.EffectiveEndDate = source.EffectiveEndDate;
            else
                targetSynchSupport.IsEffectiveEndDateSupported = false;

            if (sourceSynchSupport.IsNamespaceSupported)
                target.Namespace = source.Namespace;
            else
                targetSynchSupport.IsNamespaceSupported = false;

            if (sourceSynchSupport.IsPriorDescriptorIdSupported)
                target.PriorDescriptorId = source.PriorDescriptorId;
            else
                targetSynchSupport.IsPriorDescriptorIdSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCalendarEventTypeSupported)
                target.CalendarEventType = source.CalendarEventType;
            else
                targetSynchSupport.IsCalendarEventTypeSupported = false;

            // Map inherited lists

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ICalendarEventDescriptorSynchronizationSourceSupport
    {
        bool IsCalendarEventTypeSupported { get; set; }
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsEffectiveBeginDateSupported { get; set; }
        bool IsEffectiveEndDateSupported { get; set; }
        bool IsNamespaceSupported { get; set; }
        bool IsPriorDescriptorIdSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: CalendarEventType

namespace EdFi.Ods.Entities.Common //.CalendarEventTypeAggregate
{ 
    public static class CalendarEventTypeMapper 
    {
        public static bool SynchronizeTo(this ICalendarEventType source, ICalendarEventType target)
        {
            bool isModified = false;

            var sourceSupport = source as ICalendarEventTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.CalendarEventTypeId != target.CalendarEventTypeId)
            {
                source.CalendarEventTypeId = target.CalendarEventTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ICalendarEventType source, ICalendarEventType target, Action<ICalendarEventType, ICalendarEventType> onMapped)
        {
            var sourceSynchSupport = source as ICalendarEventTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as ICalendarEventTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.CalendarEventTypeId = source.CalendarEventTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ICalendarEventTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: CareerPathwayType

namespace EdFi.Ods.Entities.Common //.CareerPathwayTypeAggregate
{ 
    public static class CareerPathwayTypeMapper 
    {
        public static bool SynchronizeTo(this ICareerPathwayType source, ICareerPathwayType target)
        {
            bool isModified = false;

            var sourceSupport = source as ICareerPathwayTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.CareerPathwayTypeId != target.CareerPathwayTypeId)
            {
                source.CareerPathwayTypeId = target.CareerPathwayTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ICareerPathwayType source, ICareerPathwayType target, Action<ICareerPathwayType, ICareerPathwayType> onMapped)
        {
            var sourceSynchSupport = source as ICareerPathwayTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as ICareerPathwayTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.CareerPathwayTypeId = source.CareerPathwayTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ICareerPathwayTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: CharterApprovalAgencyType

namespace EdFi.Ods.Entities.Common //.CharterApprovalAgencyTypeAggregate
{ 
    public static class CharterApprovalAgencyTypeMapper 
    {
        public static bool SynchronizeTo(this ICharterApprovalAgencyType source, ICharterApprovalAgencyType target)
        {
            bool isModified = false;

            var sourceSupport = source as ICharterApprovalAgencyTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.CharterApprovalAgencyTypeId != target.CharterApprovalAgencyTypeId)
            {
                source.CharterApprovalAgencyTypeId = target.CharterApprovalAgencyTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ICharterApprovalAgencyType source, ICharterApprovalAgencyType target, Action<ICharterApprovalAgencyType, ICharterApprovalAgencyType> onMapped)
        {
            var sourceSynchSupport = source as ICharterApprovalAgencyTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as ICharterApprovalAgencyTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.CharterApprovalAgencyTypeId = source.CharterApprovalAgencyTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ICharterApprovalAgencyTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: CharterStatusType

namespace EdFi.Ods.Entities.Common //.CharterStatusTypeAggregate
{ 
    public static class CharterStatusTypeMapper 
    {
        public static bool SynchronizeTo(this ICharterStatusType source, ICharterStatusType target)
        {
            bool isModified = false;

            var sourceSupport = source as ICharterStatusTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.CharterStatusTypeId != target.CharterStatusTypeId)
            {
                source.CharterStatusTypeId = target.CharterStatusTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ICharterStatusType source, ICharterStatusType target, Action<ICharterStatusType, ICharterStatusType> onMapped)
        {
            var sourceSynchSupport = source as ICharterStatusTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as ICharterStatusTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.CharterStatusTypeId = source.CharterStatusTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ICharterStatusTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: CitizenshipStatusType

namespace EdFi.Ods.Entities.Common //.CitizenshipStatusTypeAggregate
{ 
    public static class CitizenshipStatusTypeMapper 
    {
        public static bool SynchronizeTo(this ICitizenshipStatusType source, ICitizenshipStatusType target)
        {
            bool isModified = false;

            var sourceSupport = source as ICitizenshipStatusTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.CitizenshipStatusTypeId != target.CitizenshipStatusTypeId)
            {
                source.CitizenshipStatusTypeId = target.CitizenshipStatusTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ICitizenshipStatusType source, ICitizenshipStatusType target, Action<ICitizenshipStatusType, ICitizenshipStatusType> onMapped)
        {
            var sourceSynchSupport = source as ICitizenshipStatusTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as ICitizenshipStatusTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.CitizenshipStatusTypeId = source.CitizenshipStatusTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ICitizenshipStatusTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: ClassPeriod

namespace EdFi.Ods.Entities.Common //.ClassPeriodAggregate
{ 
    public static class ClassPeriodMapper 
    {
        public static bool SynchronizeTo(this IClassPeriod source, IClassPeriod target)
        {
            bool isModified = false;

            var sourceSupport = source as IClassPeriodSynchronizationSourceSupport;

            // Allow PK column updates on ClassPeriod
            if (
                 (target.ClassPeriodName != source.ClassPeriodName)
                || (target.SchoolId != source.SchoolId))
            {            
                isModified = true;

                var sourceWithPrimaryKeyValues = (source as IHasPrimaryKeyValues);

                if (sourceWithPrimaryKeyValues != null)
                {
                    var targetWithNewKeyValues = target as IHasCascadableKeyValues;

                    if (targetWithNewKeyValues != null)
                        targetWithNewKeyValues.NewKeyValues = sourceWithPrimaryKeyValues.GetPrimaryKeyValues();
                }
            }

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.ClassPeriodName != target.ClassPeriodName)
            {
                source.ClassPeriodName = target.ClassPeriodName;
            }
            if (source.SchoolId != target.SchoolId)
            {
                source.SchoolId = target.SchoolId;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IClassPeriod source, IClassPeriod target, Action<IClassPeriod, IClassPeriod> onMapped)
        {
            var sourceSynchSupport = source as IClassPeriodSynchronizationSourceSupport;
            var targetSynchSupport = target as IClassPeriodSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.ClassPeriodName = source.ClassPeriodName;
            target.SchoolId = source.SchoolId;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IClassPeriodSynchronizationSourceSupport
    {
    }
 
}
// Aggregate: ClassroomPositionDescriptor

namespace EdFi.Ods.Entities.Common //.ClassroomPositionDescriptorAggregate
{ 
    public static class ClassroomPositionDescriptorMapper 
    {
        public static bool SynchronizeTo(this IClassroomPositionDescriptor source, IClassroomPositionDescriptor target)
        {
            bool isModified = false;

            var sourceSupport = source as IClassroomPositionDescriptorSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.ClassroomPositionDescriptorId != target.ClassroomPositionDescriptorId)
            {
                source.ClassroomPositionDescriptorId = target.ClassroomPositionDescriptorId;
            }

            // Copy inherited non-PK properties


            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveBeginDateSupported)
                && target.EffectiveBeginDate != source.EffectiveBeginDate)
            {
                target.EffectiveBeginDate = source.EffectiveBeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveEndDateSupported)
                && target.EffectiveEndDate != source.EffectiveEndDate)
            {
                target.EffectiveEndDate = source.EffectiveEndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNamespaceSupported)
                && target.Namespace != source.Namespace)
            {
                target.Namespace = source.Namespace;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPriorDescriptorIdSupported)
                && target.PriorDescriptorId != source.PriorDescriptorId)
            {
                target.PriorDescriptorId = source.PriorDescriptorId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsClassroomPositionTypeSupported)
                && target.ClassroomPositionType != source.ClassroomPositionType)
            {
                target.ClassroomPositionType = source.ClassroomPositionType;
                isModified = true;
            }

            // Synch inherited lists


            // Sync lists

            return isModified;
        }



        public static void MapTo(this IClassroomPositionDescriptor source, IClassroomPositionDescriptor target, Action<IClassroomPositionDescriptor, IClassroomPositionDescriptor> onMapped)
        {
            var sourceSynchSupport = source as IClassroomPositionDescriptorSynchronizationSourceSupport;
            var targetSynchSupport = target as IClassroomPositionDescriptorSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.ClassroomPositionDescriptorId = source.ClassroomPositionDescriptorId;

            // Copy inherited non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsEffectiveBeginDateSupported)
                target.EffectiveBeginDate = source.EffectiveBeginDate;
            else
                targetSynchSupport.IsEffectiveBeginDateSupported = false;

            if (sourceSynchSupport.IsEffectiveEndDateSupported)
                target.EffectiveEndDate = source.EffectiveEndDate;
            else
                targetSynchSupport.IsEffectiveEndDateSupported = false;

            if (sourceSynchSupport.IsNamespaceSupported)
                target.Namespace = source.Namespace;
            else
                targetSynchSupport.IsNamespaceSupported = false;

            if (sourceSynchSupport.IsPriorDescriptorIdSupported)
                target.PriorDescriptorId = source.PriorDescriptorId;
            else
                targetSynchSupport.IsPriorDescriptorIdSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Copy non-PK properties

            if (sourceSynchSupport.IsClassroomPositionTypeSupported)
                target.ClassroomPositionType = source.ClassroomPositionType;
            else
                targetSynchSupport.IsClassroomPositionTypeSupported = false;

            // Map inherited lists

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IClassroomPositionDescriptorSynchronizationSourceSupport
    {
        bool IsClassroomPositionTypeSupported { get; set; }
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsEffectiveBeginDateSupported { get; set; }
        bool IsEffectiveEndDateSupported { get; set; }
        bool IsNamespaceSupported { get; set; }
        bool IsPriorDescriptorIdSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: ClassroomPositionType

namespace EdFi.Ods.Entities.Common //.ClassroomPositionTypeAggregate
{ 
    public static class ClassroomPositionTypeMapper 
    {
        public static bool SynchronizeTo(this IClassroomPositionType source, IClassroomPositionType target)
        {
            bool isModified = false;

            var sourceSupport = source as IClassroomPositionTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.ClassroomPositionTypeId != target.ClassroomPositionTypeId)
            {
                source.ClassroomPositionTypeId = target.ClassroomPositionTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IClassroomPositionType source, IClassroomPositionType target, Action<IClassroomPositionType, IClassroomPositionType> onMapped)
        {
            var sourceSynchSupport = source as IClassroomPositionTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IClassroomPositionTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.ClassroomPositionTypeId = source.ClassroomPositionTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IClassroomPositionTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: Cohort

namespace EdFi.Ods.Entities.Common //.CohortAggregate
{ 
    public static class CohortMapper 
    {
        public static bool SynchronizeTo(this ICohort source, ICohort target)
        {
            bool isModified = false;

            var sourceSupport = source as ICohortSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.CohortIdentifier != target.CohortIdentifier)
            {
                source.CohortIdentifier = target.CohortIdentifier;
            }
            if (source.EducationOrganizationId != target.EducationOrganizationId)
            {
                source.EducationOrganizationId = target.EducationOrganizationId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsAcademicSubjectDescriptorSupported)
                && target.AcademicSubjectDescriptor != source.AcademicSubjectDescriptor)
            {
                target.AcademicSubjectDescriptor = source.AcademicSubjectDescriptor;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsCohortDescriptionSupported)
                && target.CohortDescription != source.CohortDescription)
            {
                target.CohortDescription = source.CohortDescription;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsCohortScopeTypeSupported)
                && target.CohortScopeType != source.CohortScopeType)
            {
                target.CohortScopeType = source.CohortScopeType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsCohortTypeSupported)
                && target.CohortType != source.CohortType)
            {
                target.CohortType = source.CohortType;
                isModified = true;
            }



            // Sync lists
            if (sourceSupport == null || sourceSupport.IsCohortProgramsSupported)
                isModified |= source.CohortPrograms.SynchronizeListTo(target.CohortPrograms, child => child.Cohort = target,
                                sourceSupport == null ? null : sourceSupport.IsCohortProgramIncluded);


            return isModified;
        }



        public static void MapTo(this ICohort source, ICohort target, Action<ICohort, ICohort> onMapped)
        {
            var sourceSynchSupport = source as ICohortSynchronizationSourceSupport;
            var targetSynchSupport = target as ICohortSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.CohortIdentifier = source.CohortIdentifier;
            target.EducationOrganizationId = source.EducationOrganizationId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsAcademicSubjectDescriptorSupported)
                target.AcademicSubjectDescriptor = source.AcademicSubjectDescriptor;
            else
                targetSynchSupport.IsAcademicSubjectDescriptorSupported = false;

            if (sourceSynchSupport.IsCohortDescriptionSupported)
                target.CohortDescription = source.CohortDescription;
            else
                targetSynchSupport.IsCohortDescriptionSupported = false;

            if (sourceSynchSupport.IsCohortScopeTypeSupported)
                target.CohortScopeType = source.CohortScopeType;
            else
                targetSynchSupport.IsCohortScopeTypeSupported = false;

            if (sourceSynchSupport.IsCohortTypeSupported)
                target.CohortType = source.CohortType;
            else
                targetSynchSupport.IsCohortTypeSupported = false;

            // Map lists

            if (sourceSynchSupport.IsCohortProgramsSupported)
            {    
                targetSynchSupport.IsCohortProgramIncluded = sourceSynchSupport.IsCohortProgramIncluded;
                source.CohortPrograms.MapListTo(target.CohortPrograms);
            }
            else
            {
                targetSynchSupport.IsCohortProgramsSupported = false;
            }

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ICohortSynchronizationSourceSupport
    {
        bool IsAcademicSubjectDescriptorSupported { get; set; }
        bool IsCohortDescriptionSupported { get; set; }
        bool IsCohortProgramsSupported { get; set; }
        bool IsCohortScopeTypeSupported { get; set; }
        bool IsCohortTypeSupported { get; set; }
        Func<ICohortProgram, bool> IsCohortProgramIncluded { get; set; }
    }
 
    public static class CohortProgramMapper 
    {
        public static bool SynchronizeTo(this ICohortProgram source, ICohortProgram target)
        {
            bool isModified = false;

            var sourceSupport = source as ICohortProgramSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.ProgramEducationOrganizationId != target.ProgramEducationOrganizationId)
            {
                source.ProgramEducationOrganizationId = target.ProgramEducationOrganizationId;
            }
            if (source.ProgramName != target.ProgramName)
            {
                source.ProgramName = target.ProgramName;
            }
            if (source.ProgramType != target.ProgramType)
            {
                source.ProgramType = target.ProgramType;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ICohortProgram source, ICohortProgram target, Action<ICohortProgram, ICohortProgram> onMapped)
        {
            var sourceSynchSupport = source as ICohortProgramSynchronizationSourceSupport;
            var targetSynchSupport = target as ICohortProgramSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.ProgramEducationOrganizationId = source.ProgramEducationOrganizationId;
            target.ProgramName = source.ProgramName;
            target.ProgramType = source.ProgramType;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ICohortProgramSynchronizationSourceSupport
    {
    }
 
}
// Aggregate: CohortScopeType

namespace EdFi.Ods.Entities.Common //.CohortScopeTypeAggregate
{ 
    public static class CohortScopeTypeMapper 
    {
        public static bool SynchronizeTo(this ICohortScopeType source, ICohortScopeType target)
        {
            bool isModified = false;

            var sourceSupport = source as ICohortScopeTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.CohortScopeTypeId != target.CohortScopeTypeId)
            {
                source.CohortScopeTypeId = target.CohortScopeTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ICohortScopeType source, ICohortScopeType target, Action<ICohortScopeType, ICohortScopeType> onMapped)
        {
            var sourceSynchSupport = source as ICohortScopeTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as ICohortScopeTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.CohortScopeTypeId = source.CohortScopeTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ICohortScopeTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: CohortType

namespace EdFi.Ods.Entities.Common //.CohortTypeAggregate
{ 
    public static class CohortTypeMapper 
    {
        public static bool SynchronizeTo(this ICohortType source, ICohortType target)
        {
            bool isModified = false;

            var sourceSupport = source as ICohortTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.CohortTypeId != target.CohortTypeId)
            {
                source.CohortTypeId = target.CohortTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ICohortType source, ICohortType target, Action<ICohortType, ICohortType> onMapped)
        {
            var sourceSynchSupport = source as ICohortTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as ICohortTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.CohortTypeId = source.CohortTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ICohortTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: CohortYearType

namespace EdFi.Ods.Entities.Common //.CohortYearTypeAggregate
{ 
    public static class CohortYearTypeMapper 
    {
        public static bool SynchronizeTo(this ICohortYearType source, ICohortYearType target)
        {
            bool isModified = false;

            var sourceSupport = source as ICohortYearTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.CohortYearTypeId != target.CohortYearTypeId)
            {
                source.CohortYearTypeId = target.CohortYearTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ICohortYearType source, ICohortYearType target, Action<ICohortYearType, ICohortYearType> onMapped)
        {
            var sourceSynchSupport = source as ICohortYearTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as ICohortYearTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.CohortYearTypeId = source.CohortYearTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ICohortYearTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: CompetencyLevelDescriptor

namespace EdFi.Ods.Entities.Common //.CompetencyLevelDescriptorAggregate
{ 
    public static class CompetencyLevelDescriptorMapper 
    {
        public static bool SynchronizeTo(this ICompetencyLevelDescriptor source, ICompetencyLevelDescriptor target)
        {
            bool isModified = false;

            var sourceSupport = source as ICompetencyLevelDescriptorSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.CompetencyLevelDescriptorId != target.CompetencyLevelDescriptorId)
            {
                source.CompetencyLevelDescriptorId = target.CompetencyLevelDescriptorId;
            }

            // Copy inherited non-PK properties


            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveBeginDateSupported)
                && target.EffectiveBeginDate != source.EffectiveBeginDate)
            {
                target.EffectiveBeginDate = source.EffectiveBeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveEndDateSupported)
                && target.EffectiveEndDate != source.EffectiveEndDate)
            {
                target.EffectiveEndDate = source.EffectiveEndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNamespaceSupported)
                && target.Namespace != source.Namespace)
            {
                target.Namespace = source.Namespace;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPriorDescriptorIdSupported)
                && target.PriorDescriptorId != source.PriorDescriptorId)
            {
                target.PriorDescriptorId = source.PriorDescriptorId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsPerformanceBaseConversionTypeSupported)
                && target.PerformanceBaseConversionType != source.PerformanceBaseConversionType)
            {
                target.PerformanceBaseConversionType = source.PerformanceBaseConversionType;
                isModified = true;
            }

            // Synch inherited lists


            // Sync lists

            return isModified;
        }



        public static void MapTo(this ICompetencyLevelDescriptor source, ICompetencyLevelDescriptor target, Action<ICompetencyLevelDescriptor, ICompetencyLevelDescriptor> onMapped)
        {
            var sourceSynchSupport = source as ICompetencyLevelDescriptorSynchronizationSourceSupport;
            var targetSynchSupport = target as ICompetencyLevelDescriptorSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.CompetencyLevelDescriptorId = source.CompetencyLevelDescriptorId;

            // Copy inherited non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsEffectiveBeginDateSupported)
                target.EffectiveBeginDate = source.EffectiveBeginDate;
            else
                targetSynchSupport.IsEffectiveBeginDateSupported = false;

            if (sourceSynchSupport.IsEffectiveEndDateSupported)
                target.EffectiveEndDate = source.EffectiveEndDate;
            else
                targetSynchSupport.IsEffectiveEndDateSupported = false;

            if (sourceSynchSupport.IsNamespaceSupported)
                target.Namespace = source.Namespace;
            else
                targetSynchSupport.IsNamespaceSupported = false;

            if (sourceSynchSupport.IsPriorDescriptorIdSupported)
                target.PriorDescriptorId = source.PriorDescriptorId;
            else
                targetSynchSupport.IsPriorDescriptorIdSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Copy non-PK properties

            if (sourceSynchSupport.IsPerformanceBaseConversionTypeSupported)
                target.PerformanceBaseConversionType = source.PerformanceBaseConversionType;
            else
                targetSynchSupport.IsPerformanceBaseConversionTypeSupported = false;

            // Map inherited lists

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ICompetencyLevelDescriptorSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsEffectiveBeginDateSupported { get; set; }
        bool IsEffectiveEndDateSupported { get; set; }
        bool IsNamespaceSupported { get; set; }
        bool IsPerformanceBaseConversionTypeSupported { get; set; }
        bool IsPriorDescriptorIdSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: CompetencyObjective

namespace EdFi.Ods.Entities.Common //.CompetencyObjectiveAggregate
{ 
    public static class CompetencyObjectiveMapper 
    {
        public static bool SynchronizeTo(this ICompetencyObjective source, ICompetencyObjective target)
        {
            bool isModified = false;

            var sourceSupport = source as ICompetencyObjectiveSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.EducationOrganizationId != target.EducationOrganizationId)
            {
                source.EducationOrganizationId = target.EducationOrganizationId;
            }
            if (source.Objective != target.Objective)
            {
                source.Objective = target.Objective;
            }
            if (source.ObjectiveGradeLevelDescriptor != target.ObjectiveGradeLevelDescriptor)
            {
                source.ObjectiveGradeLevelDescriptor = target.ObjectiveGradeLevelDescriptor;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCompetencyObjectiveIdSupported)
                && target.CompetencyObjectiveId != source.CompetencyObjectiveId)
            {
                target.CompetencyObjectiveId = source.CompetencyObjectiveId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsSuccessCriteriaSupported)
                && target.SuccessCriteria != source.SuccessCriteria)
            {
                target.SuccessCriteria = source.SuccessCriteria;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ICompetencyObjective source, ICompetencyObjective target, Action<ICompetencyObjective, ICompetencyObjective> onMapped)
        {
            var sourceSynchSupport = source as ICompetencyObjectiveSynchronizationSourceSupport;
            var targetSynchSupport = target as ICompetencyObjectiveSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.EducationOrganizationId = source.EducationOrganizationId;
            target.Objective = source.Objective;
            target.ObjectiveGradeLevelDescriptor = source.ObjectiveGradeLevelDescriptor;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCompetencyObjectiveIdSupported)
                target.CompetencyObjectiveId = source.CompetencyObjectiveId;
            else
                targetSynchSupport.IsCompetencyObjectiveIdSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsSuccessCriteriaSupported)
                target.SuccessCriteria = source.SuccessCriteria;
            else
                targetSynchSupport.IsSuccessCriteriaSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ICompetencyObjectiveSynchronizationSourceSupport
    {
        bool IsCompetencyObjectiveIdSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsSuccessCriteriaSupported { get; set; }
    }
 
}
// Aggregate: ContentClassType

namespace EdFi.Ods.Entities.Common //.ContentClassTypeAggregate
{ 
    public static class ContentClassTypeMapper 
    {
        public static bool SynchronizeTo(this IContentClassType source, IContentClassType target)
        {
            bool isModified = false;

            var sourceSupport = source as IContentClassTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.ContentClassTypeId != target.ContentClassTypeId)
            {
                source.ContentClassTypeId = target.ContentClassTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IContentClassType source, IContentClassType target, Action<IContentClassType, IContentClassType> onMapped)
        {
            var sourceSynchSupport = source as IContentClassTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IContentClassTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.ContentClassTypeId = source.ContentClassTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IContentClassTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: ContinuationOfServicesReasonDescriptor

namespace EdFi.Ods.Entities.Common //.ContinuationOfServicesReasonDescriptorAggregate
{ 
    public static class ContinuationOfServicesReasonDescriptorMapper 
    {
        public static bool SynchronizeTo(this IContinuationOfServicesReasonDescriptor source, IContinuationOfServicesReasonDescriptor target)
        {
            bool isModified = false;

            var sourceSupport = source as IContinuationOfServicesReasonDescriptorSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.ContinuationOfServicesReasonDescriptorId != target.ContinuationOfServicesReasonDescriptorId)
            {
                source.ContinuationOfServicesReasonDescriptorId = target.ContinuationOfServicesReasonDescriptorId;
            }

            // Copy inherited non-PK properties


            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveBeginDateSupported)
                && target.EffectiveBeginDate != source.EffectiveBeginDate)
            {
                target.EffectiveBeginDate = source.EffectiveBeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveEndDateSupported)
                && target.EffectiveEndDate != source.EffectiveEndDate)
            {
                target.EffectiveEndDate = source.EffectiveEndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNamespaceSupported)
                && target.Namespace != source.Namespace)
            {
                target.Namespace = source.Namespace;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPriorDescriptorIdSupported)
                && target.PriorDescriptorId != source.PriorDescriptorId)
            {
                target.PriorDescriptorId = source.PriorDescriptorId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsContinuationOfServicesReasonTypeSupported)
                && target.ContinuationOfServicesReasonType != source.ContinuationOfServicesReasonType)
            {
                target.ContinuationOfServicesReasonType = source.ContinuationOfServicesReasonType;
                isModified = true;
            }

            // Synch inherited lists


            // Sync lists

            return isModified;
        }



        public static void MapTo(this IContinuationOfServicesReasonDescriptor source, IContinuationOfServicesReasonDescriptor target, Action<IContinuationOfServicesReasonDescriptor, IContinuationOfServicesReasonDescriptor> onMapped)
        {
            var sourceSynchSupport = source as IContinuationOfServicesReasonDescriptorSynchronizationSourceSupport;
            var targetSynchSupport = target as IContinuationOfServicesReasonDescriptorSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.ContinuationOfServicesReasonDescriptorId = source.ContinuationOfServicesReasonDescriptorId;

            // Copy inherited non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsEffectiveBeginDateSupported)
                target.EffectiveBeginDate = source.EffectiveBeginDate;
            else
                targetSynchSupport.IsEffectiveBeginDateSupported = false;

            if (sourceSynchSupport.IsEffectiveEndDateSupported)
                target.EffectiveEndDate = source.EffectiveEndDate;
            else
                targetSynchSupport.IsEffectiveEndDateSupported = false;

            if (sourceSynchSupport.IsNamespaceSupported)
                target.Namespace = source.Namespace;
            else
                targetSynchSupport.IsNamespaceSupported = false;

            if (sourceSynchSupport.IsPriorDescriptorIdSupported)
                target.PriorDescriptorId = source.PriorDescriptorId;
            else
                targetSynchSupport.IsPriorDescriptorIdSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Copy non-PK properties

            if (sourceSynchSupport.IsContinuationOfServicesReasonTypeSupported)
                target.ContinuationOfServicesReasonType = source.ContinuationOfServicesReasonType;
            else
                targetSynchSupport.IsContinuationOfServicesReasonTypeSupported = false;

            // Map inherited lists

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IContinuationOfServicesReasonDescriptorSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsContinuationOfServicesReasonTypeSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsEffectiveBeginDateSupported { get; set; }
        bool IsEffectiveEndDateSupported { get; set; }
        bool IsNamespaceSupported { get; set; }
        bool IsPriorDescriptorIdSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: ContinuationOfServicesReasonType

namespace EdFi.Ods.Entities.Common //.ContinuationOfServicesReasonTypeAggregate
{ 
    public static class ContinuationOfServicesReasonTypeMapper 
    {
        public static bool SynchronizeTo(this IContinuationOfServicesReasonType source, IContinuationOfServicesReasonType target)
        {
            bool isModified = false;

            var sourceSupport = source as IContinuationOfServicesReasonTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.ContinuationOfServicesReasonTypeId != target.ContinuationOfServicesReasonTypeId)
            {
                source.ContinuationOfServicesReasonTypeId = target.ContinuationOfServicesReasonTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IContinuationOfServicesReasonType source, IContinuationOfServicesReasonType target, Action<IContinuationOfServicesReasonType, IContinuationOfServicesReasonType> onMapped)
        {
            var sourceSynchSupport = source as IContinuationOfServicesReasonTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IContinuationOfServicesReasonTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.ContinuationOfServicesReasonTypeId = source.ContinuationOfServicesReasonTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IContinuationOfServicesReasonTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: ContractedStaff

namespace EdFi.Ods.Entities.Common //.ContractedStaffAggregate
{ 
    public static class ContractedStaffMapper 
    {
        public static bool SynchronizeTo(this IContractedStaff source, IContractedStaff target)
        {
            bool isModified = false;

            var sourceSupport = source as IContractedStaffSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AccountNumber != target.AccountNumber)
            {
                source.AccountNumber = target.AccountNumber;
            }
            if (source.AsOfDate != target.AsOfDate)
            {
                source.AsOfDate = target.AsOfDate;
            }
            if (source.EducationOrganizationId != target.EducationOrganizationId)
            {
                source.EducationOrganizationId = target.EducationOrganizationId;
            }
            if (source.FiscalYear != target.FiscalYear)
            {
                source.FiscalYear = target.FiscalYear;
            }
            if (source.StaffUniqueId != target.StaffUniqueId)
            {
                source.StaffUniqueId = target.StaffUniqueId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsAmountToDateSupported)
                && target.AmountToDate != source.AmountToDate)
            {
                target.AmountToDate = source.AmountToDate;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IContractedStaff source, IContractedStaff target, Action<IContractedStaff, IContractedStaff> onMapped)
        {
            var sourceSynchSupport = source as IContractedStaffSynchronizationSourceSupport;
            var targetSynchSupport = target as IContractedStaffSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.AccountNumber = source.AccountNumber;
            target.AsOfDate = source.AsOfDate;
            target.EducationOrganizationId = source.EducationOrganizationId;
            target.FiscalYear = source.FiscalYear;
            target.StaffUniqueId = source.StaffUniqueId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsAmountToDateSupported)
                target.AmountToDate = source.AmountToDate;
            else
                targetSynchSupport.IsAmountToDateSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IContractedStaffSynchronizationSourceSupport
    {
        bool IsAmountToDateSupported { get; set; }
    }
 
}
// Aggregate: CostRateType

namespace EdFi.Ods.Entities.Common //.CostRateTypeAggregate
{ 
    public static class CostRateTypeMapper 
    {
        public static bool SynchronizeTo(this ICostRateType source, ICostRateType target)
        {
            bool isModified = false;

            var sourceSupport = source as ICostRateTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.CostRateTypeId != target.CostRateTypeId)
            {
                source.CostRateTypeId = target.CostRateTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ICostRateType source, ICostRateType target, Action<ICostRateType, ICostRateType> onMapped)
        {
            var sourceSynchSupport = source as ICostRateTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as ICostRateTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.CostRateTypeId = source.CostRateTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ICostRateTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: CountryDescriptor

namespace EdFi.Ods.Entities.Common //.CountryDescriptorAggregate
{ 
    public static class CountryDescriptorMapper 
    {
        public static bool SynchronizeTo(this ICountryDescriptor source, ICountryDescriptor target)
        {
            bool isModified = false;

            var sourceSupport = source as ICountryDescriptorSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.CountryDescriptorId != target.CountryDescriptorId)
            {
                source.CountryDescriptorId = target.CountryDescriptorId;
            }

            // Copy inherited non-PK properties


            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveBeginDateSupported)
                && target.EffectiveBeginDate != source.EffectiveBeginDate)
            {
                target.EffectiveBeginDate = source.EffectiveBeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveEndDateSupported)
                && target.EffectiveEndDate != source.EffectiveEndDate)
            {
                target.EffectiveEndDate = source.EffectiveEndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNamespaceSupported)
                && target.Namespace != source.Namespace)
            {
                target.Namespace = source.Namespace;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPriorDescriptorIdSupported)
                && target.PriorDescriptorId != source.PriorDescriptorId)
            {
                target.PriorDescriptorId = source.PriorDescriptorId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }

            // Copy non-PK properties

            // Synch inherited lists


            // Sync lists

            return isModified;
        }



        public static void MapTo(this ICountryDescriptor source, ICountryDescriptor target, Action<ICountryDescriptor, ICountryDescriptor> onMapped)
        {
            var sourceSynchSupport = source as ICountryDescriptorSynchronizationSourceSupport;
            var targetSynchSupport = target as ICountryDescriptorSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.CountryDescriptorId = source.CountryDescriptorId;

            // Copy inherited non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsEffectiveBeginDateSupported)
                target.EffectiveBeginDate = source.EffectiveBeginDate;
            else
                targetSynchSupport.IsEffectiveBeginDateSupported = false;

            if (sourceSynchSupport.IsEffectiveEndDateSupported)
                target.EffectiveEndDate = source.EffectiveEndDate;
            else
                targetSynchSupport.IsEffectiveEndDateSupported = false;

            if (sourceSynchSupport.IsNamespaceSupported)
                target.Namespace = source.Namespace;
            else
                targetSynchSupport.IsNamespaceSupported = false;

            if (sourceSynchSupport.IsPriorDescriptorIdSupported)
                target.PriorDescriptorId = source.PriorDescriptorId;
            else
                targetSynchSupport.IsPriorDescriptorIdSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Copy non-PK properties

            // Map inherited lists

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ICountryDescriptorSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsEffectiveBeginDateSupported { get; set; }
        bool IsEffectiveEndDateSupported { get; set; }
        bool IsNamespaceSupported { get; set; }
        bool IsPriorDescriptorIdSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: Course

namespace EdFi.Ods.Entities.Common //.CourseAggregate
{ 
    public static class CourseMapper 
    {
        public static bool SynchronizeTo(this ICourse source, ICourse target)
        {
            bool isModified = false;

            var sourceSupport = source as ICourseSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.CourseCode != target.CourseCode)
            {
                source.CourseCode = target.CourseCode;
            }
            if (source.EducationOrganizationId != target.EducationOrganizationId)
            {
                source.EducationOrganizationId = target.EducationOrganizationId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsAcademicSubjectDescriptorSupported)
                && target.AcademicSubjectDescriptor != source.AcademicSubjectDescriptor)
            {
                target.AcademicSubjectDescriptor = source.AcademicSubjectDescriptor;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsCareerPathwayTypeSupported)
                && target.CareerPathwayType != source.CareerPathwayType)
            {
                target.CareerPathwayType = source.CareerPathwayType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsCourseDefinedByTypeSupported)
                && target.CourseDefinedByType != source.CourseDefinedByType)
            {
                target.CourseDefinedByType = source.CourseDefinedByType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsCourseDescriptionSupported)
                && target.CourseDescription != source.CourseDescription)
            {
                target.CourseDescription = source.CourseDescription;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsCourseGPAApplicabilityTypeSupported)
                && target.CourseGPAApplicabilityType != source.CourseGPAApplicabilityType)
            {
                target.CourseGPAApplicabilityType = source.CourseGPAApplicabilityType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsCourseTitleSupported)
                && target.CourseTitle != source.CourseTitle)
            {
                target.CourseTitle = source.CourseTitle;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDateCourseAdoptedSupported)
                && target.DateCourseAdopted != source.DateCourseAdopted)
            {
                target.DateCourseAdopted = source.DateCourseAdopted;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsHighSchoolCourseRequirementSupported)
                && target.HighSchoolCourseRequirement != source.HighSchoolCourseRequirement)
            {
                target.HighSchoolCourseRequirement = source.HighSchoolCourseRequirement;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsMaximumAvailableCreditConversionSupported)
                && target.MaximumAvailableCreditConversion != source.MaximumAvailableCreditConversion)
            {
                target.MaximumAvailableCreditConversion = source.MaximumAvailableCreditConversion;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsMaximumAvailableCreditsSupported)
                && target.MaximumAvailableCredits != source.MaximumAvailableCredits)
            {
                target.MaximumAvailableCredits = source.MaximumAvailableCredits;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsMaximumAvailableCreditTypeSupported)
                && target.MaximumAvailableCreditType != source.MaximumAvailableCreditType)
            {
                target.MaximumAvailableCreditType = source.MaximumAvailableCreditType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsMinimumAvailableCreditConversionSupported)
                && target.MinimumAvailableCreditConversion != source.MinimumAvailableCreditConversion)
            {
                target.MinimumAvailableCreditConversion = source.MinimumAvailableCreditConversion;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsMinimumAvailableCreditsSupported)
                && target.MinimumAvailableCredits != source.MinimumAvailableCredits)
            {
                target.MinimumAvailableCredits = source.MinimumAvailableCredits;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsMinimumAvailableCreditTypeSupported)
                && target.MinimumAvailableCreditType != source.MinimumAvailableCreditType)
            {
                target.MinimumAvailableCreditType = source.MinimumAvailableCreditType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNumberOfPartsSupported)
                && target.NumberOfParts != source.NumberOfParts)
            {
                target.NumberOfParts = source.NumberOfParts;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsTimeRequiredForCompletionSupported)
                && target.TimeRequiredForCompletion != source.TimeRequiredForCompletion)
            {
                target.TimeRequiredForCompletion = source.TimeRequiredForCompletion;
                isModified = true;
            }



            // Sync lists
            if (sourceSupport == null || sourceSupport.IsCourseCompetencyLevelsSupported)
                isModified |= source.CourseCompetencyLevels.SynchronizeListTo(target.CourseCompetencyLevels, child => child.Course = target,
                                sourceSupport == null ? null : sourceSupport.IsCourseCompetencyLevelIncluded);

            if (sourceSupport == null || sourceSupport.IsCourseIdentificationCodesSupported)
                isModified |= source.CourseIdentificationCodes.SynchronizeListTo(target.CourseIdentificationCodes, child => child.Course = target,
                                sourceSupport == null ? null : sourceSupport.IsCourseIdentificationCodeIncluded);

            if (sourceSupport == null || sourceSupport.IsCourseLearningObjectivesSupported)
                isModified |= source.CourseLearningObjectives.SynchronizeListTo(target.CourseLearningObjectives, child => child.Course = target,
                                sourceSupport == null ? null : sourceSupport.IsCourseLearningObjectiveIncluded);

            if (sourceSupport == null || sourceSupport.IsCourseLearningStandardsSupported)
                isModified |= source.CourseLearningStandards.SynchronizeListTo(target.CourseLearningStandards, child => child.Course = target,
                                sourceSupport == null ? null : sourceSupport.IsCourseLearningStandardIncluded);

            if (sourceSupport == null || sourceSupport.IsCourseLevelCharacteristicsSupported)
                isModified |= source.CourseLevelCharacteristics.SynchronizeListTo(target.CourseLevelCharacteristics, child => child.Course = target,
                                sourceSupport == null ? null : sourceSupport.IsCourseLevelCharacteristicIncluded);

            if (sourceSupport == null || sourceSupport.IsCourseOfferedGradeLevelsSupported)
                isModified |= source.CourseOfferedGradeLevels.SynchronizeListTo(target.CourseOfferedGradeLevels, child => child.Course = target,
                                sourceSupport == null ? null : sourceSupport.IsCourseOfferedGradeLevelIncluded);


            return isModified;
        }



        public static void MapTo(this ICourse source, ICourse target, Action<ICourse, ICourse> onMapped)
        {
            var sourceSynchSupport = source as ICourseSynchronizationSourceSupport;
            var targetSynchSupport = target as ICourseSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.CourseCode = source.CourseCode;
            target.EducationOrganizationId = source.EducationOrganizationId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsAcademicSubjectDescriptorSupported)
                target.AcademicSubjectDescriptor = source.AcademicSubjectDescriptor;
            else
                targetSynchSupport.IsAcademicSubjectDescriptorSupported = false;

            if (sourceSynchSupport.IsCareerPathwayTypeSupported)
                target.CareerPathwayType = source.CareerPathwayType;
            else
                targetSynchSupport.IsCareerPathwayTypeSupported = false;

            if (sourceSynchSupport.IsCourseDefinedByTypeSupported)
                target.CourseDefinedByType = source.CourseDefinedByType;
            else
                targetSynchSupport.IsCourseDefinedByTypeSupported = false;

            if (sourceSynchSupport.IsCourseDescriptionSupported)
                target.CourseDescription = source.CourseDescription;
            else
                targetSynchSupport.IsCourseDescriptionSupported = false;

            if (sourceSynchSupport.IsCourseGPAApplicabilityTypeSupported)
                target.CourseGPAApplicabilityType = source.CourseGPAApplicabilityType;
            else
                targetSynchSupport.IsCourseGPAApplicabilityTypeSupported = false;

            if (sourceSynchSupport.IsCourseTitleSupported)
                target.CourseTitle = source.CourseTitle;
            else
                targetSynchSupport.IsCourseTitleSupported = false;

            if (sourceSynchSupport.IsDateCourseAdoptedSupported)
                target.DateCourseAdopted = source.DateCourseAdopted;
            else
                targetSynchSupport.IsDateCourseAdoptedSupported = false;

            if (sourceSynchSupport.IsHighSchoolCourseRequirementSupported)
                target.HighSchoolCourseRequirement = source.HighSchoolCourseRequirement;
            else
                targetSynchSupport.IsHighSchoolCourseRequirementSupported = false;

            if (sourceSynchSupport.IsMaximumAvailableCreditConversionSupported)
                target.MaximumAvailableCreditConversion = source.MaximumAvailableCreditConversion;
            else
                targetSynchSupport.IsMaximumAvailableCreditConversionSupported = false;

            if (sourceSynchSupport.IsMaximumAvailableCreditsSupported)
                target.MaximumAvailableCredits = source.MaximumAvailableCredits;
            else
                targetSynchSupport.IsMaximumAvailableCreditsSupported = false;

            if (sourceSynchSupport.IsMaximumAvailableCreditTypeSupported)
                target.MaximumAvailableCreditType = source.MaximumAvailableCreditType;
            else
                targetSynchSupport.IsMaximumAvailableCreditTypeSupported = false;

            if (sourceSynchSupport.IsMinimumAvailableCreditConversionSupported)
                target.MinimumAvailableCreditConversion = source.MinimumAvailableCreditConversion;
            else
                targetSynchSupport.IsMinimumAvailableCreditConversionSupported = false;

            if (sourceSynchSupport.IsMinimumAvailableCreditsSupported)
                target.MinimumAvailableCredits = source.MinimumAvailableCredits;
            else
                targetSynchSupport.IsMinimumAvailableCreditsSupported = false;

            if (sourceSynchSupport.IsMinimumAvailableCreditTypeSupported)
                target.MinimumAvailableCreditType = source.MinimumAvailableCreditType;
            else
                targetSynchSupport.IsMinimumAvailableCreditTypeSupported = false;

            if (sourceSynchSupport.IsNumberOfPartsSupported)
                target.NumberOfParts = source.NumberOfParts;
            else
                targetSynchSupport.IsNumberOfPartsSupported = false;

            if (sourceSynchSupport.IsTimeRequiredForCompletionSupported)
                target.TimeRequiredForCompletion = source.TimeRequiredForCompletion;
            else
                targetSynchSupport.IsTimeRequiredForCompletionSupported = false;

            // Map lists

            if (sourceSynchSupport.IsCourseCompetencyLevelsSupported)
            {    
                targetSynchSupport.IsCourseCompetencyLevelIncluded = sourceSynchSupport.IsCourseCompetencyLevelIncluded;
                source.CourseCompetencyLevels.MapListTo(target.CourseCompetencyLevels);
            }
            else
            {
                targetSynchSupport.IsCourseCompetencyLevelsSupported = false;
            }

            if (sourceSynchSupport.IsCourseIdentificationCodesSupported)
            {    
                targetSynchSupport.IsCourseIdentificationCodeIncluded = sourceSynchSupport.IsCourseIdentificationCodeIncluded;
                source.CourseIdentificationCodes.MapListTo(target.CourseIdentificationCodes);
            }
            else
            {
                targetSynchSupport.IsCourseIdentificationCodesSupported = false;
            }

            if (sourceSynchSupport.IsCourseLearningObjectivesSupported)
            {    
                targetSynchSupport.IsCourseLearningObjectiveIncluded = sourceSynchSupport.IsCourseLearningObjectiveIncluded;
                source.CourseLearningObjectives.MapListTo(target.CourseLearningObjectives);
            }
            else
            {
                targetSynchSupport.IsCourseLearningObjectivesSupported = false;
            }

            if (sourceSynchSupport.IsCourseLearningStandardsSupported)
            {    
                targetSynchSupport.IsCourseLearningStandardIncluded = sourceSynchSupport.IsCourseLearningStandardIncluded;
                source.CourseLearningStandards.MapListTo(target.CourseLearningStandards);
            }
            else
            {
                targetSynchSupport.IsCourseLearningStandardsSupported = false;
            }

            if (sourceSynchSupport.IsCourseLevelCharacteristicsSupported)
            {    
                targetSynchSupport.IsCourseLevelCharacteristicIncluded = sourceSynchSupport.IsCourseLevelCharacteristicIncluded;
                source.CourseLevelCharacteristics.MapListTo(target.CourseLevelCharacteristics);
            }
            else
            {
                targetSynchSupport.IsCourseLevelCharacteristicsSupported = false;
            }

            if (sourceSynchSupport.IsCourseOfferedGradeLevelsSupported)
            {    
                targetSynchSupport.IsCourseOfferedGradeLevelIncluded = sourceSynchSupport.IsCourseOfferedGradeLevelIncluded;
                source.CourseOfferedGradeLevels.MapListTo(target.CourseOfferedGradeLevels);
            }
            else
            {
                targetSynchSupport.IsCourseOfferedGradeLevelsSupported = false;
            }

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ICourseSynchronizationSourceSupport
    {
        bool IsAcademicSubjectDescriptorSupported { get; set; }
        bool IsCareerPathwayTypeSupported { get; set; }
        bool IsCourseCompetencyLevelsSupported { get; set; }
        bool IsCourseDefinedByTypeSupported { get; set; }
        bool IsCourseDescriptionSupported { get; set; }
        bool IsCourseGPAApplicabilityTypeSupported { get; set; }
        bool IsCourseIdentificationCodesSupported { get; set; }
        bool IsCourseLearningObjectivesSupported { get; set; }
        bool IsCourseLearningStandardsSupported { get; set; }
        bool IsCourseLevelCharacteristicsSupported { get; set; }
        bool IsCourseOfferedGradeLevelsSupported { get; set; }
        bool IsCourseTitleSupported { get; set; }
        bool IsDateCourseAdoptedSupported { get; set; }
        bool IsHighSchoolCourseRequirementSupported { get; set; }
        bool IsMaximumAvailableCreditConversionSupported { get; set; }
        bool IsMaximumAvailableCreditsSupported { get; set; }
        bool IsMaximumAvailableCreditTypeSupported { get; set; }
        bool IsMinimumAvailableCreditConversionSupported { get; set; }
        bool IsMinimumAvailableCreditsSupported { get; set; }
        bool IsMinimumAvailableCreditTypeSupported { get; set; }
        bool IsNumberOfPartsSupported { get; set; }
        bool IsTimeRequiredForCompletionSupported { get; set; }
        Func<ICourseCompetencyLevel, bool> IsCourseCompetencyLevelIncluded { get; set; }
        Func<ICourseIdentificationCode, bool> IsCourseIdentificationCodeIncluded { get; set; }
        Func<ICourseLearningObjective, bool> IsCourseLearningObjectiveIncluded { get; set; }
        Func<ICourseLearningStandard, bool> IsCourseLearningStandardIncluded { get; set; }
        Func<ICourseLevelCharacteristic, bool> IsCourseLevelCharacteristicIncluded { get; set; }
        Func<ICourseOfferedGradeLevel, bool> IsCourseOfferedGradeLevelIncluded { get; set; }
    }
 
    public static class CourseCompetencyLevelMapper 
    {
        public static bool SynchronizeTo(this ICourseCompetencyLevel source, ICourseCompetencyLevel target)
        {
            bool isModified = false;

            var sourceSupport = source as ICourseCompetencyLevelSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.CompetencyLevelDescriptor != target.CompetencyLevelDescriptor)
            {
                source.CompetencyLevelDescriptor = target.CompetencyLevelDescriptor;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ICourseCompetencyLevel source, ICourseCompetencyLevel target, Action<ICourseCompetencyLevel, ICourseCompetencyLevel> onMapped)
        {
            var sourceSynchSupport = source as ICourseCompetencyLevelSynchronizationSourceSupport;
            var targetSynchSupport = target as ICourseCompetencyLevelSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.CompetencyLevelDescriptor = source.CompetencyLevelDescriptor;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ICourseCompetencyLevelSynchronizationSourceSupport
    {
    }
 
    public static class CourseIdentificationCodeMapper 
    {
        public static bool SynchronizeTo(this ICourseIdentificationCode source, ICourseIdentificationCode target)
        {
            bool isModified = false;

            var sourceSupport = source as ICourseIdentificationCodeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.CourseIdentificationSystemDescriptor != target.CourseIdentificationSystemDescriptor)
            {
                source.CourseIdentificationSystemDescriptor = target.CourseIdentificationSystemDescriptor;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsAssigningOrganizationIdentificationCodeSupported)
                && target.AssigningOrganizationIdentificationCode != source.AssigningOrganizationIdentificationCode)
            {
                target.AssigningOrganizationIdentificationCode = source.AssigningOrganizationIdentificationCode;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsIdentificationCodeSupported)
                && target.IdentificationCode != source.IdentificationCode)
            {
                target.IdentificationCode = source.IdentificationCode;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ICourseIdentificationCode source, ICourseIdentificationCode target, Action<ICourseIdentificationCode, ICourseIdentificationCode> onMapped)
        {
            var sourceSynchSupport = source as ICourseIdentificationCodeSynchronizationSourceSupport;
            var targetSynchSupport = target as ICourseIdentificationCodeSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.CourseIdentificationSystemDescriptor = source.CourseIdentificationSystemDescriptor;

            // Copy non-PK properties

            if (sourceSynchSupport.IsAssigningOrganizationIdentificationCodeSupported)
                target.AssigningOrganizationIdentificationCode = source.AssigningOrganizationIdentificationCode;
            else
                targetSynchSupport.IsAssigningOrganizationIdentificationCodeSupported = false;

            if (sourceSynchSupport.IsIdentificationCodeSupported)
                target.IdentificationCode = source.IdentificationCode;
            else
                targetSynchSupport.IsIdentificationCodeSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ICourseIdentificationCodeSynchronizationSourceSupport
    {
        bool IsAssigningOrganizationIdentificationCodeSupported { get; set; }
        bool IsIdentificationCodeSupported { get; set; }
    }
 
    public static class CourseLearningObjectiveMapper 
    {
        public static bool SynchronizeTo(this ICourseLearningObjective source, ICourseLearningObjective target)
        {
            bool isModified = false;

            var sourceSupport = source as ICourseLearningObjectiveSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.LearningObjectiveId != target.LearningObjectiveId)
            {
                source.LearningObjectiveId = target.LearningObjectiveId;
            }
            if (source.Namespace != target.Namespace)
            {
                source.Namespace = target.Namespace;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ICourseLearningObjective source, ICourseLearningObjective target, Action<ICourseLearningObjective, ICourseLearningObjective> onMapped)
        {
            var sourceSynchSupport = source as ICourseLearningObjectiveSynchronizationSourceSupport;
            var targetSynchSupport = target as ICourseLearningObjectiveSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.LearningObjectiveId = source.LearningObjectiveId;
            target.Namespace = source.Namespace;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ICourseLearningObjectiveSynchronizationSourceSupport
    {
    }
 
    public static class CourseLearningStandardMapper 
    {
        public static bool SynchronizeTo(this ICourseLearningStandard source, ICourseLearningStandard target)
        {
            bool isModified = false;

            var sourceSupport = source as ICourseLearningStandardSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.LearningStandardId != target.LearningStandardId)
            {
                source.LearningStandardId = target.LearningStandardId;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ICourseLearningStandard source, ICourseLearningStandard target, Action<ICourseLearningStandard, ICourseLearningStandard> onMapped)
        {
            var sourceSynchSupport = source as ICourseLearningStandardSynchronizationSourceSupport;
            var targetSynchSupport = target as ICourseLearningStandardSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.LearningStandardId = source.LearningStandardId;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ICourseLearningStandardSynchronizationSourceSupport
    {
    }
 
    public static class CourseLevelCharacteristicMapper 
    {
        public static bool SynchronizeTo(this ICourseLevelCharacteristic source, ICourseLevelCharacteristic target)
        {
            bool isModified = false;

            var sourceSupport = source as ICourseLevelCharacteristicSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.CourseLevelCharacteristicType != target.CourseLevelCharacteristicType)
            {
                source.CourseLevelCharacteristicType = target.CourseLevelCharacteristicType;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ICourseLevelCharacteristic source, ICourseLevelCharacteristic target, Action<ICourseLevelCharacteristic, ICourseLevelCharacteristic> onMapped)
        {
            var sourceSynchSupport = source as ICourseLevelCharacteristicSynchronizationSourceSupport;
            var targetSynchSupport = target as ICourseLevelCharacteristicSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.CourseLevelCharacteristicType = source.CourseLevelCharacteristicType;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ICourseLevelCharacteristicSynchronizationSourceSupport
    {
    }
 
    public static class CourseOfferedGradeLevelMapper 
    {
        public static bool SynchronizeTo(this ICourseOfferedGradeLevel source, ICourseOfferedGradeLevel target)
        {
            bool isModified = false;

            var sourceSupport = source as ICourseOfferedGradeLevelSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.GradeLevelDescriptor != target.GradeLevelDescriptor)
            {
                source.GradeLevelDescriptor = target.GradeLevelDescriptor;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ICourseOfferedGradeLevel source, ICourseOfferedGradeLevel target, Action<ICourseOfferedGradeLevel, ICourseOfferedGradeLevel> onMapped)
        {
            var sourceSynchSupport = source as ICourseOfferedGradeLevelSynchronizationSourceSupport;
            var targetSynchSupport = target as ICourseOfferedGradeLevelSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.GradeLevelDescriptor = source.GradeLevelDescriptor;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ICourseOfferedGradeLevelSynchronizationSourceSupport
    {
    }
 
}
// Aggregate: CourseAttemptResultType

namespace EdFi.Ods.Entities.Common //.CourseAttemptResultTypeAggregate
{ 
    public static class CourseAttemptResultTypeMapper 
    {
        public static bool SynchronizeTo(this ICourseAttemptResultType source, ICourseAttemptResultType target)
        {
            bool isModified = false;

            var sourceSupport = source as ICourseAttemptResultTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.CourseAttemptResultTypeId != target.CourseAttemptResultTypeId)
            {
                source.CourseAttemptResultTypeId = target.CourseAttemptResultTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ICourseAttemptResultType source, ICourseAttemptResultType target, Action<ICourseAttemptResultType, ICourseAttemptResultType> onMapped)
        {
            var sourceSynchSupport = source as ICourseAttemptResultTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as ICourseAttemptResultTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.CourseAttemptResultTypeId = source.CourseAttemptResultTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ICourseAttemptResultTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: CourseDefinedByType

namespace EdFi.Ods.Entities.Common //.CourseDefinedByTypeAggregate
{ 
    public static class CourseDefinedByTypeMapper 
    {
        public static bool SynchronizeTo(this ICourseDefinedByType source, ICourseDefinedByType target)
        {
            bool isModified = false;

            var sourceSupport = source as ICourseDefinedByTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.CourseDefinedByTypeId != target.CourseDefinedByTypeId)
            {
                source.CourseDefinedByTypeId = target.CourseDefinedByTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ICourseDefinedByType source, ICourseDefinedByType target, Action<ICourseDefinedByType, ICourseDefinedByType> onMapped)
        {
            var sourceSynchSupport = source as ICourseDefinedByTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as ICourseDefinedByTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.CourseDefinedByTypeId = source.CourseDefinedByTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ICourseDefinedByTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: CourseGPAApplicabilityType

namespace EdFi.Ods.Entities.Common //.CourseGPAApplicabilityTypeAggregate
{ 
    public static class CourseGPAApplicabilityTypeMapper 
    {
        public static bool SynchronizeTo(this ICourseGPAApplicabilityType source, ICourseGPAApplicabilityType target)
        {
            bool isModified = false;

            var sourceSupport = source as ICourseGPAApplicabilityTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.CourseGPAApplicabilityTypeId != target.CourseGPAApplicabilityTypeId)
            {
                source.CourseGPAApplicabilityTypeId = target.CourseGPAApplicabilityTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ICourseGPAApplicabilityType source, ICourseGPAApplicabilityType target, Action<ICourseGPAApplicabilityType, ICourseGPAApplicabilityType> onMapped)
        {
            var sourceSynchSupport = source as ICourseGPAApplicabilityTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as ICourseGPAApplicabilityTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.CourseGPAApplicabilityTypeId = source.CourseGPAApplicabilityTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ICourseGPAApplicabilityTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: CourseIdentificationSystemDescriptor

namespace EdFi.Ods.Entities.Common //.CourseIdentificationSystemDescriptorAggregate
{ 
    public static class CourseIdentificationSystemDescriptorMapper 
    {
        public static bool SynchronizeTo(this ICourseIdentificationSystemDescriptor source, ICourseIdentificationSystemDescriptor target)
        {
            bool isModified = false;

            var sourceSupport = source as ICourseIdentificationSystemDescriptorSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.CourseIdentificationSystemDescriptorId != target.CourseIdentificationSystemDescriptorId)
            {
                source.CourseIdentificationSystemDescriptorId = target.CourseIdentificationSystemDescriptorId;
            }

            // Copy inherited non-PK properties


            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveBeginDateSupported)
                && target.EffectiveBeginDate != source.EffectiveBeginDate)
            {
                target.EffectiveBeginDate = source.EffectiveBeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveEndDateSupported)
                && target.EffectiveEndDate != source.EffectiveEndDate)
            {
                target.EffectiveEndDate = source.EffectiveEndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNamespaceSupported)
                && target.Namespace != source.Namespace)
            {
                target.Namespace = source.Namespace;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPriorDescriptorIdSupported)
                && target.PriorDescriptorId != source.PriorDescriptorId)
            {
                target.PriorDescriptorId = source.PriorDescriptorId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCourseIdentificationSystemTypeSupported)
                && target.CourseIdentificationSystemType != source.CourseIdentificationSystemType)
            {
                target.CourseIdentificationSystemType = source.CourseIdentificationSystemType;
                isModified = true;
            }

            // Synch inherited lists


            // Sync lists

            return isModified;
        }



        public static void MapTo(this ICourseIdentificationSystemDescriptor source, ICourseIdentificationSystemDescriptor target, Action<ICourseIdentificationSystemDescriptor, ICourseIdentificationSystemDescriptor> onMapped)
        {
            var sourceSynchSupport = source as ICourseIdentificationSystemDescriptorSynchronizationSourceSupport;
            var targetSynchSupport = target as ICourseIdentificationSystemDescriptorSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.CourseIdentificationSystemDescriptorId = source.CourseIdentificationSystemDescriptorId;

            // Copy inherited non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsEffectiveBeginDateSupported)
                target.EffectiveBeginDate = source.EffectiveBeginDate;
            else
                targetSynchSupport.IsEffectiveBeginDateSupported = false;

            if (sourceSynchSupport.IsEffectiveEndDateSupported)
                target.EffectiveEndDate = source.EffectiveEndDate;
            else
                targetSynchSupport.IsEffectiveEndDateSupported = false;

            if (sourceSynchSupport.IsNamespaceSupported)
                target.Namespace = source.Namespace;
            else
                targetSynchSupport.IsNamespaceSupported = false;

            if (sourceSynchSupport.IsPriorDescriptorIdSupported)
                target.PriorDescriptorId = source.PriorDescriptorId;
            else
                targetSynchSupport.IsPriorDescriptorIdSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCourseIdentificationSystemTypeSupported)
                target.CourseIdentificationSystemType = source.CourseIdentificationSystemType;
            else
                targetSynchSupport.IsCourseIdentificationSystemTypeSupported = false;

            // Map inherited lists

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ICourseIdentificationSystemDescriptorSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsCourseIdentificationSystemTypeSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsEffectiveBeginDateSupported { get; set; }
        bool IsEffectiveEndDateSupported { get; set; }
        bool IsNamespaceSupported { get; set; }
        bool IsPriorDescriptorIdSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: CourseIdentificationSystemType

namespace EdFi.Ods.Entities.Common //.CourseIdentificationSystemTypeAggregate
{ 
    public static class CourseIdentificationSystemTypeMapper 
    {
        public static bool SynchronizeTo(this ICourseIdentificationSystemType source, ICourseIdentificationSystemType target)
        {
            bool isModified = false;

            var sourceSupport = source as ICourseIdentificationSystemTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.CourseIdentificationSystemTypeId != target.CourseIdentificationSystemTypeId)
            {
                source.CourseIdentificationSystemTypeId = target.CourseIdentificationSystemTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ICourseIdentificationSystemType source, ICourseIdentificationSystemType target, Action<ICourseIdentificationSystemType, ICourseIdentificationSystemType> onMapped)
        {
            var sourceSynchSupport = source as ICourseIdentificationSystemTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as ICourseIdentificationSystemTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.CourseIdentificationSystemTypeId = source.CourseIdentificationSystemTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ICourseIdentificationSystemTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: CourseLevelCharacteristicType

namespace EdFi.Ods.Entities.Common //.CourseLevelCharacteristicTypeAggregate
{ 
    public static class CourseLevelCharacteristicTypeMapper 
    {
        public static bool SynchronizeTo(this ICourseLevelCharacteristicType source, ICourseLevelCharacteristicType target)
        {
            bool isModified = false;

            var sourceSupport = source as ICourseLevelCharacteristicTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.CourseLevelCharacteristicTypeId != target.CourseLevelCharacteristicTypeId)
            {
                source.CourseLevelCharacteristicTypeId = target.CourseLevelCharacteristicTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ICourseLevelCharacteristicType source, ICourseLevelCharacteristicType target, Action<ICourseLevelCharacteristicType, ICourseLevelCharacteristicType> onMapped)
        {
            var sourceSynchSupport = source as ICourseLevelCharacteristicTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as ICourseLevelCharacteristicTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.CourseLevelCharacteristicTypeId = source.CourseLevelCharacteristicTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ICourseLevelCharacteristicTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: CourseOffering

namespace EdFi.Ods.Entities.Common //.CourseOfferingAggregate
{ 
    public static class CourseOfferingMapper 
    {
        public static bool SynchronizeTo(this ICourseOffering source, ICourseOffering target)
        {
            bool isModified = false;

            var sourceSupport = source as ICourseOfferingSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.LocalCourseCode != target.LocalCourseCode)
            {
                source.LocalCourseCode = target.LocalCourseCode;
            }
            if (source.SchoolId != target.SchoolId)
            {
                source.SchoolId = target.SchoolId;
            }
            if (source.SchoolYear != target.SchoolYear)
            {
                source.SchoolYear = target.SchoolYear;
            }
            if (source.TermDescriptor != target.TermDescriptor)
            {
                source.TermDescriptor = target.TermDescriptor;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCourseCodeSupported)
                && target.CourseCode != source.CourseCode)
            {
                target.CourseCode = source.CourseCode;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEducationOrganizationIdSupported)
                && target.EducationOrganizationId != source.EducationOrganizationId)
            {
                target.EducationOrganizationId = source.EducationOrganizationId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsInstructionalTimePlannedSupported)
                && target.InstructionalTimePlanned != source.InstructionalTimePlanned)
            {
                target.InstructionalTimePlanned = source.InstructionalTimePlanned;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsLocalCourseTitleSupported)
                && target.LocalCourseTitle != source.LocalCourseTitle)
            {
                target.LocalCourseTitle = source.LocalCourseTitle;
                isModified = true;
            }



            // Sync lists
            if (sourceSupport == null || sourceSupport.IsCourseOfferingCurriculumUsedsSupported)
                isModified |= source.CourseOfferingCurriculumUseds.SynchronizeListTo(target.CourseOfferingCurriculumUseds, child => child.CourseOffering = target,
                                sourceSupport == null ? null : sourceSupport.IsCourseOfferingCurriculumUsedIncluded);


            return isModified;
        }



        public static void MapTo(this ICourseOffering source, ICourseOffering target, Action<ICourseOffering, ICourseOffering> onMapped)
        {
            var sourceSynchSupport = source as ICourseOfferingSynchronizationSourceSupport;
            var targetSynchSupport = target as ICourseOfferingSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.LocalCourseCode = source.LocalCourseCode;
            target.SchoolId = source.SchoolId;
            target.SchoolYear = source.SchoolYear;
            target.TermDescriptor = source.TermDescriptor;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCourseCodeSupported)
                target.CourseCode = source.CourseCode;
            else
                targetSynchSupport.IsCourseCodeSupported = false;

            if (sourceSynchSupport.IsEducationOrganizationIdSupported)
                target.EducationOrganizationId = source.EducationOrganizationId;
            else
                targetSynchSupport.IsEducationOrganizationIdSupported = false;

            if (sourceSynchSupport.IsInstructionalTimePlannedSupported)
                target.InstructionalTimePlanned = source.InstructionalTimePlanned;
            else
                targetSynchSupport.IsInstructionalTimePlannedSupported = false;

            if (sourceSynchSupport.IsLocalCourseTitleSupported)
                target.LocalCourseTitle = source.LocalCourseTitle;
            else
                targetSynchSupport.IsLocalCourseTitleSupported = false;

            // Map lists

            if (sourceSynchSupport.IsCourseOfferingCurriculumUsedsSupported)
            {    
                targetSynchSupport.IsCourseOfferingCurriculumUsedIncluded = sourceSynchSupport.IsCourseOfferingCurriculumUsedIncluded;
                source.CourseOfferingCurriculumUseds.MapListTo(target.CourseOfferingCurriculumUseds);
            }
            else
            {
                targetSynchSupport.IsCourseOfferingCurriculumUsedsSupported = false;
            }

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ICourseOfferingSynchronizationSourceSupport
    {
        bool IsCourseCodeSupported { get; set; }
        bool IsCourseOfferingCurriculumUsedsSupported { get; set; }
        bool IsEducationOrganizationIdSupported { get; set; }
        bool IsInstructionalTimePlannedSupported { get; set; }
        bool IsLocalCourseTitleSupported { get; set; }
        Func<ICourseOfferingCurriculumUsed, bool> IsCourseOfferingCurriculumUsedIncluded { get; set; }
    }
 
    public static class CourseOfferingCurriculumUsedMapper 
    {
        public static bool SynchronizeTo(this ICourseOfferingCurriculumUsed source, ICourseOfferingCurriculumUsed target)
        {
            bool isModified = false;

            var sourceSupport = source as ICourseOfferingCurriculumUsedSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.CurriculumUsedType != target.CurriculumUsedType)
            {
                source.CurriculumUsedType = target.CurriculumUsedType;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ICourseOfferingCurriculumUsed source, ICourseOfferingCurriculumUsed target, Action<ICourseOfferingCurriculumUsed, ICourseOfferingCurriculumUsed> onMapped)
        {
            var sourceSynchSupport = source as ICourseOfferingCurriculumUsedSynchronizationSourceSupport;
            var targetSynchSupport = target as ICourseOfferingCurriculumUsedSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.CurriculumUsedType = source.CurriculumUsedType;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ICourseOfferingCurriculumUsedSynchronizationSourceSupport
    {
    }
 
}
// Aggregate: CourseRepeatCodeType

namespace EdFi.Ods.Entities.Common //.CourseRepeatCodeTypeAggregate
{ 
    public static class CourseRepeatCodeTypeMapper 
    {
        public static bool SynchronizeTo(this ICourseRepeatCodeType source, ICourseRepeatCodeType target)
        {
            bool isModified = false;

            var sourceSupport = source as ICourseRepeatCodeTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.CourseRepeatCodeTypeId != target.CourseRepeatCodeTypeId)
            {
                source.CourseRepeatCodeTypeId = target.CourseRepeatCodeTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ICourseRepeatCodeType source, ICourseRepeatCodeType target, Action<ICourseRepeatCodeType, ICourseRepeatCodeType> onMapped)
        {
            var sourceSynchSupport = source as ICourseRepeatCodeTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as ICourseRepeatCodeTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.CourseRepeatCodeTypeId = source.CourseRepeatCodeTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ICourseRepeatCodeTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: CourseTranscript

namespace EdFi.Ods.Entities.Common //.CourseTranscriptAggregate
{ 
    public static class CourseTranscriptMapper 
    {
        public static bool SynchronizeTo(this ICourseTranscript source, ICourseTranscript target)
        {
            bool isModified = false;

            var sourceSupport = source as ICourseTranscriptSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.CourseAttemptResultType != target.CourseAttemptResultType)
            {
                source.CourseAttemptResultType = target.CourseAttemptResultType;
            }
            if (source.CourseCode != target.CourseCode)
            {
                source.CourseCode = target.CourseCode;
            }
            if (source.CourseEducationOrganizationId != target.CourseEducationOrganizationId)
            {
                source.CourseEducationOrganizationId = target.CourseEducationOrganizationId;
            }
            if (source.EducationOrganizationId != target.EducationOrganizationId)
            {
                source.EducationOrganizationId = target.EducationOrganizationId;
            }
            if (source.SchoolYear != target.SchoolYear)
            {
                source.SchoolYear = target.SchoolYear;
            }
            if (source.StudentUniqueId != target.StudentUniqueId)
            {
                source.StudentUniqueId = target.StudentUniqueId;
            }
            if (source.TermDescriptor != target.TermDescriptor)
            {
                source.TermDescriptor = target.TermDescriptor;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsAlternativeCourseCodeSupported)
                && target.AlternativeCourseCode != source.AlternativeCourseCode)
            {
                target.AlternativeCourseCode = source.AlternativeCourseCode;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsAlternativeCourseTitleSupported)
                && target.AlternativeCourseTitle != source.AlternativeCourseTitle)
            {
                target.AlternativeCourseTitle = source.AlternativeCourseTitle;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsAttemptedCreditConversionSupported)
                && target.AttemptedCreditConversion != source.AttemptedCreditConversion)
            {
                target.AttemptedCreditConversion = source.AttemptedCreditConversion;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsAttemptedCreditsSupported)
                && target.AttemptedCredits != source.AttemptedCredits)
            {
                target.AttemptedCredits = source.AttemptedCredits;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsAttemptedCreditTypeSupported)
                && target.AttemptedCreditType != source.AttemptedCreditType)
            {
                target.AttemptedCreditType = source.AttemptedCreditType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsCourseRepeatCodeTypeSupported)
                && target.CourseRepeatCodeType != source.CourseRepeatCodeType)
            {
                target.CourseRepeatCodeType = source.CourseRepeatCodeType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsCourseTitleSupported)
                && target.CourseTitle != source.CourseTitle)
            {
                target.CourseTitle = source.CourseTitle;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEarnedCreditConversionSupported)
                && target.EarnedCreditConversion != source.EarnedCreditConversion)
            {
                target.EarnedCreditConversion = source.EarnedCreditConversion;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEarnedCreditsSupported)
                && target.EarnedCredits != source.EarnedCredits)
            {
                target.EarnedCredits = source.EarnedCredits;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEarnedCreditTypeSupported)
                && target.EarnedCreditType != source.EarnedCreditType)
            {
                target.EarnedCreditType = source.EarnedCreditType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsFinalLetterGradeEarnedSupported)
                && target.FinalLetterGradeEarned != source.FinalLetterGradeEarned)
            {
                target.FinalLetterGradeEarned = source.FinalLetterGradeEarned;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsFinalNumericGradeEarnedSupported)
                && target.FinalNumericGradeEarned != source.FinalNumericGradeEarned)
            {
                target.FinalNumericGradeEarned = source.FinalNumericGradeEarned;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsMethodCreditEarnedTypeSupported)
                && target.MethodCreditEarnedType != source.MethodCreditEarnedType)
            {
                target.MethodCreditEarnedType = source.MethodCreditEarnedType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsSchoolIdSupported)
                && target.SchoolId != source.SchoolId)
            {
                target.SchoolId = source.SchoolId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsWhenTakenGradeLevelDescriptorSupported)
                && target.WhenTakenGradeLevelDescriptor != source.WhenTakenGradeLevelDescriptor)
            {
                target.WhenTakenGradeLevelDescriptor = source.WhenTakenGradeLevelDescriptor;
                isModified = true;
            }



            // Sync lists
            if (sourceSupport == null || sourceSupport.IsCourseTranscriptEarnedAdditionalCreditsSupported)
                isModified |= source.CourseTranscriptEarnedAdditionalCredits.SynchronizeListTo(target.CourseTranscriptEarnedAdditionalCredits, child => child.CourseTranscript = target,
                                sourceSupport == null ? null : sourceSupport.IsCourseTranscriptEarnedAdditionalCreditsIncluded);


            return isModified;
        }



        public static void MapTo(this ICourseTranscript source, ICourseTranscript target, Action<ICourseTranscript, ICourseTranscript> onMapped)
        {
            var sourceSynchSupport = source as ICourseTranscriptSynchronizationSourceSupport;
            var targetSynchSupport = target as ICourseTranscriptSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.CourseAttemptResultType = source.CourseAttemptResultType;
            target.CourseCode = source.CourseCode;
            target.CourseEducationOrganizationId = source.CourseEducationOrganizationId;
            target.EducationOrganizationId = source.EducationOrganizationId;
            target.SchoolYear = source.SchoolYear;
            target.StudentUniqueId = source.StudentUniqueId;
            target.TermDescriptor = source.TermDescriptor;

            // Copy non-PK properties

            if (sourceSynchSupport.IsAlternativeCourseCodeSupported)
                target.AlternativeCourseCode = source.AlternativeCourseCode;
            else
                targetSynchSupport.IsAlternativeCourseCodeSupported = false;

            if (sourceSynchSupport.IsAlternativeCourseTitleSupported)
                target.AlternativeCourseTitle = source.AlternativeCourseTitle;
            else
                targetSynchSupport.IsAlternativeCourseTitleSupported = false;

            if (sourceSynchSupport.IsAttemptedCreditConversionSupported)
                target.AttemptedCreditConversion = source.AttemptedCreditConversion;
            else
                targetSynchSupport.IsAttemptedCreditConversionSupported = false;

            if (sourceSynchSupport.IsAttemptedCreditsSupported)
                target.AttemptedCredits = source.AttemptedCredits;
            else
                targetSynchSupport.IsAttemptedCreditsSupported = false;

            if (sourceSynchSupport.IsAttemptedCreditTypeSupported)
                target.AttemptedCreditType = source.AttemptedCreditType;
            else
                targetSynchSupport.IsAttemptedCreditTypeSupported = false;

            if (sourceSynchSupport.IsCourseRepeatCodeTypeSupported)
                target.CourseRepeatCodeType = source.CourseRepeatCodeType;
            else
                targetSynchSupport.IsCourseRepeatCodeTypeSupported = false;

            if (sourceSynchSupport.IsCourseTitleSupported)
                target.CourseTitle = source.CourseTitle;
            else
                targetSynchSupport.IsCourseTitleSupported = false;

            if (sourceSynchSupport.IsEarnedCreditConversionSupported)
                target.EarnedCreditConversion = source.EarnedCreditConversion;
            else
                targetSynchSupport.IsEarnedCreditConversionSupported = false;

            if (sourceSynchSupport.IsEarnedCreditsSupported)
                target.EarnedCredits = source.EarnedCredits;
            else
                targetSynchSupport.IsEarnedCreditsSupported = false;

            if (sourceSynchSupport.IsEarnedCreditTypeSupported)
                target.EarnedCreditType = source.EarnedCreditType;
            else
                targetSynchSupport.IsEarnedCreditTypeSupported = false;

            if (sourceSynchSupport.IsFinalLetterGradeEarnedSupported)
                target.FinalLetterGradeEarned = source.FinalLetterGradeEarned;
            else
                targetSynchSupport.IsFinalLetterGradeEarnedSupported = false;

            if (sourceSynchSupport.IsFinalNumericGradeEarnedSupported)
                target.FinalNumericGradeEarned = source.FinalNumericGradeEarned;
            else
                targetSynchSupport.IsFinalNumericGradeEarnedSupported = false;

            if (sourceSynchSupport.IsMethodCreditEarnedTypeSupported)
                target.MethodCreditEarnedType = source.MethodCreditEarnedType;
            else
                targetSynchSupport.IsMethodCreditEarnedTypeSupported = false;

            if (sourceSynchSupport.IsSchoolIdSupported)
                target.SchoolId = source.SchoolId;
            else
                targetSynchSupport.IsSchoolIdSupported = false;

            if (sourceSynchSupport.IsWhenTakenGradeLevelDescriptorSupported)
                target.WhenTakenGradeLevelDescriptor = source.WhenTakenGradeLevelDescriptor;
            else
                targetSynchSupport.IsWhenTakenGradeLevelDescriptorSupported = false;

            // Map lists

            if (sourceSynchSupport.IsCourseTranscriptEarnedAdditionalCreditsSupported)
            {    
                targetSynchSupport.IsCourseTranscriptEarnedAdditionalCreditsIncluded = sourceSynchSupport.IsCourseTranscriptEarnedAdditionalCreditsIncluded;
                source.CourseTranscriptEarnedAdditionalCredits.MapListTo(target.CourseTranscriptEarnedAdditionalCredits);
            }
            else
            {
                targetSynchSupport.IsCourseTranscriptEarnedAdditionalCreditsSupported = false;
            }

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ICourseTranscriptSynchronizationSourceSupport
    {
        bool IsAlternativeCourseCodeSupported { get; set; }
        bool IsAlternativeCourseTitleSupported { get; set; }
        bool IsAttemptedCreditConversionSupported { get; set; }
        bool IsAttemptedCreditsSupported { get; set; }
        bool IsAttemptedCreditTypeSupported { get; set; }
        bool IsCourseRepeatCodeTypeSupported { get; set; }
        bool IsCourseTitleSupported { get; set; }
        bool IsCourseTranscriptEarnedAdditionalCreditsSupported { get; set; }
        bool IsEarnedCreditConversionSupported { get; set; }
        bool IsEarnedCreditsSupported { get; set; }
        bool IsEarnedCreditTypeSupported { get; set; }
        bool IsFinalLetterGradeEarnedSupported { get; set; }
        bool IsFinalNumericGradeEarnedSupported { get; set; }
        bool IsMethodCreditEarnedTypeSupported { get; set; }
        bool IsSchoolIdSupported { get; set; }
        bool IsWhenTakenGradeLevelDescriptorSupported { get; set; }
        Func<ICourseTranscriptEarnedAdditionalCredits, bool> IsCourseTranscriptEarnedAdditionalCreditsIncluded { get; set; }
    }
 
    public static class CourseTranscriptEarnedAdditionalCreditsMapper 
    {
        public static bool SynchronizeTo(this ICourseTranscriptEarnedAdditionalCredits source, ICourseTranscriptEarnedAdditionalCredits target)
        {
            bool isModified = false;

            var sourceSupport = source as ICourseTranscriptEarnedAdditionalCreditsSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AdditionalCreditType != target.AdditionalCreditType)
            {
                source.AdditionalCreditType = target.AdditionalCreditType;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCreditsSupported)
                && target.Credits != source.Credits)
            {
                target.Credits = source.Credits;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ICourseTranscriptEarnedAdditionalCredits source, ICourseTranscriptEarnedAdditionalCredits target, Action<ICourseTranscriptEarnedAdditionalCredits, ICourseTranscriptEarnedAdditionalCredits> onMapped)
        {
            var sourceSynchSupport = source as ICourseTranscriptEarnedAdditionalCreditsSynchronizationSourceSupport;
            var targetSynchSupport = target as ICourseTranscriptEarnedAdditionalCreditsSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.AdditionalCreditType = source.AdditionalCreditType;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCreditsSupported)
                target.Credits = source.Credits;
            else
                targetSynchSupport.IsCreditsSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ICourseTranscriptEarnedAdditionalCreditsSynchronizationSourceSupport
    {
        bool IsCreditsSupported { get; set; }
    }
 
}
// Aggregate: CredentialFieldDescriptor

namespace EdFi.Ods.Entities.Common //.CredentialFieldDescriptorAggregate
{ 
    public static class CredentialFieldDescriptorMapper 
    {
        public static bool SynchronizeTo(this ICredentialFieldDescriptor source, ICredentialFieldDescriptor target)
        {
            bool isModified = false;

            var sourceSupport = source as ICredentialFieldDescriptorSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.CredentialFieldDescriptorId != target.CredentialFieldDescriptorId)
            {
                source.CredentialFieldDescriptorId = target.CredentialFieldDescriptorId;
            }

            // Copy inherited non-PK properties


            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveBeginDateSupported)
                && target.EffectiveBeginDate != source.EffectiveBeginDate)
            {
                target.EffectiveBeginDate = source.EffectiveBeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveEndDateSupported)
                && target.EffectiveEndDate != source.EffectiveEndDate)
            {
                target.EffectiveEndDate = source.EffectiveEndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNamespaceSupported)
                && target.Namespace != source.Namespace)
            {
                target.Namespace = source.Namespace;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPriorDescriptorIdSupported)
                && target.PriorDescriptorId != source.PriorDescriptorId)
            {
                target.PriorDescriptorId = source.PriorDescriptorId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsAcademicSubjectDescriptorSupported)
                && target.AcademicSubjectDescriptor != source.AcademicSubjectDescriptor)
            {
                target.AcademicSubjectDescriptor = source.AcademicSubjectDescriptor;
                isModified = true;
            }

            // Synch inherited lists


            // Sync lists

            return isModified;
        }



        public static void MapTo(this ICredentialFieldDescriptor source, ICredentialFieldDescriptor target, Action<ICredentialFieldDescriptor, ICredentialFieldDescriptor> onMapped)
        {
            var sourceSynchSupport = source as ICredentialFieldDescriptorSynchronizationSourceSupport;
            var targetSynchSupport = target as ICredentialFieldDescriptorSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.CredentialFieldDescriptorId = source.CredentialFieldDescriptorId;

            // Copy inherited non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsEffectiveBeginDateSupported)
                target.EffectiveBeginDate = source.EffectiveBeginDate;
            else
                targetSynchSupport.IsEffectiveBeginDateSupported = false;

            if (sourceSynchSupport.IsEffectiveEndDateSupported)
                target.EffectiveEndDate = source.EffectiveEndDate;
            else
                targetSynchSupport.IsEffectiveEndDateSupported = false;

            if (sourceSynchSupport.IsNamespaceSupported)
                target.Namespace = source.Namespace;
            else
                targetSynchSupport.IsNamespaceSupported = false;

            if (sourceSynchSupport.IsPriorDescriptorIdSupported)
                target.PriorDescriptorId = source.PriorDescriptorId;
            else
                targetSynchSupport.IsPriorDescriptorIdSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Copy non-PK properties

            if (sourceSynchSupport.IsAcademicSubjectDescriptorSupported)
                target.AcademicSubjectDescriptor = source.AcademicSubjectDescriptor;
            else
                targetSynchSupport.IsAcademicSubjectDescriptorSupported = false;

            // Map inherited lists

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ICredentialFieldDescriptorSynchronizationSourceSupport
    {
        bool IsAcademicSubjectDescriptorSupported { get; set; }
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsEffectiveBeginDateSupported { get; set; }
        bool IsEffectiveEndDateSupported { get; set; }
        bool IsNamespaceSupported { get; set; }
        bool IsPriorDescriptorIdSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: CredentialType

namespace EdFi.Ods.Entities.Common //.CredentialTypeAggregate
{ 
    public static class CredentialTypeMapper 
    {
        public static bool SynchronizeTo(this ICredentialType source, ICredentialType target)
        {
            bool isModified = false;

            var sourceSupport = source as ICredentialTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.CredentialTypeId != target.CredentialTypeId)
            {
                source.CredentialTypeId = target.CredentialTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ICredentialType source, ICredentialType target, Action<ICredentialType, ICredentialType> onMapped)
        {
            var sourceSynchSupport = source as ICredentialTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as ICredentialTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.CredentialTypeId = source.CredentialTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ICredentialTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: CreditType

namespace EdFi.Ods.Entities.Common //.CreditTypeAggregate
{ 
    public static class CreditTypeMapper 
    {
        public static bool SynchronizeTo(this ICreditType source, ICreditType target)
        {
            bool isModified = false;

            var sourceSupport = source as ICreditTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.CreditTypeId != target.CreditTypeId)
            {
                source.CreditTypeId = target.CreditTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ICreditType source, ICreditType target, Action<ICreditType, ICreditType> onMapped)
        {
            var sourceSynchSupport = source as ICreditTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as ICreditTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.CreditTypeId = source.CreditTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ICreditTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: CurriculumUsedType

namespace EdFi.Ods.Entities.Common //.CurriculumUsedTypeAggregate
{ 
    public static class CurriculumUsedTypeMapper 
    {
        public static bool SynchronizeTo(this ICurriculumUsedType source, ICurriculumUsedType target)
        {
            bool isModified = false;

            var sourceSupport = source as ICurriculumUsedTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.CurriculumUsedTypeId != target.CurriculumUsedTypeId)
            {
                source.CurriculumUsedTypeId = target.CurriculumUsedTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ICurriculumUsedType source, ICurriculumUsedType target, Action<ICurriculumUsedType, ICurriculumUsedType> onMapped)
        {
            var sourceSynchSupport = source as ICurriculumUsedTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as ICurriculumUsedTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.CurriculumUsedTypeId = source.CurriculumUsedTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ICurriculumUsedTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: DeliveryMethodType

namespace EdFi.Ods.Entities.Common //.DeliveryMethodTypeAggregate
{ 
    public static class DeliveryMethodTypeMapper 
    {
        public static bool SynchronizeTo(this IDeliveryMethodType source, IDeliveryMethodType target)
        {
            bool isModified = false;

            var sourceSupport = source as IDeliveryMethodTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.DeliveryMethodTypeId != target.DeliveryMethodTypeId)
            {
                source.DeliveryMethodTypeId = target.DeliveryMethodTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IDeliveryMethodType source, IDeliveryMethodType target, Action<IDeliveryMethodType, IDeliveryMethodType> onMapped)
        {
            var sourceSynchSupport = source as IDeliveryMethodTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IDeliveryMethodTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.DeliveryMethodTypeId = source.DeliveryMethodTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IDeliveryMethodTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: DiagnosisDescriptor

namespace EdFi.Ods.Entities.Common //.DiagnosisDescriptorAggregate
{ 
    public static class DiagnosisDescriptorMapper 
    {
        public static bool SynchronizeTo(this IDiagnosisDescriptor source, IDiagnosisDescriptor target)
        {
            bool isModified = false;

            var sourceSupport = source as IDiagnosisDescriptorSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.DiagnosisDescriptorId != target.DiagnosisDescriptorId)
            {
                source.DiagnosisDescriptorId = target.DiagnosisDescriptorId;
            }

            // Copy inherited non-PK properties


            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveBeginDateSupported)
                && target.EffectiveBeginDate != source.EffectiveBeginDate)
            {
                target.EffectiveBeginDate = source.EffectiveBeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveEndDateSupported)
                && target.EffectiveEndDate != source.EffectiveEndDate)
            {
                target.EffectiveEndDate = source.EffectiveEndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNamespaceSupported)
                && target.Namespace != source.Namespace)
            {
                target.Namespace = source.Namespace;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPriorDescriptorIdSupported)
                && target.PriorDescriptorId != source.PriorDescriptorId)
            {
                target.PriorDescriptorId = source.PriorDescriptorId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsDiagnosisTypeSupported)
                && target.DiagnosisType != source.DiagnosisType)
            {
                target.DiagnosisType = source.DiagnosisType;
                isModified = true;
            }

            // Synch inherited lists


            // Sync lists

            return isModified;
        }



        public static void MapTo(this IDiagnosisDescriptor source, IDiagnosisDescriptor target, Action<IDiagnosisDescriptor, IDiagnosisDescriptor> onMapped)
        {
            var sourceSynchSupport = source as IDiagnosisDescriptorSynchronizationSourceSupport;
            var targetSynchSupport = target as IDiagnosisDescriptorSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.DiagnosisDescriptorId = source.DiagnosisDescriptorId;

            // Copy inherited non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsEffectiveBeginDateSupported)
                target.EffectiveBeginDate = source.EffectiveBeginDate;
            else
                targetSynchSupport.IsEffectiveBeginDateSupported = false;

            if (sourceSynchSupport.IsEffectiveEndDateSupported)
                target.EffectiveEndDate = source.EffectiveEndDate;
            else
                targetSynchSupport.IsEffectiveEndDateSupported = false;

            if (sourceSynchSupport.IsNamespaceSupported)
                target.Namespace = source.Namespace;
            else
                targetSynchSupport.IsNamespaceSupported = false;

            if (sourceSynchSupport.IsPriorDescriptorIdSupported)
                target.PriorDescriptorId = source.PriorDescriptorId;
            else
                targetSynchSupport.IsPriorDescriptorIdSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Copy non-PK properties

            if (sourceSynchSupport.IsDiagnosisTypeSupported)
                target.DiagnosisType = source.DiagnosisType;
            else
                targetSynchSupport.IsDiagnosisTypeSupported = false;

            // Map inherited lists

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IDiagnosisDescriptorSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsDiagnosisTypeSupported { get; set; }
        bool IsEffectiveBeginDateSupported { get; set; }
        bool IsEffectiveEndDateSupported { get; set; }
        bool IsNamespaceSupported { get; set; }
        bool IsPriorDescriptorIdSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: DiagnosisType

namespace EdFi.Ods.Entities.Common //.DiagnosisTypeAggregate
{ 
    public static class DiagnosisTypeMapper 
    {
        public static bool SynchronizeTo(this IDiagnosisType source, IDiagnosisType target)
        {
            bool isModified = false;

            var sourceSupport = source as IDiagnosisTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.DiagnosisTypeId != target.DiagnosisTypeId)
            {
                source.DiagnosisTypeId = target.DiagnosisTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IDiagnosisType source, IDiagnosisType target, Action<IDiagnosisType, IDiagnosisType> onMapped)
        {
            var sourceSynchSupport = source as IDiagnosisTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IDiagnosisTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.DiagnosisTypeId = source.DiagnosisTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IDiagnosisTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: DiplomaLevelType

namespace EdFi.Ods.Entities.Common //.DiplomaLevelTypeAggregate
{ 
    public static class DiplomaLevelTypeMapper 
    {
        public static bool SynchronizeTo(this IDiplomaLevelType source, IDiplomaLevelType target)
        {
            bool isModified = false;

            var sourceSupport = source as IDiplomaLevelTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.DiplomaLevelTypeId != target.DiplomaLevelTypeId)
            {
                source.DiplomaLevelTypeId = target.DiplomaLevelTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IDiplomaLevelType source, IDiplomaLevelType target, Action<IDiplomaLevelType, IDiplomaLevelType> onMapped)
        {
            var sourceSynchSupport = source as IDiplomaLevelTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IDiplomaLevelTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.DiplomaLevelTypeId = source.DiplomaLevelTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IDiplomaLevelTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: DiplomaType

namespace EdFi.Ods.Entities.Common //.DiplomaTypeAggregate
{ 
    public static class DiplomaTypeMapper 
    {
        public static bool SynchronizeTo(this IDiplomaType source, IDiplomaType target)
        {
            bool isModified = false;

            var sourceSupport = source as IDiplomaTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.DiplomaTypeId != target.DiplomaTypeId)
            {
                source.DiplomaTypeId = target.DiplomaTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IDiplomaType source, IDiplomaType target, Action<IDiplomaType, IDiplomaType> onMapped)
        {
            var sourceSynchSupport = source as IDiplomaTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IDiplomaTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.DiplomaTypeId = source.DiplomaTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IDiplomaTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: DisabilityCategoryType

namespace EdFi.Ods.Entities.Common //.DisabilityCategoryTypeAggregate
{ 
    public static class DisabilityCategoryTypeMapper 
    {
        public static bool SynchronizeTo(this IDisabilityCategoryType source, IDisabilityCategoryType target)
        {
            bool isModified = false;

            var sourceSupport = source as IDisabilityCategoryTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.DisabilityCategoryTypeId != target.DisabilityCategoryTypeId)
            {
                source.DisabilityCategoryTypeId = target.DisabilityCategoryTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IDisabilityCategoryType source, IDisabilityCategoryType target, Action<IDisabilityCategoryType, IDisabilityCategoryType> onMapped)
        {
            var sourceSynchSupport = source as IDisabilityCategoryTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IDisabilityCategoryTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.DisabilityCategoryTypeId = source.DisabilityCategoryTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IDisabilityCategoryTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: DisabilityDescriptor

namespace EdFi.Ods.Entities.Common //.DisabilityDescriptorAggregate
{ 
    public static class DisabilityDescriptorMapper 
    {
        public static bool SynchronizeTo(this IDisabilityDescriptor source, IDisabilityDescriptor target)
        {
            bool isModified = false;

            var sourceSupport = source as IDisabilityDescriptorSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.DisabilityDescriptorId != target.DisabilityDescriptorId)
            {
                source.DisabilityDescriptorId = target.DisabilityDescriptorId;
            }

            // Copy inherited non-PK properties


            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveBeginDateSupported)
                && target.EffectiveBeginDate != source.EffectiveBeginDate)
            {
                target.EffectiveBeginDate = source.EffectiveBeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveEndDateSupported)
                && target.EffectiveEndDate != source.EffectiveEndDate)
            {
                target.EffectiveEndDate = source.EffectiveEndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNamespaceSupported)
                && target.Namespace != source.Namespace)
            {
                target.Namespace = source.Namespace;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPriorDescriptorIdSupported)
                && target.PriorDescriptorId != source.PriorDescriptorId)
            {
                target.PriorDescriptorId = source.PriorDescriptorId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsDisabilityCategoryTypeSupported)
                && target.DisabilityCategoryType != source.DisabilityCategoryType)
            {
                target.DisabilityCategoryType = source.DisabilityCategoryType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDisabilityTypeSupported)
                && target.DisabilityType != source.DisabilityType)
            {
                target.DisabilityType = source.DisabilityType;
                isModified = true;
            }

            // Synch inherited lists


            // Sync lists

            return isModified;
        }



        public static void MapTo(this IDisabilityDescriptor source, IDisabilityDescriptor target, Action<IDisabilityDescriptor, IDisabilityDescriptor> onMapped)
        {
            var sourceSynchSupport = source as IDisabilityDescriptorSynchronizationSourceSupport;
            var targetSynchSupport = target as IDisabilityDescriptorSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.DisabilityDescriptorId = source.DisabilityDescriptorId;

            // Copy inherited non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsEffectiveBeginDateSupported)
                target.EffectiveBeginDate = source.EffectiveBeginDate;
            else
                targetSynchSupport.IsEffectiveBeginDateSupported = false;

            if (sourceSynchSupport.IsEffectiveEndDateSupported)
                target.EffectiveEndDate = source.EffectiveEndDate;
            else
                targetSynchSupport.IsEffectiveEndDateSupported = false;

            if (sourceSynchSupport.IsNamespaceSupported)
                target.Namespace = source.Namespace;
            else
                targetSynchSupport.IsNamespaceSupported = false;

            if (sourceSynchSupport.IsPriorDescriptorIdSupported)
                target.PriorDescriptorId = source.PriorDescriptorId;
            else
                targetSynchSupport.IsPriorDescriptorIdSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Copy non-PK properties

            if (sourceSynchSupport.IsDisabilityCategoryTypeSupported)
                target.DisabilityCategoryType = source.DisabilityCategoryType;
            else
                targetSynchSupport.IsDisabilityCategoryTypeSupported = false;

            if (sourceSynchSupport.IsDisabilityTypeSupported)
                target.DisabilityType = source.DisabilityType;
            else
                targetSynchSupport.IsDisabilityTypeSupported = false;

            // Map inherited lists

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IDisabilityDescriptorSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsDisabilityCategoryTypeSupported { get; set; }
        bool IsDisabilityTypeSupported { get; set; }
        bool IsEffectiveBeginDateSupported { get; set; }
        bool IsEffectiveEndDateSupported { get; set; }
        bool IsNamespaceSupported { get; set; }
        bool IsPriorDescriptorIdSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: DisabilityDeterminationSourceType

namespace EdFi.Ods.Entities.Common //.DisabilityDeterminationSourceTypeAggregate
{ 
    public static class DisabilityDeterminationSourceTypeMapper 
    {
        public static bool SynchronizeTo(this IDisabilityDeterminationSourceType source, IDisabilityDeterminationSourceType target)
        {
            bool isModified = false;

            var sourceSupport = source as IDisabilityDeterminationSourceTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.DisabilityDeterminationSourceTypeId != target.DisabilityDeterminationSourceTypeId)
            {
                source.DisabilityDeterminationSourceTypeId = target.DisabilityDeterminationSourceTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IDisabilityDeterminationSourceType source, IDisabilityDeterminationSourceType target, Action<IDisabilityDeterminationSourceType, IDisabilityDeterminationSourceType> onMapped)
        {
            var sourceSynchSupport = source as IDisabilityDeterminationSourceTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IDisabilityDeterminationSourceTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.DisabilityDeterminationSourceTypeId = source.DisabilityDeterminationSourceTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IDisabilityDeterminationSourceTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: DisabilityType

namespace EdFi.Ods.Entities.Common //.DisabilityTypeAggregate
{ 
    public static class DisabilityTypeMapper 
    {
        public static bool SynchronizeTo(this IDisabilityType source, IDisabilityType target)
        {
            bool isModified = false;

            var sourceSupport = source as IDisabilityTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.DisabilityTypeId != target.DisabilityTypeId)
            {
                source.DisabilityTypeId = target.DisabilityTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IDisabilityType source, IDisabilityType target, Action<IDisabilityType, IDisabilityType> onMapped)
        {
            var sourceSynchSupport = source as IDisabilityTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IDisabilityTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.DisabilityTypeId = source.DisabilityTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IDisabilityTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: DisciplineAction

namespace EdFi.Ods.Entities.Common //.DisciplineActionAggregate
{ 
    public static class DisciplineActionMapper 
    {
        public static bool SynchronizeTo(this IDisciplineAction source, IDisciplineAction target)
        {
            bool isModified = false;

            var sourceSupport = source as IDisciplineActionSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.DisciplineActionIdentifier != target.DisciplineActionIdentifier)
            {
                source.DisciplineActionIdentifier = target.DisciplineActionIdentifier;
            }
            if (source.DisciplineDate != target.DisciplineDate)
            {
                source.DisciplineDate = target.DisciplineDate;
            }
            if (source.StudentUniqueId != target.StudentUniqueId)
            {
                source.StudentUniqueId = target.StudentUniqueId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsActualDisciplineActionLengthSupported)
                && target.ActualDisciplineActionLength != source.ActualDisciplineActionLength)
            {
                target.ActualDisciplineActionLength = source.ActualDisciplineActionLength;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsAssignmentSchoolIdSupported)
                && target.AssignmentSchoolId != source.AssignmentSchoolId)
            {
                target.AssignmentSchoolId = source.AssignmentSchoolId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDisciplineActionLengthSupported)
                && target.DisciplineActionLength != source.DisciplineActionLength)
            {
                target.DisciplineActionLength = source.DisciplineActionLength;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDisciplineActionLengthDifferenceReasonTypeSupported)
                && target.DisciplineActionLengthDifferenceReasonType != source.DisciplineActionLengthDifferenceReasonType)
            {
                target.DisciplineActionLengthDifferenceReasonType = source.DisciplineActionLengthDifferenceReasonType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsRelatedToZeroTolerancePolicySupported)
                && target.RelatedToZeroTolerancePolicy != source.RelatedToZeroTolerancePolicy)
            {
                target.RelatedToZeroTolerancePolicy = source.RelatedToZeroTolerancePolicy;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsResponsibilitySchoolIdSupported)
                && target.ResponsibilitySchoolId != source.ResponsibilitySchoolId)
            {
                target.ResponsibilitySchoolId = source.ResponsibilitySchoolId;
                isModified = true;
            }



            // Sync lists
            if (sourceSupport == null || sourceSupport.IsDisciplineActionDisciplinesSupported)
                isModified |= source.DisciplineActionDisciplines.SynchronizeListTo(target.DisciplineActionDisciplines, child => child.DisciplineAction = target,
                                sourceSupport == null ? null : sourceSupport.IsDisciplineActionDisciplineIncluded);

            if (sourceSupport == null || sourceSupport.IsDisciplineActionDisciplineIncidentsSupported)
                isModified |= source.DisciplineActionDisciplineIncidents.SynchronizeListTo(target.DisciplineActionDisciplineIncidents, child => child.DisciplineAction = target,
                                sourceSupport == null ? null : sourceSupport.IsDisciplineActionDisciplineIncidentIncluded);

            if (sourceSupport == null || sourceSupport.IsDisciplineActionStaffsSupported)
                isModified |= source.DisciplineActionStaffs.SynchronizeListTo(target.DisciplineActionStaffs, child => child.DisciplineAction = target,
                                sourceSupport == null ? null : sourceSupport.IsDisciplineActionStaffIncluded);


            return isModified;
        }



        public static void MapTo(this IDisciplineAction source, IDisciplineAction target, Action<IDisciplineAction, IDisciplineAction> onMapped)
        {
            var sourceSynchSupport = source as IDisciplineActionSynchronizationSourceSupport;
            var targetSynchSupport = target as IDisciplineActionSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.DisciplineActionIdentifier = source.DisciplineActionIdentifier;
            target.DisciplineDate = source.DisciplineDate;
            target.StudentUniqueId = source.StudentUniqueId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsActualDisciplineActionLengthSupported)
                target.ActualDisciplineActionLength = source.ActualDisciplineActionLength;
            else
                targetSynchSupport.IsActualDisciplineActionLengthSupported = false;

            if (sourceSynchSupport.IsAssignmentSchoolIdSupported)
                target.AssignmentSchoolId = source.AssignmentSchoolId;
            else
                targetSynchSupport.IsAssignmentSchoolIdSupported = false;

            if (sourceSynchSupport.IsDisciplineActionLengthSupported)
                target.DisciplineActionLength = source.DisciplineActionLength;
            else
                targetSynchSupport.IsDisciplineActionLengthSupported = false;

            if (sourceSynchSupport.IsDisciplineActionLengthDifferenceReasonTypeSupported)
                target.DisciplineActionLengthDifferenceReasonType = source.DisciplineActionLengthDifferenceReasonType;
            else
                targetSynchSupport.IsDisciplineActionLengthDifferenceReasonTypeSupported = false;

            if (sourceSynchSupport.IsRelatedToZeroTolerancePolicySupported)
                target.RelatedToZeroTolerancePolicy = source.RelatedToZeroTolerancePolicy;
            else
                targetSynchSupport.IsRelatedToZeroTolerancePolicySupported = false;

            if (sourceSynchSupport.IsResponsibilitySchoolIdSupported)
                target.ResponsibilitySchoolId = source.ResponsibilitySchoolId;
            else
                targetSynchSupport.IsResponsibilitySchoolIdSupported = false;

            // Map lists

            if (sourceSynchSupport.IsDisciplineActionDisciplinesSupported)
            {    
                targetSynchSupport.IsDisciplineActionDisciplineIncluded = sourceSynchSupport.IsDisciplineActionDisciplineIncluded;
                source.DisciplineActionDisciplines.MapListTo(target.DisciplineActionDisciplines);
            }
            else
            {
                targetSynchSupport.IsDisciplineActionDisciplinesSupported = false;
            }

            if (sourceSynchSupport.IsDisciplineActionDisciplineIncidentsSupported)
            {    
                targetSynchSupport.IsDisciplineActionDisciplineIncidentIncluded = sourceSynchSupport.IsDisciplineActionDisciplineIncidentIncluded;
                source.DisciplineActionDisciplineIncidents.MapListTo(target.DisciplineActionDisciplineIncidents);
            }
            else
            {
                targetSynchSupport.IsDisciplineActionDisciplineIncidentsSupported = false;
            }

            if (sourceSynchSupport.IsDisciplineActionStaffsSupported)
            {    
                targetSynchSupport.IsDisciplineActionStaffIncluded = sourceSynchSupport.IsDisciplineActionStaffIncluded;
                source.DisciplineActionStaffs.MapListTo(target.DisciplineActionStaffs);
            }
            else
            {
                targetSynchSupport.IsDisciplineActionStaffsSupported = false;
            }

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IDisciplineActionSynchronizationSourceSupport
    {
        bool IsActualDisciplineActionLengthSupported { get; set; }
        bool IsAssignmentSchoolIdSupported { get; set; }
        bool IsDisciplineActionDisciplineIncidentsSupported { get; set; }
        bool IsDisciplineActionDisciplinesSupported { get; set; }
        bool IsDisciplineActionLengthSupported { get; set; }
        bool IsDisciplineActionLengthDifferenceReasonTypeSupported { get; set; }
        bool IsDisciplineActionStaffsSupported { get; set; }
        bool IsRelatedToZeroTolerancePolicySupported { get; set; }
        bool IsResponsibilitySchoolIdSupported { get; set; }
        Func<IDisciplineActionDiscipline, bool> IsDisciplineActionDisciplineIncluded { get; set; }
        Func<IDisciplineActionDisciplineIncident, bool> IsDisciplineActionDisciplineIncidentIncluded { get; set; }
        Func<IDisciplineActionStaff, bool> IsDisciplineActionStaffIncluded { get; set; }
    }
 
    public static class DisciplineActionDisciplineMapper 
    {
        public static bool SynchronizeTo(this IDisciplineActionDiscipline source, IDisciplineActionDiscipline target)
        {
            bool isModified = false;

            var sourceSupport = source as IDisciplineActionDisciplineSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.DisciplineDescriptor != target.DisciplineDescriptor)
            {
                source.DisciplineDescriptor = target.DisciplineDescriptor;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IDisciplineActionDiscipline source, IDisciplineActionDiscipline target, Action<IDisciplineActionDiscipline, IDisciplineActionDiscipline> onMapped)
        {
            var sourceSynchSupport = source as IDisciplineActionDisciplineSynchronizationSourceSupport;
            var targetSynchSupport = target as IDisciplineActionDisciplineSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.DisciplineDescriptor = source.DisciplineDescriptor;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IDisciplineActionDisciplineSynchronizationSourceSupport
    {
    }
 
    public static class DisciplineActionDisciplineIncidentMapper 
    {
        public static bool SynchronizeTo(this IDisciplineActionDisciplineIncident source, IDisciplineActionDisciplineIncident target)
        {
            bool isModified = false;

            var sourceSupport = source as IDisciplineActionDisciplineIncidentSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.IncidentIdentifier != target.IncidentIdentifier)
            {
                source.IncidentIdentifier = target.IncidentIdentifier;
            }
            if (source.SchoolId != target.SchoolId)
            {
                source.SchoolId = target.SchoolId;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IDisciplineActionDisciplineIncident source, IDisciplineActionDisciplineIncident target, Action<IDisciplineActionDisciplineIncident, IDisciplineActionDisciplineIncident> onMapped)
        {
            var sourceSynchSupport = source as IDisciplineActionDisciplineIncidentSynchronizationSourceSupport;
            var targetSynchSupport = target as IDisciplineActionDisciplineIncidentSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.IncidentIdentifier = source.IncidentIdentifier;
            target.SchoolId = source.SchoolId;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IDisciplineActionDisciplineIncidentSynchronizationSourceSupport
    {
    }
 
    public static class DisciplineActionStaffMapper 
    {
        public static bool SynchronizeTo(this IDisciplineActionStaff source, IDisciplineActionStaff target)
        {
            bool isModified = false;

            var sourceSupport = source as IDisciplineActionStaffSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.StaffUniqueId != target.StaffUniqueId)
            {
                source.StaffUniqueId = target.StaffUniqueId;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IDisciplineActionStaff source, IDisciplineActionStaff target, Action<IDisciplineActionStaff, IDisciplineActionStaff> onMapped)
        {
            var sourceSynchSupport = source as IDisciplineActionStaffSynchronizationSourceSupport;
            var targetSynchSupport = target as IDisciplineActionStaffSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.StaffUniqueId = source.StaffUniqueId;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IDisciplineActionStaffSynchronizationSourceSupport
    {
    }
 
}
// Aggregate: DisciplineActionLengthDifferenceReasonType

namespace EdFi.Ods.Entities.Common //.DisciplineActionLengthDifferenceReasonTypeAggregate
{ 
    public static class DisciplineActionLengthDifferenceReasonTypeMapper 
    {
        public static bool SynchronizeTo(this IDisciplineActionLengthDifferenceReasonType source, IDisciplineActionLengthDifferenceReasonType target)
        {
            bool isModified = false;

            var sourceSupport = source as IDisciplineActionLengthDifferenceReasonTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.DisciplineActionLengthDifferenceReasonTypeId != target.DisciplineActionLengthDifferenceReasonTypeId)
            {
                source.DisciplineActionLengthDifferenceReasonTypeId = target.DisciplineActionLengthDifferenceReasonTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IDisciplineActionLengthDifferenceReasonType source, IDisciplineActionLengthDifferenceReasonType target, Action<IDisciplineActionLengthDifferenceReasonType, IDisciplineActionLengthDifferenceReasonType> onMapped)
        {
            var sourceSynchSupport = source as IDisciplineActionLengthDifferenceReasonTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IDisciplineActionLengthDifferenceReasonTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.DisciplineActionLengthDifferenceReasonTypeId = source.DisciplineActionLengthDifferenceReasonTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IDisciplineActionLengthDifferenceReasonTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: DisciplineDescriptor

namespace EdFi.Ods.Entities.Common //.DisciplineDescriptorAggregate
{ 
    public static class DisciplineDescriptorMapper 
    {
        public static bool SynchronizeTo(this IDisciplineDescriptor source, IDisciplineDescriptor target)
        {
            bool isModified = false;

            var sourceSupport = source as IDisciplineDescriptorSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.DisciplineDescriptorId != target.DisciplineDescriptorId)
            {
                source.DisciplineDescriptorId = target.DisciplineDescriptorId;
            }

            // Copy inherited non-PK properties


            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveBeginDateSupported)
                && target.EffectiveBeginDate != source.EffectiveBeginDate)
            {
                target.EffectiveBeginDate = source.EffectiveBeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveEndDateSupported)
                && target.EffectiveEndDate != source.EffectiveEndDate)
            {
                target.EffectiveEndDate = source.EffectiveEndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNamespaceSupported)
                && target.Namespace != source.Namespace)
            {
                target.Namespace = source.Namespace;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPriorDescriptorIdSupported)
                && target.PriorDescriptorId != source.PriorDescriptorId)
            {
                target.PriorDescriptorId = source.PriorDescriptorId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsDisciplineTypeSupported)
                && target.DisciplineType != source.DisciplineType)
            {
                target.DisciplineType = source.DisciplineType;
                isModified = true;
            }

            // Synch inherited lists


            // Sync lists

            return isModified;
        }



        public static void MapTo(this IDisciplineDescriptor source, IDisciplineDescriptor target, Action<IDisciplineDescriptor, IDisciplineDescriptor> onMapped)
        {
            var sourceSynchSupport = source as IDisciplineDescriptorSynchronizationSourceSupport;
            var targetSynchSupport = target as IDisciplineDescriptorSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.DisciplineDescriptorId = source.DisciplineDescriptorId;

            // Copy inherited non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsEffectiveBeginDateSupported)
                target.EffectiveBeginDate = source.EffectiveBeginDate;
            else
                targetSynchSupport.IsEffectiveBeginDateSupported = false;

            if (sourceSynchSupport.IsEffectiveEndDateSupported)
                target.EffectiveEndDate = source.EffectiveEndDate;
            else
                targetSynchSupport.IsEffectiveEndDateSupported = false;

            if (sourceSynchSupport.IsNamespaceSupported)
                target.Namespace = source.Namespace;
            else
                targetSynchSupport.IsNamespaceSupported = false;

            if (sourceSynchSupport.IsPriorDescriptorIdSupported)
                target.PriorDescriptorId = source.PriorDescriptorId;
            else
                targetSynchSupport.IsPriorDescriptorIdSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Copy non-PK properties

            if (sourceSynchSupport.IsDisciplineTypeSupported)
                target.DisciplineType = source.DisciplineType;
            else
                targetSynchSupport.IsDisciplineTypeSupported = false;

            // Map inherited lists

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IDisciplineDescriptorSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsDisciplineTypeSupported { get; set; }
        bool IsEffectiveBeginDateSupported { get; set; }
        bool IsEffectiveEndDateSupported { get; set; }
        bool IsNamespaceSupported { get; set; }
        bool IsPriorDescriptorIdSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: DisciplineIncident

namespace EdFi.Ods.Entities.Common //.DisciplineIncidentAggregate
{ 
    public static class DisciplineIncidentMapper 
    {
        public static bool SynchronizeTo(this IDisciplineIncident source, IDisciplineIncident target)
        {
            bool isModified = false;

            var sourceSupport = source as IDisciplineIncidentSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.IncidentIdentifier != target.IncidentIdentifier)
            {
                source.IncidentIdentifier = target.IncidentIdentifier;
            }
            if (source.SchoolId != target.SchoolId)
            {
                source.SchoolId = target.SchoolId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCaseNumberSupported)
                && target.CaseNumber != source.CaseNumber)
            {
                target.CaseNumber = source.CaseNumber;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsIncidentCostSupported)
                && target.IncidentCost != source.IncidentCost)
            {
                target.IncidentCost = source.IncidentCost;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsIncidentDateSupported)
                && target.IncidentDate != source.IncidentDate)
            {
                target.IncidentDate = source.IncidentDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsIncidentDescriptionSupported)
                && target.IncidentDescription != source.IncidentDescription)
            {
                target.IncidentDescription = source.IncidentDescription;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsIncidentLocationTypeSupported)
                && target.IncidentLocationType != source.IncidentLocationType)
            {
                target.IncidentLocationType = source.IncidentLocationType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsIncidentTimeSupported)
                && target.IncidentTime != source.IncidentTime)
            {
                target.IncidentTime = source.IncidentTime;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsReportedToLawEnforcementSupported)
                && target.ReportedToLawEnforcement != source.ReportedToLawEnforcement)
            {
                target.ReportedToLawEnforcement = source.ReportedToLawEnforcement;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsReporterDescriptionDescriptorSupported)
                && target.ReporterDescriptionDescriptor != source.ReporterDescriptionDescriptor)
            {
                target.ReporterDescriptionDescriptor = source.ReporterDescriptionDescriptor;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsReporterNameSupported)
                && target.ReporterName != source.ReporterName)
            {
                target.ReporterName = source.ReporterName;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsStaffUniqueIdSupported)
                && target.StaffUniqueId != source.StaffUniqueId)
            {
                target.StaffUniqueId = source.StaffUniqueId;
                isModified = true;
            }



            // Sync lists
            if (sourceSupport == null || sourceSupport.IsDisciplineIncidentBehaviorsSupported)
                isModified |= source.DisciplineIncidentBehaviors.SynchronizeListTo(target.DisciplineIncidentBehaviors, child => child.DisciplineIncident = target,
                                sourceSupport == null ? null : sourceSupport.IsDisciplineIncidentBehaviorIncluded);

            if (sourceSupport == null || sourceSupport.IsDisciplineIncidentWeaponsSupported)
                isModified |= source.DisciplineIncidentWeapons.SynchronizeListTo(target.DisciplineIncidentWeapons, child => child.DisciplineIncident = target,
                                sourceSupport == null ? null : sourceSupport.IsDisciplineIncidentWeaponIncluded);


            return isModified;
        }



        public static void MapTo(this IDisciplineIncident source, IDisciplineIncident target, Action<IDisciplineIncident, IDisciplineIncident> onMapped)
        {
            var sourceSynchSupport = source as IDisciplineIncidentSynchronizationSourceSupport;
            var targetSynchSupport = target as IDisciplineIncidentSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.IncidentIdentifier = source.IncidentIdentifier;
            target.SchoolId = source.SchoolId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCaseNumberSupported)
                target.CaseNumber = source.CaseNumber;
            else
                targetSynchSupport.IsCaseNumberSupported = false;

            if (sourceSynchSupport.IsIncidentCostSupported)
                target.IncidentCost = source.IncidentCost;
            else
                targetSynchSupport.IsIncidentCostSupported = false;

            if (sourceSynchSupport.IsIncidentDateSupported)
                target.IncidentDate = source.IncidentDate;
            else
                targetSynchSupport.IsIncidentDateSupported = false;

            if (sourceSynchSupport.IsIncidentDescriptionSupported)
                target.IncidentDescription = source.IncidentDescription;
            else
                targetSynchSupport.IsIncidentDescriptionSupported = false;

            if (sourceSynchSupport.IsIncidentLocationTypeSupported)
                target.IncidentLocationType = source.IncidentLocationType;
            else
                targetSynchSupport.IsIncidentLocationTypeSupported = false;

            if (sourceSynchSupport.IsIncidentTimeSupported)
                target.IncidentTime = source.IncidentTime;
            else
                targetSynchSupport.IsIncidentTimeSupported = false;

            if (sourceSynchSupport.IsReportedToLawEnforcementSupported)
                target.ReportedToLawEnforcement = source.ReportedToLawEnforcement;
            else
                targetSynchSupport.IsReportedToLawEnforcementSupported = false;

            if (sourceSynchSupport.IsReporterDescriptionDescriptorSupported)
                target.ReporterDescriptionDescriptor = source.ReporterDescriptionDescriptor;
            else
                targetSynchSupport.IsReporterDescriptionDescriptorSupported = false;

            if (sourceSynchSupport.IsReporterNameSupported)
                target.ReporterName = source.ReporterName;
            else
                targetSynchSupport.IsReporterNameSupported = false;

            if (sourceSynchSupport.IsStaffUniqueIdSupported)
                target.StaffUniqueId = source.StaffUniqueId;
            else
                targetSynchSupport.IsStaffUniqueIdSupported = false;

            // Map lists

            if (sourceSynchSupport.IsDisciplineIncidentBehaviorsSupported)
            {    
                targetSynchSupport.IsDisciplineIncidentBehaviorIncluded = sourceSynchSupport.IsDisciplineIncidentBehaviorIncluded;
                source.DisciplineIncidentBehaviors.MapListTo(target.DisciplineIncidentBehaviors);
            }
            else
            {
                targetSynchSupport.IsDisciplineIncidentBehaviorsSupported = false;
            }

            if (sourceSynchSupport.IsDisciplineIncidentWeaponsSupported)
            {    
                targetSynchSupport.IsDisciplineIncidentWeaponIncluded = sourceSynchSupport.IsDisciplineIncidentWeaponIncluded;
                source.DisciplineIncidentWeapons.MapListTo(target.DisciplineIncidentWeapons);
            }
            else
            {
                targetSynchSupport.IsDisciplineIncidentWeaponsSupported = false;
            }

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IDisciplineIncidentSynchronizationSourceSupport
    {
        bool IsCaseNumberSupported { get; set; }
        bool IsDisciplineIncidentBehaviorsSupported { get; set; }
        bool IsDisciplineIncidentWeaponsSupported { get; set; }
        bool IsIncidentCostSupported { get; set; }
        bool IsIncidentDateSupported { get; set; }
        bool IsIncidentDescriptionSupported { get; set; }
        bool IsIncidentLocationTypeSupported { get; set; }
        bool IsIncidentTimeSupported { get; set; }
        bool IsReportedToLawEnforcementSupported { get; set; }
        bool IsReporterDescriptionDescriptorSupported { get; set; }
        bool IsReporterNameSupported { get; set; }
        bool IsStaffUniqueIdSupported { get; set; }
        Func<IDisciplineIncidentBehavior, bool> IsDisciplineIncidentBehaviorIncluded { get; set; }
        Func<IDisciplineIncidentWeapon, bool> IsDisciplineIncidentWeaponIncluded { get; set; }
    }
 
    public static class DisciplineIncidentBehaviorMapper 
    {
        public static bool SynchronizeTo(this IDisciplineIncidentBehavior source, IDisciplineIncidentBehavior target)
        {
            bool isModified = false;

            var sourceSupport = source as IDisciplineIncidentBehaviorSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.BehaviorDescriptor != target.BehaviorDescriptor)
            {
                source.BehaviorDescriptor = target.BehaviorDescriptor;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsBehaviorDetailedDescriptionSupported)
                && target.BehaviorDetailedDescription != source.BehaviorDetailedDescription)
            {
                target.BehaviorDetailedDescription = source.BehaviorDetailedDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IDisciplineIncidentBehavior source, IDisciplineIncidentBehavior target, Action<IDisciplineIncidentBehavior, IDisciplineIncidentBehavior> onMapped)
        {
            var sourceSynchSupport = source as IDisciplineIncidentBehaviorSynchronizationSourceSupport;
            var targetSynchSupport = target as IDisciplineIncidentBehaviorSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.BehaviorDescriptor = source.BehaviorDescriptor;

            // Copy non-PK properties

            if (sourceSynchSupport.IsBehaviorDetailedDescriptionSupported)
                target.BehaviorDetailedDescription = source.BehaviorDetailedDescription;
            else
                targetSynchSupport.IsBehaviorDetailedDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IDisciplineIncidentBehaviorSynchronizationSourceSupport
    {
        bool IsBehaviorDetailedDescriptionSupported { get; set; }
    }
 
    public static class DisciplineIncidentWeaponMapper 
    {
        public static bool SynchronizeTo(this IDisciplineIncidentWeapon source, IDisciplineIncidentWeapon target)
        {
            bool isModified = false;

            var sourceSupport = source as IDisciplineIncidentWeaponSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.WeaponDescriptor != target.WeaponDescriptor)
            {
                source.WeaponDescriptor = target.WeaponDescriptor;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IDisciplineIncidentWeapon source, IDisciplineIncidentWeapon target, Action<IDisciplineIncidentWeapon, IDisciplineIncidentWeapon> onMapped)
        {
            var sourceSynchSupport = source as IDisciplineIncidentWeaponSynchronizationSourceSupport;
            var targetSynchSupport = target as IDisciplineIncidentWeaponSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.WeaponDescriptor = source.WeaponDescriptor;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IDisciplineIncidentWeaponSynchronizationSourceSupport
    {
    }
 
}
// Aggregate: DisciplineType

namespace EdFi.Ods.Entities.Common //.DisciplineTypeAggregate
{ 
    public static class DisciplineTypeMapper 
    {
        public static bool SynchronizeTo(this IDisciplineType source, IDisciplineType target)
        {
            bool isModified = false;

            var sourceSupport = source as IDisciplineTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.DisciplineTypeId != target.DisciplineTypeId)
            {
                source.DisciplineTypeId = target.DisciplineTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IDisciplineType source, IDisciplineType target, Action<IDisciplineType, IDisciplineType> onMapped)
        {
            var sourceSynchSupport = source as IDisciplineTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IDisciplineTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.DisciplineTypeId = source.DisciplineTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IDisciplineTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: EducationalEnvironmentType

namespace EdFi.Ods.Entities.Common //.EducationalEnvironmentTypeAggregate
{ 
    public static class EducationalEnvironmentTypeMapper 
    {
        public static bool SynchronizeTo(this IEducationalEnvironmentType source, IEducationalEnvironmentType target)
        {
            bool isModified = false;

            var sourceSupport = source as IEducationalEnvironmentTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.EducationalEnvironmentTypeId != target.EducationalEnvironmentTypeId)
            {
                source.EducationalEnvironmentTypeId = target.EducationalEnvironmentTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IEducationalEnvironmentType source, IEducationalEnvironmentType target, Action<IEducationalEnvironmentType, IEducationalEnvironmentType> onMapped)
        {
            var sourceSynchSupport = source as IEducationalEnvironmentTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IEducationalEnvironmentTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.EducationalEnvironmentTypeId = source.EducationalEnvironmentTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IEducationalEnvironmentTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: EducationContent

namespace EdFi.Ods.Entities.Common //.EducationContentAggregate
{ 
    public static class EducationContentMapper 
    {
        public static bool SynchronizeTo(this IEducationContent source, IEducationContent target)
        {
            bool isModified = false;

            var sourceSupport = source as IEducationContentSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.ContentIdentifier != target.ContentIdentifier)
            {
                source.ContentIdentifier = target.ContentIdentifier;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsAdditionalAuthorsIndicatorSupported)
                && target.AdditionalAuthorsIndicator != source.AdditionalAuthorsIndicator)
            {
                target.AdditionalAuthorsIndicator = source.AdditionalAuthorsIndicator;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsContentClassTypeSupported)
                && target.ContentClassType != source.ContentClassType)
            {
                target.ContentClassType = source.ContentClassType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsCostSupported)
                && target.Cost != source.Cost)
            {
                target.Cost = source.Cost;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsCostRateTypeSupported)
                && target.CostRateType != source.CostRateType)
            {
                target.CostRateType = source.CostRateType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsInteractivityStyleTypeSupported)
                && target.InteractivityStyleType != source.InteractivityStyleType)
            {
                target.InteractivityStyleType = source.InteractivityStyleType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsLearningResourceMetadataURISupported)
                && target.LearningResourceMetadataURI != source.LearningResourceMetadataURI)
            {
                target.LearningResourceMetadataURI = source.LearningResourceMetadataURI;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsLearningStandardIdSupported)
                && target.LearningStandardId != source.LearningStandardId)
            {
                target.LearningStandardId = source.LearningStandardId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNamespaceSupported)
                && target.Namespace != source.Namespace)
            {
                target.Namespace = source.Namespace;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPublicationDateSupported)
                && target.PublicationDate != source.PublicationDate)
            {
                target.PublicationDate = source.PublicationDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPublicationYearSupported)
                && target.PublicationYear != source.PublicationYear)
            {
                target.PublicationYear = source.PublicationYear;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPublisherSupported)
                && target.Publisher != source.Publisher)
            {
                target.Publisher = source.Publisher;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsTimeRequiredSupported)
                && target.TimeRequired != source.TimeRequired)
            {
                target.TimeRequired = source.TimeRequired;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsUseRightsURLSupported)
                && target.UseRightsURL != source.UseRightsURL)
            {
                target.UseRightsURL = source.UseRightsURL;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsVersionSupported)
                && target.Version != source.Version)
            {
                target.Version = source.Version;
                isModified = true;
            }



            // Sync lists
            if (sourceSupport == null || sourceSupport.IsEducationContentAppropriateGradeLevelsSupported)
                isModified |= source.EducationContentAppropriateGradeLevels.SynchronizeListTo(target.EducationContentAppropriateGradeLevels, child => child.EducationContent = target,
                                sourceSupport == null ? null : sourceSupport.IsEducationContentAppropriateGradeLevelIncluded);

            if (sourceSupport == null || sourceSupport.IsEducationContentAppropriateSexesSupported)
                isModified |= source.EducationContentAppropriateSexes.SynchronizeListTo(target.EducationContentAppropriateSexes, child => child.EducationContent = target,
                                sourceSupport == null ? null : sourceSupport.IsEducationContentAppropriateSexIncluded);

            if (sourceSupport == null || sourceSupport.IsEducationContentAuthorsSupported)
                isModified |= source.EducationContentAuthors.SynchronizeListTo(target.EducationContentAuthors, child => child.EducationContent = target,
                                sourceSupport == null ? null : sourceSupport.IsEducationContentAuthorIncluded);

            if (sourceSupport == null || sourceSupport.IsEducationContentDerivativeSourceEducationContentsSupported)
                isModified |= source.EducationContentDerivativeSourceEducationContents.SynchronizeListTo(target.EducationContentDerivativeSourceEducationContents, child => child.EducationContent = target,
                                sourceSupport == null ? null : sourceSupport.IsEducationContentDerivativeSourceEducationContentIncluded);

            if (sourceSupport == null || sourceSupport.IsEducationContentDerivativeSourceLearningResourceMetadataURIsSupported)
                isModified |= source.EducationContentDerivativeSourceLearningResourceMetadataURIs.SynchronizeListTo(target.EducationContentDerivativeSourceLearningResourceMetadataURIs, child => child.EducationContent = target,
                                sourceSupport == null ? null : sourceSupport.IsEducationContentDerivativeSourceLearningResourceMetadataURIIncluded);

            if (sourceSupport == null || sourceSupport.IsEducationContentDerivativeSourceURIsSupported)
                isModified |= source.EducationContentDerivativeSourceURIs.SynchronizeListTo(target.EducationContentDerivativeSourceURIs, child => child.EducationContent = target,
                                sourceSupport == null ? null : sourceSupport.IsEducationContentDerivativeSourceURIIncluded);

            if (sourceSupport == null || sourceSupport.IsEducationContentLanguagesSupported)
                isModified |= source.EducationContentLanguages.SynchronizeListTo(target.EducationContentLanguages, child => child.EducationContent = target,
                                sourceSupport == null ? null : sourceSupport.IsEducationContentLanguageIncluded);


            return isModified;
        }



        public static void MapTo(this IEducationContent source, IEducationContent target, Action<IEducationContent, IEducationContent> onMapped)
        {
            var sourceSynchSupport = source as IEducationContentSynchronizationSourceSupport;
            var targetSynchSupport = target as IEducationContentSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.ContentIdentifier = source.ContentIdentifier;

            // Copy non-PK properties

            if (sourceSynchSupport.IsAdditionalAuthorsIndicatorSupported)
                target.AdditionalAuthorsIndicator = source.AdditionalAuthorsIndicator;
            else
                targetSynchSupport.IsAdditionalAuthorsIndicatorSupported = false;

            if (sourceSynchSupport.IsContentClassTypeSupported)
                target.ContentClassType = source.ContentClassType;
            else
                targetSynchSupport.IsContentClassTypeSupported = false;

            if (sourceSynchSupport.IsCostSupported)
                target.Cost = source.Cost;
            else
                targetSynchSupport.IsCostSupported = false;

            if (sourceSynchSupport.IsCostRateTypeSupported)
                target.CostRateType = source.CostRateType;
            else
                targetSynchSupport.IsCostRateTypeSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsInteractivityStyleTypeSupported)
                target.InteractivityStyleType = source.InteractivityStyleType;
            else
                targetSynchSupport.IsInteractivityStyleTypeSupported = false;

            if (sourceSynchSupport.IsLearningResourceMetadataURISupported)
                target.LearningResourceMetadataURI = source.LearningResourceMetadataURI;
            else
                targetSynchSupport.IsLearningResourceMetadataURISupported = false;

            if (sourceSynchSupport.IsLearningStandardIdSupported)
                target.LearningStandardId = source.LearningStandardId;
            else
                targetSynchSupport.IsLearningStandardIdSupported = false;

            if (sourceSynchSupport.IsNamespaceSupported)
                target.Namespace = source.Namespace;
            else
                targetSynchSupport.IsNamespaceSupported = false;

            if (sourceSynchSupport.IsPublicationDateSupported)
                target.PublicationDate = source.PublicationDate;
            else
                targetSynchSupport.IsPublicationDateSupported = false;

            if (sourceSynchSupport.IsPublicationYearSupported)
                target.PublicationYear = source.PublicationYear;
            else
                targetSynchSupport.IsPublicationYearSupported = false;

            if (sourceSynchSupport.IsPublisherSupported)
                target.Publisher = source.Publisher;
            else
                targetSynchSupport.IsPublisherSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            if (sourceSynchSupport.IsTimeRequiredSupported)
                target.TimeRequired = source.TimeRequired;
            else
                targetSynchSupport.IsTimeRequiredSupported = false;

            if (sourceSynchSupport.IsUseRightsURLSupported)
                target.UseRightsURL = source.UseRightsURL;
            else
                targetSynchSupport.IsUseRightsURLSupported = false;

            if (sourceSynchSupport.IsVersionSupported)
                target.Version = source.Version;
            else
                targetSynchSupport.IsVersionSupported = false;

            // Map lists

            if (sourceSynchSupport.IsEducationContentAppropriateGradeLevelsSupported)
            {    
                targetSynchSupport.IsEducationContentAppropriateGradeLevelIncluded = sourceSynchSupport.IsEducationContentAppropriateGradeLevelIncluded;
                source.EducationContentAppropriateGradeLevels.MapListTo(target.EducationContentAppropriateGradeLevels);
            }
            else
            {
                targetSynchSupport.IsEducationContentAppropriateGradeLevelsSupported = false;
            }

            if (sourceSynchSupport.IsEducationContentAppropriateSexesSupported)
            {    
                targetSynchSupport.IsEducationContentAppropriateSexIncluded = sourceSynchSupport.IsEducationContentAppropriateSexIncluded;
                source.EducationContentAppropriateSexes.MapListTo(target.EducationContentAppropriateSexes);
            }
            else
            {
                targetSynchSupport.IsEducationContentAppropriateSexesSupported = false;
            }

            if (sourceSynchSupport.IsEducationContentAuthorsSupported)
            {    
                targetSynchSupport.IsEducationContentAuthorIncluded = sourceSynchSupport.IsEducationContentAuthorIncluded;
                source.EducationContentAuthors.MapListTo(target.EducationContentAuthors);
            }
            else
            {
                targetSynchSupport.IsEducationContentAuthorsSupported = false;
            }

            if (sourceSynchSupport.IsEducationContentDerivativeSourceEducationContentsSupported)
            {    
                targetSynchSupport.IsEducationContentDerivativeSourceEducationContentIncluded = sourceSynchSupport.IsEducationContentDerivativeSourceEducationContentIncluded;
                source.EducationContentDerivativeSourceEducationContents.MapListTo(target.EducationContentDerivativeSourceEducationContents);
            }
            else
            {
                targetSynchSupport.IsEducationContentDerivativeSourceEducationContentsSupported = false;
            }

            if (sourceSynchSupport.IsEducationContentDerivativeSourceLearningResourceMetadataURIsSupported)
            {    
                targetSynchSupport.IsEducationContentDerivativeSourceLearningResourceMetadataURIIncluded = sourceSynchSupport.IsEducationContentDerivativeSourceLearningResourceMetadataURIIncluded;
                source.EducationContentDerivativeSourceLearningResourceMetadataURIs.MapListTo(target.EducationContentDerivativeSourceLearningResourceMetadataURIs);
            }
            else
            {
                targetSynchSupport.IsEducationContentDerivativeSourceLearningResourceMetadataURIsSupported = false;
            }

            if (sourceSynchSupport.IsEducationContentDerivativeSourceURIsSupported)
            {    
                targetSynchSupport.IsEducationContentDerivativeSourceURIIncluded = sourceSynchSupport.IsEducationContentDerivativeSourceURIIncluded;
                source.EducationContentDerivativeSourceURIs.MapListTo(target.EducationContentDerivativeSourceURIs);
            }
            else
            {
                targetSynchSupport.IsEducationContentDerivativeSourceURIsSupported = false;
            }

            if (sourceSynchSupport.IsEducationContentLanguagesSupported)
            {    
                targetSynchSupport.IsEducationContentLanguageIncluded = sourceSynchSupport.IsEducationContentLanguageIncluded;
                source.EducationContentLanguages.MapListTo(target.EducationContentLanguages);
            }
            else
            {
                targetSynchSupport.IsEducationContentLanguagesSupported = false;
            }

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IEducationContentSynchronizationSourceSupport
    {
        bool IsAdditionalAuthorsIndicatorSupported { get; set; }
        bool IsContentClassTypeSupported { get; set; }
        bool IsCostSupported { get; set; }
        bool IsCostRateTypeSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsEducationContentAppropriateGradeLevelsSupported { get; set; }
        bool IsEducationContentAppropriateSexesSupported { get; set; }
        bool IsEducationContentAuthorsSupported { get; set; }
        bool IsEducationContentDerivativeSourceEducationContentsSupported { get; set; }
        bool IsEducationContentDerivativeSourceLearningResourceMetadataURIsSupported { get; set; }
        bool IsEducationContentDerivativeSourceURIsSupported { get; set; }
        bool IsEducationContentLanguagesSupported { get; set; }
        bool IsInteractivityStyleTypeSupported { get; set; }
        bool IsLearningResourceMetadataURISupported { get; set; }
        bool IsLearningStandardIdSupported { get; set; }
        bool IsNamespaceSupported { get; set; }
        bool IsPublicationDateSupported { get; set; }
        bool IsPublicationYearSupported { get; set; }
        bool IsPublisherSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
        bool IsTimeRequiredSupported { get; set; }
        bool IsUseRightsURLSupported { get; set; }
        bool IsVersionSupported { get; set; }
        Func<IEducationContentAppropriateGradeLevel, bool> IsEducationContentAppropriateGradeLevelIncluded { get; set; }
        Func<IEducationContentAppropriateSex, bool> IsEducationContentAppropriateSexIncluded { get; set; }
        Func<IEducationContentAuthor, bool> IsEducationContentAuthorIncluded { get; set; }
        Func<IEducationContentDerivativeSourceEducationContent, bool> IsEducationContentDerivativeSourceEducationContentIncluded { get; set; }
        Func<IEducationContentDerivativeSourceLearningResourceMetadataURI, bool> IsEducationContentDerivativeSourceLearningResourceMetadataURIIncluded { get; set; }
        Func<IEducationContentDerivativeSourceURI, bool> IsEducationContentDerivativeSourceURIIncluded { get; set; }
        Func<IEducationContentLanguage, bool> IsEducationContentLanguageIncluded { get; set; }
    }
 
    public static class EducationContentAppropriateGradeLevelMapper 
    {
        public static bool SynchronizeTo(this IEducationContentAppropriateGradeLevel source, IEducationContentAppropriateGradeLevel target)
        {
            bool isModified = false;

            var sourceSupport = source as IEducationContentAppropriateGradeLevelSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.GradeLevelDescriptor != target.GradeLevelDescriptor)
            {
                source.GradeLevelDescriptor = target.GradeLevelDescriptor;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IEducationContentAppropriateGradeLevel source, IEducationContentAppropriateGradeLevel target, Action<IEducationContentAppropriateGradeLevel, IEducationContentAppropriateGradeLevel> onMapped)
        {
            var sourceSynchSupport = source as IEducationContentAppropriateGradeLevelSynchronizationSourceSupport;
            var targetSynchSupport = target as IEducationContentAppropriateGradeLevelSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.GradeLevelDescriptor = source.GradeLevelDescriptor;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IEducationContentAppropriateGradeLevelSynchronizationSourceSupport
    {
    }
 
    public static class EducationContentAppropriateSexMapper 
    {
        public static bool SynchronizeTo(this IEducationContentAppropriateSex source, IEducationContentAppropriateSex target)
        {
            bool isModified = false;

            var sourceSupport = source as IEducationContentAppropriateSexSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.SexType != target.SexType)
            {
                source.SexType = target.SexType;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IEducationContentAppropriateSex source, IEducationContentAppropriateSex target, Action<IEducationContentAppropriateSex, IEducationContentAppropriateSex> onMapped)
        {
            var sourceSynchSupport = source as IEducationContentAppropriateSexSynchronizationSourceSupport;
            var targetSynchSupport = target as IEducationContentAppropriateSexSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.SexType = source.SexType;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IEducationContentAppropriateSexSynchronizationSourceSupport
    {
    }
 
    public static class EducationContentAuthorMapper 
    {
        public static bool SynchronizeTo(this IEducationContentAuthor source, IEducationContentAuthor target)
        {
            bool isModified = false;

            var sourceSupport = source as IEducationContentAuthorSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.Author != target.Author)
            {
                source.Author = target.Author;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IEducationContentAuthor source, IEducationContentAuthor target, Action<IEducationContentAuthor, IEducationContentAuthor> onMapped)
        {
            var sourceSynchSupport = source as IEducationContentAuthorSynchronizationSourceSupport;
            var targetSynchSupport = target as IEducationContentAuthorSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.Author = source.Author;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IEducationContentAuthorSynchronizationSourceSupport
    {
    }
 
    public static class EducationContentDerivativeSourceEducationContentMapper 
    {
        public static bool SynchronizeTo(this IEducationContentDerivativeSourceEducationContent source, IEducationContentDerivativeSourceEducationContent target)
        {
            bool isModified = false;

            var sourceSupport = source as IEducationContentDerivativeSourceEducationContentSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.DerivativeSourceContentIdentifier != target.DerivativeSourceContentIdentifier)
            {
                source.DerivativeSourceContentIdentifier = target.DerivativeSourceContentIdentifier;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IEducationContentDerivativeSourceEducationContent source, IEducationContentDerivativeSourceEducationContent target, Action<IEducationContentDerivativeSourceEducationContent, IEducationContentDerivativeSourceEducationContent> onMapped)
        {
            var sourceSynchSupport = source as IEducationContentDerivativeSourceEducationContentSynchronizationSourceSupport;
            var targetSynchSupport = target as IEducationContentDerivativeSourceEducationContentSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.DerivativeSourceContentIdentifier = source.DerivativeSourceContentIdentifier;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IEducationContentDerivativeSourceEducationContentSynchronizationSourceSupport
    {
    }
 
    public static class EducationContentDerivativeSourceLearningResourceMetadataURIMapper 
    {
        public static bool SynchronizeTo(this IEducationContentDerivativeSourceLearningResourceMetadataURI source, IEducationContentDerivativeSourceLearningResourceMetadataURI target)
        {
            bool isModified = false;

            var sourceSupport = source as IEducationContentDerivativeSourceLearningResourceMetadataURISynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.LearningResourceMetadataURI != target.LearningResourceMetadataURI)
            {
                source.LearningResourceMetadataURI = target.LearningResourceMetadataURI;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IEducationContentDerivativeSourceLearningResourceMetadataURI source, IEducationContentDerivativeSourceLearningResourceMetadataURI target, Action<IEducationContentDerivativeSourceLearningResourceMetadataURI, IEducationContentDerivativeSourceLearningResourceMetadataURI> onMapped)
        {
            var sourceSynchSupport = source as IEducationContentDerivativeSourceLearningResourceMetadataURISynchronizationSourceSupport;
            var targetSynchSupport = target as IEducationContentDerivativeSourceLearningResourceMetadataURISynchronizationSourceSupport;

            // Copy contextual primary key values
            target.LearningResourceMetadataURI = source.LearningResourceMetadataURI;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IEducationContentDerivativeSourceLearningResourceMetadataURISynchronizationSourceSupport
    {
    }
 
    public static class EducationContentDerivativeSourceURIMapper 
    {
        public static bool SynchronizeTo(this IEducationContentDerivativeSourceURI source, IEducationContentDerivativeSourceURI target)
        {
            bool isModified = false;

            var sourceSupport = source as IEducationContentDerivativeSourceURISynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.URI != target.URI)
            {
                source.URI = target.URI;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IEducationContentDerivativeSourceURI source, IEducationContentDerivativeSourceURI target, Action<IEducationContentDerivativeSourceURI, IEducationContentDerivativeSourceURI> onMapped)
        {
            var sourceSynchSupport = source as IEducationContentDerivativeSourceURISynchronizationSourceSupport;
            var targetSynchSupport = target as IEducationContentDerivativeSourceURISynchronizationSourceSupport;

            // Copy contextual primary key values
            target.URI = source.URI;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IEducationContentDerivativeSourceURISynchronizationSourceSupport
    {
    }
 
    public static class EducationContentLanguageMapper 
    {
        public static bool SynchronizeTo(this IEducationContentLanguage source, IEducationContentLanguage target)
        {
            bool isModified = false;

            var sourceSupport = source as IEducationContentLanguageSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.LanguageDescriptor != target.LanguageDescriptor)
            {
                source.LanguageDescriptor = target.LanguageDescriptor;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IEducationContentLanguage source, IEducationContentLanguage target, Action<IEducationContentLanguage, IEducationContentLanguage> onMapped)
        {
            var sourceSynchSupport = source as IEducationContentLanguageSynchronizationSourceSupport;
            var targetSynchSupport = target as IEducationContentLanguageSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.LanguageDescriptor = source.LanguageDescriptor;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IEducationContentLanguageSynchronizationSourceSupport
    {
    }
 
}
// Aggregate: EducationOrganization

namespace EdFi.Ods.Entities.Common //.EducationOrganizationAggregate
{ 
    public static class EducationOrganizationAddressMapper 
    {
        public static bool SynchronizeTo(this IEducationOrganizationAddress source, IEducationOrganizationAddress target)
        {
            bool isModified = false;

            var sourceSupport = source as IEducationOrganizationAddressSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AddressType != target.AddressType)
            {
                source.AddressType = target.AddressType;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsApartmentRoomSuiteNumberSupported)
                && target.ApartmentRoomSuiteNumber != source.ApartmentRoomSuiteNumber)
            {
                target.ApartmentRoomSuiteNumber = source.ApartmentRoomSuiteNumber;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsBeginDateSupported)
                && target.BeginDate != source.BeginDate)
            {
                target.BeginDate = source.BeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsBuildingSiteNumberSupported)
                && target.BuildingSiteNumber != source.BuildingSiteNumber)
            {
                target.BuildingSiteNumber = source.BuildingSiteNumber;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsCitySupported)
                && target.City != source.City)
            {
                target.City = source.City;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsCountyFIPSCodeSupported)
                && target.CountyFIPSCode != source.CountyFIPSCode)
            {
                target.CountyFIPSCode = source.CountyFIPSCode;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEndDateSupported)
                && target.EndDate != source.EndDate)
            {
                target.EndDate = source.EndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsLatitudeSupported)
                && target.Latitude != source.Latitude)
            {
                target.Latitude = source.Latitude;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsLongitudeSupported)
                && target.Longitude != source.Longitude)
            {
                target.Longitude = source.Longitude;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNameOfCountySupported)
                && target.NameOfCounty != source.NameOfCounty)
            {
                target.NameOfCounty = source.NameOfCounty;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPostalCodeSupported)
                && target.PostalCode != source.PostalCode)
            {
                target.PostalCode = source.PostalCode;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsStateAbbreviationTypeSupported)
                && target.StateAbbreviationType != source.StateAbbreviationType)
            {
                target.StateAbbreviationType = source.StateAbbreviationType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsStreetNumberNameSupported)
                && target.StreetNumberName != source.StreetNumberName)
            {
                target.StreetNumberName = source.StreetNumberName;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IEducationOrganizationAddress source, IEducationOrganizationAddress target, Action<IEducationOrganizationAddress, IEducationOrganizationAddress> onMapped)
        {
            var sourceSynchSupport = source as IEducationOrganizationAddressSynchronizationSourceSupport;
            var targetSynchSupport = target as IEducationOrganizationAddressSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.AddressType = source.AddressType;

            // Copy non-PK properties

            if (sourceSynchSupport.IsApartmentRoomSuiteNumberSupported)
                target.ApartmentRoomSuiteNumber = source.ApartmentRoomSuiteNumber;
            else
                targetSynchSupport.IsApartmentRoomSuiteNumberSupported = false;

            if (sourceSynchSupport.IsBeginDateSupported)
                target.BeginDate = source.BeginDate;
            else
                targetSynchSupport.IsBeginDateSupported = false;

            if (sourceSynchSupport.IsBuildingSiteNumberSupported)
                target.BuildingSiteNumber = source.BuildingSiteNumber;
            else
                targetSynchSupport.IsBuildingSiteNumberSupported = false;

            if (sourceSynchSupport.IsCitySupported)
                target.City = source.City;
            else
                targetSynchSupport.IsCitySupported = false;

            if (sourceSynchSupport.IsCountyFIPSCodeSupported)
                target.CountyFIPSCode = source.CountyFIPSCode;
            else
                targetSynchSupport.IsCountyFIPSCodeSupported = false;

            if (sourceSynchSupport.IsEndDateSupported)
                target.EndDate = source.EndDate;
            else
                targetSynchSupport.IsEndDateSupported = false;

            if (sourceSynchSupport.IsLatitudeSupported)
                target.Latitude = source.Latitude;
            else
                targetSynchSupport.IsLatitudeSupported = false;

            if (sourceSynchSupport.IsLongitudeSupported)
                target.Longitude = source.Longitude;
            else
                targetSynchSupport.IsLongitudeSupported = false;

            if (sourceSynchSupport.IsNameOfCountySupported)
                target.NameOfCounty = source.NameOfCounty;
            else
                targetSynchSupport.IsNameOfCountySupported = false;

            if (sourceSynchSupport.IsPostalCodeSupported)
                target.PostalCode = source.PostalCode;
            else
                targetSynchSupport.IsPostalCodeSupported = false;

            if (sourceSynchSupport.IsStateAbbreviationTypeSupported)
                target.StateAbbreviationType = source.StateAbbreviationType;
            else
                targetSynchSupport.IsStateAbbreviationTypeSupported = false;

            if (sourceSynchSupport.IsStreetNumberNameSupported)
                target.StreetNumberName = source.StreetNumberName;
            else
                targetSynchSupport.IsStreetNumberNameSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IEducationOrganizationAddressSynchronizationSourceSupport
    {
        bool IsApartmentRoomSuiteNumberSupported { get; set; }
        bool IsBeginDateSupported { get; set; }
        bool IsBuildingSiteNumberSupported { get; set; }
        bool IsCitySupported { get; set; }
        bool IsCountyFIPSCodeSupported { get; set; }
        bool IsEndDateSupported { get; set; }
        bool IsLatitudeSupported { get; set; }
        bool IsLongitudeSupported { get; set; }
        bool IsNameOfCountySupported { get; set; }
        bool IsPostalCodeSupported { get; set; }
        bool IsStateAbbreviationTypeSupported { get; set; }
        bool IsStreetNumberNameSupported { get; set; }
    }
 
    public static class EducationOrganizationCategoryMapper 
    {
        public static bool SynchronizeTo(this IEducationOrganizationCategory source, IEducationOrganizationCategory target)
        {
            bool isModified = false;

            var sourceSupport = source as IEducationOrganizationCategorySynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.EducationOrganizationCategoryType != target.EducationOrganizationCategoryType)
            {
                source.EducationOrganizationCategoryType = target.EducationOrganizationCategoryType;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IEducationOrganizationCategory source, IEducationOrganizationCategory target, Action<IEducationOrganizationCategory, IEducationOrganizationCategory> onMapped)
        {
            var sourceSynchSupport = source as IEducationOrganizationCategorySynchronizationSourceSupport;
            var targetSynchSupport = target as IEducationOrganizationCategorySynchronizationSourceSupport;

            // Copy contextual primary key values
            target.EducationOrganizationCategoryType = source.EducationOrganizationCategoryType;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IEducationOrganizationCategorySynchronizationSourceSupport
    {
    }
 
    public static class EducationOrganizationIdentificationCodeMapper 
    {
        public static bool SynchronizeTo(this IEducationOrganizationIdentificationCode source, IEducationOrganizationIdentificationCode target)
        {
            bool isModified = false;

            var sourceSupport = source as IEducationOrganizationIdentificationCodeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.EducationOrganizationIdentificationSystemDescriptor != target.EducationOrganizationIdentificationSystemDescriptor)
            {
                source.EducationOrganizationIdentificationSystemDescriptor = target.EducationOrganizationIdentificationSystemDescriptor;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsIdentificationCodeSupported)
                && target.IdentificationCode != source.IdentificationCode)
            {
                target.IdentificationCode = source.IdentificationCode;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IEducationOrganizationIdentificationCode source, IEducationOrganizationIdentificationCode target, Action<IEducationOrganizationIdentificationCode, IEducationOrganizationIdentificationCode> onMapped)
        {
            var sourceSynchSupport = source as IEducationOrganizationIdentificationCodeSynchronizationSourceSupport;
            var targetSynchSupport = target as IEducationOrganizationIdentificationCodeSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.EducationOrganizationIdentificationSystemDescriptor = source.EducationOrganizationIdentificationSystemDescriptor;

            // Copy non-PK properties

            if (sourceSynchSupport.IsIdentificationCodeSupported)
                target.IdentificationCode = source.IdentificationCode;
            else
                targetSynchSupport.IsIdentificationCodeSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IEducationOrganizationIdentificationCodeSynchronizationSourceSupport
    {
        bool IsIdentificationCodeSupported { get; set; }
    }
 
    public static class EducationOrganizationInstitutionTelephoneMapper 
    {
        public static bool SynchronizeTo(this IEducationOrganizationInstitutionTelephone source, IEducationOrganizationInstitutionTelephone target)
        {
            bool isModified = false;

            var sourceSupport = source as IEducationOrganizationInstitutionTelephoneSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.InstitutionTelephoneNumberType != target.InstitutionTelephoneNumberType)
            {
                source.InstitutionTelephoneNumberType = target.InstitutionTelephoneNumberType;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsTelephoneNumberSupported)
                && target.TelephoneNumber != source.TelephoneNumber)
            {
                target.TelephoneNumber = source.TelephoneNumber;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IEducationOrganizationInstitutionTelephone source, IEducationOrganizationInstitutionTelephone target, Action<IEducationOrganizationInstitutionTelephone, IEducationOrganizationInstitutionTelephone> onMapped)
        {
            var sourceSynchSupport = source as IEducationOrganizationInstitutionTelephoneSynchronizationSourceSupport;
            var targetSynchSupport = target as IEducationOrganizationInstitutionTelephoneSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.InstitutionTelephoneNumberType = source.InstitutionTelephoneNumberType;

            // Copy non-PK properties

            if (sourceSynchSupport.IsTelephoneNumberSupported)
                target.TelephoneNumber = source.TelephoneNumber;
            else
                targetSynchSupport.IsTelephoneNumberSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IEducationOrganizationInstitutionTelephoneSynchronizationSourceSupport
    {
        bool IsTelephoneNumberSupported { get; set; }
    }
 
    public static class EducationOrganizationInternationalAddressMapper 
    {
        public static bool SynchronizeTo(this IEducationOrganizationInternationalAddress source, IEducationOrganizationInternationalAddress target)
        {
            bool isModified = false;

            var sourceSupport = source as IEducationOrganizationInternationalAddressSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AddressType != target.AddressType)
            {
                source.AddressType = target.AddressType;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsAddressLine1Supported)
                && target.AddressLine1 != source.AddressLine1)
            {
                target.AddressLine1 = source.AddressLine1;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsAddressLine2Supported)
                && target.AddressLine2 != source.AddressLine2)
            {
                target.AddressLine2 = source.AddressLine2;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsAddressLine3Supported)
                && target.AddressLine3 != source.AddressLine3)
            {
                target.AddressLine3 = source.AddressLine3;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsAddressLine4Supported)
                && target.AddressLine4 != source.AddressLine4)
            {
                target.AddressLine4 = source.AddressLine4;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsBeginDateSupported)
                && target.BeginDate != source.BeginDate)
            {
                target.BeginDate = source.BeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsCountryDescriptorSupported)
                && target.CountryDescriptor != source.CountryDescriptor)
            {
                target.CountryDescriptor = source.CountryDescriptor;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEndDateSupported)
                && target.EndDate != source.EndDate)
            {
                target.EndDate = source.EndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsLatitudeSupported)
                && target.Latitude != source.Latitude)
            {
                target.Latitude = source.Latitude;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsLongitudeSupported)
                && target.Longitude != source.Longitude)
            {
                target.Longitude = source.Longitude;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IEducationOrganizationInternationalAddress source, IEducationOrganizationInternationalAddress target, Action<IEducationOrganizationInternationalAddress, IEducationOrganizationInternationalAddress> onMapped)
        {
            var sourceSynchSupport = source as IEducationOrganizationInternationalAddressSynchronizationSourceSupport;
            var targetSynchSupport = target as IEducationOrganizationInternationalAddressSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.AddressType = source.AddressType;

            // Copy non-PK properties

            if (sourceSynchSupport.IsAddressLine1Supported)
                target.AddressLine1 = source.AddressLine1;
            else
                targetSynchSupport.IsAddressLine1Supported = false;

            if (sourceSynchSupport.IsAddressLine2Supported)
                target.AddressLine2 = source.AddressLine2;
            else
                targetSynchSupport.IsAddressLine2Supported = false;

            if (sourceSynchSupport.IsAddressLine3Supported)
                target.AddressLine3 = source.AddressLine3;
            else
                targetSynchSupport.IsAddressLine3Supported = false;

            if (sourceSynchSupport.IsAddressLine4Supported)
                target.AddressLine4 = source.AddressLine4;
            else
                targetSynchSupport.IsAddressLine4Supported = false;

            if (sourceSynchSupport.IsBeginDateSupported)
                target.BeginDate = source.BeginDate;
            else
                targetSynchSupport.IsBeginDateSupported = false;

            if (sourceSynchSupport.IsCountryDescriptorSupported)
                target.CountryDescriptor = source.CountryDescriptor;
            else
                targetSynchSupport.IsCountryDescriptorSupported = false;

            if (sourceSynchSupport.IsEndDateSupported)
                target.EndDate = source.EndDate;
            else
                targetSynchSupport.IsEndDateSupported = false;

            if (sourceSynchSupport.IsLatitudeSupported)
                target.Latitude = source.Latitude;
            else
                targetSynchSupport.IsLatitudeSupported = false;

            if (sourceSynchSupport.IsLongitudeSupported)
                target.Longitude = source.Longitude;
            else
                targetSynchSupport.IsLongitudeSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IEducationOrganizationInternationalAddressSynchronizationSourceSupport
    {
        bool IsAddressLine1Supported { get; set; }
        bool IsAddressLine2Supported { get; set; }
        bool IsAddressLine3Supported { get; set; }
        bool IsAddressLine4Supported { get; set; }
        bool IsBeginDateSupported { get; set; }
        bool IsCountryDescriptorSupported { get; set; }
        bool IsEndDateSupported { get; set; }
        bool IsLatitudeSupported { get; set; }
        bool IsLongitudeSupported { get; set; }
    }
 
}
// Aggregate: EducationOrganizationCategoryType

namespace EdFi.Ods.Entities.Common //.EducationOrganizationCategoryTypeAggregate
{ 
    public static class EducationOrganizationCategoryTypeMapper 
    {
        public static bool SynchronizeTo(this IEducationOrganizationCategoryType source, IEducationOrganizationCategoryType target)
        {
            bool isModified = false;

            var sourceSupport = source as IEducationOrganizationCategoryTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.EducationOrganizationCategoryTypeId != target.EducationOrganizationCategoryTypeId)
            {
                source.EducationOrganizationCategoryTypeId = target.EducationOrganizationCategoryTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IEducationOrganizationCategoryType source, IEducationOrganizationCategoryType target, Action<IEducationOrganizationCategoryType, IEducationOrganizationCategoryType> onMapped)
        {
            var sourceSynchSupport = source as IEducationOrganizationCategoryTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IEducationOrganizationCategoryTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.EducationOrganizationCategoryTypeId = source.EducationOrganizationCategoryTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IEducationOrganizationCategoryTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: EducationOrganizationIdentificationSystemDescriptor

namespace EdFi.Ods.Entities.Common //.EducationOrganizationIdentificationSystemDescriptorAggregate
{ 
    public static class EducationOrganizationIdentificationSystemDescriptorMapper 
    {
        public static bool SynchronizeTo(this IEducationOrganizationIdentificationSystemDescriptor source, IEducationOrganizationIdentificationSystemDescriptor target)
        {
            bool isModified = false;

            var sourceSupport = source as IEducationOrganizationIdentificationSystemDescriptorSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.EducationOrganizationIdentificationSystemDescriptorId != target.EducationOrganizationIdentificationSystemDescriptorId)
            {
                source.EducationOrganizationIdentificationSystemDescriptorId = target.EducationOrganizationIdentificationSystemDescriptorId;
            }

            // Copy inherited non-PK properties


            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveBeginDateSupported)
                && target.EffectiveBeginDate != source.EffectiveBeginDate)
            {
                target.EffectiveBeginDate = source.EffectiveBeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveEndDateSupported)
                && target.EffectiveEndDate != source.EffectiveEndDate)
            {
                target.EffectiveEndDate = source.EffectiveEndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNamespaceSupported)
                && target.Namespace != source.Namespace)
            {
                target.Namespace = source.Namespace;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPriorDescriptorIdSupported)
                && target.PriorDescriptorId != source.PriorDescriptorId)
            {
                target.PriorDescriptorId = source.PriorDescriptorId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsEducationOrganizationIdentificationSystemTypeSupported)
                && target.EducationOrganizationIdentificationSystemType != source.EducationOrganizationIdentificationSystemType)
            {
                target.EducationOrganizationIdentificationSystemType = source.EducationOrganizationIdentificationSystemType;
                isModified = true;
            }

            // Synch inherited lists


            // Sync lists

            return isModified;
        }



        public static void MapTo(this IEducationOrganizationIdentificationSystemDescriptor source, IEducationOrganizationIdentificationSystemDescriptor target, Action<IEducationOrganizationIdentificationSystemDescriptor, IEducationOrganizationIdentificationSystemDescriptor> onMapped)
        {
            var sourceSynchSupport = source as IEducationOrganizationIdentificationSystemDescriptorSynchronizationSourceSupport;
            var targetSynchSupport = target as IEducationOrganizationIdentificationSystemDescriptorSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.EducationOrganizationIdentificationSystemDescriptorId = source.EducationOrganizationIdentificationSystemDescriptorId;

            // Copy inherited non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsEffectiveBeginDateSupported)
                target.EffectiveBeginDate = source.EffectiveBeginDate;
            else
                targetSynchSupport.IsEffectiveBeginDateSupported = false;

            if (sourceSynchSupport.IsEffectiveEndDateSupported)
                target.EffectiveEndDate = source.EffectiveEndDate;
            else
                targetSynchSupport.IsEffectiveEndDateSupported = false;

            if (sourceSynchSupport.IsNamespaceSupported)
                target.Namespace = source.Namespace;
            else
                targetSynchSupport.IsNamespaceSupported = false;

            if (sourceSynchSupport.IsPriorDescriptorIdSupported)
                target.PriorDescriptorId = source.PriorDescriptorId;
            else
                targetSynchSupport.IsPriorDescriptorIdSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Copy non-PK properties

            if (sourceSynchSupport.IsEducationOrganizationIdentificationSystemTypeSupported)
                target.EducationOrganizationIdentificationSystemType = source.EducationOrganizationIdentificationSystemType;
            else
                targetSynchSupport.IsEducationOrganizationIdentificationSystemTypeSupported = false;

            // Map inherited lists

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IEducationOrganizationIdentificationSystemDescriptorSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsEducationOrganizationIdentificationSystemTypeSupported { get; set; }
        bool IsEffectiveBeginDateSupported { get; set; }
        bool IsEffectiveEndDateSupported { get; set; }
        bool IsNamespaceSupported { get; set; }
        bool IsPriorDescriptorIdSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: EducationOrganizationIdentificationSystemType

namespace EdFi.Ods.Entities.Common //.EducationOrganizationIdentificationSystemTypeAggregate
{ 
    public static class EducationOrganizationIdentificationSystemTypeMapper 
    {
        public static bool SynchronizeTo(this IEducationOrganizationIdentificationSystemType source, IEducationOrganizationIdentificationSystemType target)
        {
            bool isModified = false;

            var sourceSupport = source as IEducationOrganizationIdentificationSystemTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.EducationOrganizationIdentificationSystemTypeId != target.EducationOrganizationIdentificationSystemTypeId)
            {
                source.EducationOrganizationIdentificationSystemTypeId = target.EducationOrganizationIdentificationSystemTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IEducationOrganizationIdentificationSystemType source, IEducationOrganizationIdentificationSystemType target, Action<IEducationOrganizationIdentificationSystemType, IEducationOrganizationIdentificationSystemType> onMapped)
        {
            var sourceSynchSupport = source as IEducationOrganizationIdentificationSystemTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IEducationOrganizationIdentificationSystemTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.EducationOrganizationIdentificationSystemTypeId = source.EducationOrganizationIdentificationSystemTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IEducationOrganizationIdentificationSystemTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: EducationOrganizationInterventionPrescriptionAssociation

namespace EdFi.Ods.Entities.Common //.EducationOrganizationInterventionPrescriptionAssociationAggregate
{ 
    public static class EducationOrganizationInterventionPrescriptionAssociationMapper 
    {
        public static bool SynchronizeTo(this IEducationOrganizationInterventionPrescriptionAssociation source, IEducationOrganizationInterventionPrescriptionAssociation target)
        {
            bool isModified = false;

            var sourceSupport = source as IEducationOrganizationInterventionPrescriptionAssociationSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.EducationOrganizationId != target.EducationOrganizationId)
            {
                source.EducationOrganizationId = target.EducationOrganizationId;
            }
            if (source.InterventionPrescriptionEducationOrganizationId != target.InterventionPrescriptionEducationOrganizationId)
            {
                source.InterventionPrescriptionEducationOrganizationId = target.InterventionPrescriptionEducationOrganizationId;
            }
            if (source.InterventionPrescriptionIdentificationCode != target.InterventionPrescriptionIdentificationCode)
            {
                source.InterventionPrescriptionIdentificationCode = target.InterventionPrescriptionIdentificationCode;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsBeginDateSupported)
                && target.BeginDate != source.BeginDate)
            {
                target.BeginDate = source.BeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEndDateSupported)
                && target.EndDate != source.EndDate)
            {
                target.EndDate = source.EndDate;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IEducationOrganizationInterventionPrescriptionAssociation source, IEducationOrganizationInterventionPrescriptionAssociation target, Action<IEducationOrganizationInterventionPrescriptionAssociation, IEducationOrganizationInterventionPrescriptionAssociation> onMapped)
        {
            var sourceSynchSupport = source as IEducationOrganizationInterventionPrescriptionAssociationSynchronizationSourceSupport;
            var targetSynchSupport = target as IEducationOrganizationInterventionPrescriptionAssociationSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.EducationOrganizationId = source.EducationOrganizationId;
            target.InterventionPrescriptionEducationOrganizationId = source.InterventionPrescriptionEducationOrganizationId;
            target.InterventionPrescriptionIdentificationCode = source.InterventionPrescriptionIdentificationCode;

            // Copy non-PK properties

            if (sourceSynchSupport.IsBeginDateSupported)
                target.BeginDate = source.BeginDate;
            else
                targetSynchSupport.IsBeginDateSupported = false;

            if (sourceSynchSupport.IsEndDateSupported)
                target.EndDate = source.EndDate;
            else
                targetSynchSupport.IsEndDateSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IEducationOrganizationInterventionPrescriptionAssociationSynchronizationSourceSupport
    {
        bool IsBeginDateSupported { get; set; }
        bool IsEndDateSupported { get; set; }
    }
 
}
// Aggregate: EducationOrganizationNetwork

namespace EdFi.Ods.Entities.Common //.EducationOrganizationNetworkAggregate
{ 
    public static class EducationOrganizationNetworkMapper 
    {
        public static bool SynchronizeTo(this IEducationOrganizationNetwork source, IEducationOrganizationNetwork target)
        {
            bool isModified = false;

            var sourceSupport = source as IEducationOrganizationNetworkSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.EducationOrganizationNetworkId != target.EducationOrganizationNetworkId)
            {
                source.EducationOrganizationNetworkId = target.EducationOrganizationNetworkId;
            }

            // Copy inherited non-PK properties


            if ((sourceSupport == null || sourceSupport.IsNameOfInstitutionSupported)
                && target.NameOfInstitution != source.NameOfInstitution)
            {
                target.NameOfInstitution = source.NameOfInstitution;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsOperationalStatusTypeSupported)
                && target.OperationalStatusType != source.OperationalStatusType)
            {
                target.OperationalStatusType = source.OperationalStatusType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortNameOfInstitutionSupported)
                && target.ShortNameOfInstitution != source.ShortNameOfInstitution)
            {
                target.ShortNameOfInstitution = source.ShortNameOfInstitution;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsStateOrganizationIdSupported)
                && target.StateOrganizationId != source.StateOrganizationId)
            {
                target.StateOrganizationId = source.StateOrganizationId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsWebSiteSupported)
                && target.WebSite != source.WebSite)
            {
                target.WebSite = source.WebSite;
                isModified = true;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsNetworkPurposeTypeSupported)
                && target.NetworkPurposeType != source.NetworkPurposeType)
            {
                target.NetworkPurposeType = source.NetworkPurposeType;
                isModified = true;
            }

            // Synch inherited lists
            if (sourceSupport == null || sourceSupport.IsEducationOrganizationAddressesSupported)
                isModified |= source.EducationOrganizationAddresses.SynchronizeListTo(target.EducationOrganizationAddresses, child => child.EducationOrganization = target,
                                sourceSupport == null ? null : sourceSupport.IsEducationOrganizationAddressIncluded);

            if (sourceSupport == null || sourceSupport.IsEducationOrganizationCategoriesSupported)
                isModified |= source.EducationOrganizationCategories.SynchronizeListTo(target.EducationOrganizationCategories, child => child.EducationOrganization = target,
                                sourceSupport == null ? null : sourceSupport.IsEducationOrganizationCategoryIncluded);

            if (sourceSupport == null || sourceSupport.IsEducationOrganizationIdentificationCodesSupported)
                isModified |= source.EducationOrganizationIdentificationCodes.SynchronizeListTo(target.EducationOrganizationIdentificationCodes, child => child.EducationOrganization = target,
                                sourceSupport == null ? null : sourceSupport.IsEducationOrganizationIdentificationCodeIncluded);

            if (sourceSupport == null || sourceSupport.IsEducationOrganizationInstitutionTelephonesSupported)
                isModified |= source.EducationOrganizationInstitutionTelephones.SynchronizeListTo(target.EducationOrganizationInstitutionTelephones, child => child.EducationOrganization = target,
                                sourceSupport == null ? null : sourceSupport.IsEducationOrganizationInstitutionTelephoneIncluded);

            if (sourceSupport == null || sourceSupport.IsEducationOrganizationInternationalAddressesSupported)
                isModified |= source.EducationOrganizationInternationalAddresses.SynchronizeListTo(target.EducationOrganizationInternationalAddresses, child => child.EducationOrganization = target,
                                sourceSupport == null ? null : sourceSupport.IsEducationOrganizationInternationalAddressIncluded);



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IEducationOrganizationNetwork source, IEducationOrganizationNetwork target, Action<IEducationOrganizationNetwork, IEducationOrganizationNetwork> onMapped)
        {
            var sourceSynchSupport = source as IEducationOrganizationNetworkSynchronizationSourceSupport;
            var targetSynchSupport = target as IEducationOrganizationNetworkSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.EducationOrganizationNetworkId = source.EducationOrganizationNetworkId;

            // Copy inherited non-PK properties

            if (sourceSynchSupport.IsNameOfInstitutionSupported)
                target.NameOfInstitution = source.NameOfInstitution;
            else
                targetSynchSupport.IsNameOfInstitutionSupported = false;

            if (sourceSynchSupport.IsOperationalStatusTypeSupported)
                target.OperationalStatusType = source.OperationalStatusType;
            else
                targetSynchSupport.IsOperationalStatusTypeSupported = false;

            if (sourceSynchSupport.IsShortNameOfInstitutionSupported)
                target.ShortNameOfInstitution = source.ShortNameOfInstitution;
            else
                targetSynchSupport.IsShortNameOfInstitutionSupported = false;

            if (sourceSynchSupport.IsStateOrganizationIdSupported)
                target.StateOrganizationId = source.StateOrganizationId;
            else
                targetSynchSupport.IsStateOrganizationIdSupported = false;

            if (sourceSynchSupport.IsWebSiteSupported)
                target.WebSite = source.WebSite;
            else
                targetSynchSupport.IsWebSiteSupported = false;

            // Copy non-PK properties

            if (sourceSynchSupport.IsNetworkPurposeTypeSupported)
                target.NetworkPurposeType = source.NetworkPurposeType;
            else
                targetSynchSupport.IsNetworkPurposeTypeSupported = false;

            // Map inherited lists

            if (sourceSynchSupport.IsEducationOrganizationAddressesSupported)
            {
                targetSynchSupport.IsEducationOrganizationAddressIncluded = sourceSynchSupport.IsEducationOrganizationAddressIncluded;
                source.EducationOrganizationAddresses.MapListTo(target.EducationOrganizationAddresses);
            }
            else
            {
                targetSynchSupport.IsEducationOrganizationAddressesSupported = false;
            }

            if (sourceSynchSupport.IsEducationOrganizationCategoriesSupported)
            {
                targetSynchSupport.IsEducationOrganizationCategoryIncluded = sourceSynchSupport.IsEducationOrganizationCategoryIncluded;
                source.EducationOrganizationCategories.MapListTo(target.EducationOrganizationCategories);
            }
            else
            {
                targetSynchSupport.IsEducationOrganizationCategoriesSupported = false;
            }

            if (sourceSynchSupport.IsEducationOrganizationIdentificationCodesSupported)
            {
                targetSynchSupport.IsEducationOrganizationIdentificationCodeIncluded = sourceSynchSupport.IsEducationOrganizationIdentificationCodeIncluded;
                source.EducationOrganizationIdentificationCodes.MapListTo(target.EducationOrganizationIdentificationCodes);
            }
            else
            {
                targetSynchSupport.IsEducationOrganizationIdentificationCodesSupported = false;
            }

            if (sourceSynchSupport.IsEducationOrganizationInstitutionTelephonesSupported)
            {
                targetSynchSupport.IsEducationOrganizationInstitutionTelephoneIncluded = sourceSynchSupport.IsEducationOrganizationInstitutionTelephoneIncluded;
                source.EducationOrganizationInstitutionTelephones.MapListTo(target.EducationOrganizationInstitutionTelephones);
            }
            else
            {
                targetSynchSupport.IsEducationOrganizationInstitutionTelephonesSupported = false;
            }

            if (sourceSynchSupport.IsEducationOrganizationInternationalAddressesSupported)
            {
                targetSynchSupport.IsEducationOrganizationInternationalAddressIncluded = sourceSynchSupport.IsEducationOrganizationInternationalAddressIncluded;
                source.EducationOrganizationInternationalAddresses.MapListTo(target.EducationOrganizationInternationalAddresses);
            }
            else
            {
                targetSynchSupport.IsEducationOrganizationInternationalAddressesSupported = false;
            }

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IEducationOrganizationNetworkSynchronizationSourceSupport
    {
        bool IsEducationOrganizationAddressesSupported { get; set; }
        bool IsEducationOrganizationCategoriesSupported { get; set; }
        bool IsEducationOrganizationIdentificationCodesSupported { get; set; }
        bool IsEducationOrganizationInstitutionTelephonesSupported { get; set; }
        bool IsEducationOrganizationInternationalAddressesSupported { get; set; }
        bool IsNameOfInstitutionSupported { get; set; }
        bool IsNetworkPurposeTypeSupported { get; set; }
        bool IsOperationalStatusTypeSupported { get; set; }
        bool IsShortNameOfInstitutionSupported { get; set; }
        bool IsStateOrganizationIdSupported { get; set; }
        bool IsWebSiteSupported { get; set; }
        Func<IEducationOrganizationAddress, bool> IsEducationOrganizationAddressIncluded { get; set; }
        Func<IEducationOrganizationCategory, bool> IsEducationOrganizationCategoryIncluded { get; set; }
        Func<IEducationOrganizationIdentificationCode, bool> IsEducationOrganizationIdentificationCodeIncluded { get; set; }
        Func<IEducationOrganizationInstitutionTelephone, bool> IsEducationOrganizationInstitutionTelephoneIncluded { get; set; }
        Func<IEducationOrganizationInternationalAddress, bool> IsEducationOrganizationInternationalAddressIncluded { get; set; }
    }
 
}
// Aggregate: EducationOrganizationNetworkAssociation

namespace EdFi.Ods.Entities.Common //.EducationOrganizationNetworkAssociationAggregate
{ 
    public static class EducationOrganizationNetworkAssociationMapper 
    {
        public static bool SynchronizeTo(this IEducationOrganizationNetworkAssociation source, IEducationOrganizationNetworkAssociation target)
        {
            bool isModified = false;

            var sourceSupport = source as IEducationOrganizationNetworkAssociationSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.EducationOrganizationNetworkId != target.EducationOrganizationNetworkId)
            {
                source.EducationOrganizationNetworkId = target.EducationOrganizationNetworkId;
            }
            if (source.MemberEducationOrganizationId != target.MemberEducationOrganizationId)
            {
                source.MemberEducationOrganizationId = target.MemberEducationOrganizationId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsBeginDateSupported)
                && target.BeginDate != source.BeginDate)
            {
                target.BeginDate = source.BeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEndDateSupported)
                && target.EndDate != source.EndDate)
            {
                target.EndDate = source.EndDate;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IEducationOrganizationNetworkAssociation source, IEducationOrganizationNetworkAssociation target, Action<IEducationOrganizationNetworkAssociation, IEducationOrganizationNetworkAssociation> onMapped)
        {
            var sourceSynchSupport = source as IEducationOrganizationNetworkAssociationSynchronizationSourceSupport;
            var targetSynchSupport = target as IEducationOrganizationNetworkAssociationSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.EducationOrganizationNetworkId = source.EducationOrganizationNetworkId;
            target.MemberEducationOrganizationId = source.MemberEducationOrganizationId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsBeginDateSupported)
                target.BeginDate = source.BeginDate;
            else
                targetSynchSupport.IsBeginDateSupported = false;

            if (sourceSynchSupport.IsEndDateSupported)
                target.EndDate = source.EndDate;
            else
                targetSynchSupport.IsEndDateSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IEducationOrganizationNetworkAssociationSynchronizationSourceSupport
    {
        bool IsBeginDateSupported { get; set; }
        bool IsEndDateSupported { get; set; }
    }
 
}
// Aggregate: EducationOrganizationPeerAssociation

namespace EdFi.Ods.Entities.Common //.EducationOrganizationPeerAssociationAggregate
{ 
    public static class EducationOrganizationPeerAssociationMapper 
    {
        public static bool SynchronizeTo(this IEducationOrganizationPeerAssociation source, IEducationOrganizationPeerAssociation target)
        {
            bool isModified = false;

            var sourceSupport = source as IEducationOrganizationPeerAssociationSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.EducationOrganizationId != target.EducationOrganizationId)
            {
                source.EducationOrganizationId = target.EducationOrganizationId;
            }
            if (source.PeerEducationOrganizationId != target.PeerEducationOrganizationId)
            {
                source.PeerEducationOrganizationId = target.PeerEducationOrganizationId;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IEducationOrganizationPeerAssociation source, IEducationOrganizationPeerAssociation target, Action<IEducationOrganizationPeerAssociation, IEducationOrganizationPeerAssociation> onMapped)
        {
            var sourceSynchSupport = source as IEducationOrganizationPeerAssociationSynchronizationSourceSupport;
            var targetSynchSupport = target as IEducationOrganizationPeerAssociationSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.EducationOrganizationId = source.EducationOrganizationId;
            target.PeerEducationOrganizationId = source.PeerEducationOrganizationId;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IEducationOrganizationPeerAssociationSynchronizationSourceSupport
    {
    }
 
}
// Aggregate: EducationPlanType

namespace EdFi.Ods.Entities.Common //.EducationPlanTypeAggregate
{ 
    public static class EducationPlanTypeMapper 
    {
        public static bool SynchronizeTo(this IEducationPlanType source, IEducationPlanType target)
        {
            bool isModified = false;

            var sourceSupport = source as IEducationPlanTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.EducationPlanTypeId != target.EducationPlanTypeId)
            {
                source.EducationPlanTypeId = target.EducationPlanTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IEducationPlanType source, IEducationPlanType target, Action<IEducationPlanType, IEducationPlanType> onMapped)
        {
            var sourceSynchSupport = source as IEducationPlanTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IEducationPlanTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.EducationPlanTypeId = source.EducationPlanTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IEducationPlanTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: EducationServiceCenter

namespace EdFi.Ods.Entities.Common //.EducationServiceCenterAggregate
{ 
    public static class EducationServiceCenterMapper 
    {
        public static bool SynchronizeTo(this IEducationServiceCenter source, IEducationServiceCenter target)
        {
            bool isModified = false;

            var sourceSupport = source as IEducationServiceCenterSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.EducationServiceCenterId != target.EducationServiceCenterId)
            {
                source.EducationServiceCenterId = target.EducationServiceCenterId;
            }

            // Copy inherited non-PK properties


            if ((sourceSupport == null || sourceSupport.IsNameOfInstitutionSupported)
                && target.NameOfInstitution != source.NameOfInstitution)
            {
                target.NameOfInstitution = source.NameOfInstitution;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsOperationalStatusTypeSupported)
                && target.OperationalStatusType != source.OperationalStatusType)
            {
                target.OperationalStatusType = source.OperationalStatusType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortNameOfInstitutionSupported)
                && target.ShortNameOfInstitution != source.ShortNameOfInstitution)
            {
                target.ShortNameOfInstitution = source.ShortNameOfInstitution;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsStateOrganizationIdSupported)
                && target.StateOrganizationId != source.StateOrganizationId)
            {
                target.StateOrganizationId = source.StateOrganizationId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsWebSiteSupported)
                && target.WebSite != source.WebSite)
            {
                target.WebSite = source.WebSite;
                isModified = true;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsStateEducationAgencyIdSupported)
                && target.StateEducationAgencyId != source.StateEducationAgencyId)
            {
                target.StateEducationAgencyId = source.StateEducationAgencyId;
                isModified = true;
            }

            // Synch inherited lists
            if (sourceSupport == null || sourceSupport.IsEducationOrganizationAddressesSupported)
                isModified |= source.EducationOrganizationAddresses.SynchronizeListTo(target.EducationOrganizationAddresses, child => child.EducationOrganization = target,
                                sourceSupport == null ? null : sourceSupport.IsEducationOrganizationAddressIncluded);

            if (sourceSupport == null || sourceSupport.IsEducationOrganizationCategoriesSupported)
                isModified |= source.EducationOrganizationCategories.SynchronizeListTo(target.EducationOrganizationCategories, child => child.EducationOrganization = target,
                                sourceSupport == null ? null : sourceSupport.IsEducationOrganizationCategoryIncluded);

            if (sourceSupport == null || sourceSupport.IsEducationOrganizationIdentificationCodesSupported)
                isModified |= source.EducationOrganizationIdentificationCodes.SynchronizeListTo(target.EducationOrganizationIdentificationCodes, child => child.EducationOrganization = target,
                                sourceSupport == null ? null : sourceSupport.IsEducationOrganizationIdentificationCodeIncluded);

            if (sourceSupport == null || sourceSupport.IsEducationOrganizationInstitutionTelephonesSupported)
                isModified |= source.EducationOrganizationInstitutionTelephones.SynchronizeListTo(target.EducationOrganizationInstitutionTelephones, child => child.EducationOrganization = target,
                                sourceSupport == null ? null : sourceSupport.IsEducationOrganizationInstitutionTelephoneIncluded);

            if (sourceSupport == null || sourceSupport.IsEducationOrganizationInternationalAddressesSupported)
                isModified |= source.EducationOrganizationInternationalAddresses.SynchronizeListTo(target.EducationOrganizationInternationalAddresses, child => child.EducationOrganization = target,
                                sourceSupport == null ? null : sourceSupport.IsEducationOrganizationInternationalAddressIncluded);



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IEducationServiceCenter source, IEducationServiceCenter target, Action<IEducationServiceCenter, IEducationServiceCenter> onMapped)
        {
            var sourceSynchSupport = source as IEducationServiceCenterSynchronizationSourceSupport;
            var targetSynchSupport = target as IEducationServiceCenterSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.EducationServiceCenterId = source.EducationServiceCenterId;

            // Copy inherited non-PK properties

            if (sourceSynchSupport.IsNameOfInstitutionSupported)
                target.NameOfInstitution = source.NameOfInstitution;
            else
                targetSynchSupport.IsNameOfInstitutionSupported = false;

            if (sourceSynchSupport.IsOperationalStatusTypeSupported)
                target.OperationalStatusType = source.OperationalStatusType;
            else
                targetSynchSupport.IsOperationalStatusTypeSupported = false;

            if (sourceSynchSupport.IsShortNameOfInstitutionSupported)
                target.ShortNameOfInstitution = source.ShortNameOfInstitution;
            else
                targetSynchSupport.IsShortNameOfInstitutionSupported = false;

            if (sourceSynchSupport.IsStateOrganizationIdSupported)
                target.StateOrganizationId = source.StateOrganizationId;
            else
                targetSynchSupport.IsStateOrganizationIdSupported = false;

            if (sourceSynchSupport.IsWebSiteSupported)
                target.WebSite = source.WebSite;
            else
                targetSynchSupport.IsWebSiteSupported = false;

            // Copy non-PK properties

            if (sourceSynchSupport.IsStateEducationAgencyIdSupported)
                target.StateEducationAgencyId = source.StateEducationAgencyId;
            else
                targetSynchSupport.IsStateEducationAgencyIdSupported = false;

            // Map inherited lists

            if (sourceSynchSupport.IsEducationOrganizationAddressesSupported)
            {
                targetSynchSupport.IsEducationOrganizationAddressIncluded = sourceSynchSupport.IsEducationOrganizationAddressIncluded;
                source.EducationOrganizationAddresses.MapListTo(target.EducationOrganizationAddresses);
            }
            else
            {
                targetSynchSupport.IsEducationOrganizationAddressesSupported = false;
            }

            if (sourceSynchSupport.IsEducationOrganizationCategoriesSupported)
            {
                targetSynchSupport.IsEducationOrganizationCategoryIncluded = sourceSynchSupport.IsEducationOrganizationCategoryIncluded;
                source.EducationOrganizationCategories.MapListTo(target.EducationOrganizationCategories);
            }
            else
            {
                targetSynchSupport.IsEducationOrganizationCategoriesSupported = false;
            }

            if (sourceSynchSupport.IsEducationOrganizationIdentificationCodesSupported)
            {
                targetSynchSupport.IsEducationOrganizationIdentificationCodeIncluded = sourceSynchSupport.IsEducationOrganizationIdentificationCodeIncluded;
                source.EducationOrganizationIdentificationCodes.MapListTo(target.EducationOrganizationIdentificationCodes);
            }
            else
            {
                targetSynchSupport.IsEducationOrganizationIdentificationCodesSupported = false;
            }

            if (sourceSynchSupport.IsEducationOrganizationInstitutionTelephonesSupported)
            {
                targetSynchSupport.IsEducationOrganizationInstitutionTelephoneIncluded = sourceSynchSupport.IsEducationOrganizationInstitutionTelephoneIncluded;
                source.EducationOrganizationInstitutionTelephones.MapListTo(target.EducationOrganizationInstitutionTelephones);
            }
            else
            {
                targetSynchSupport.IsEducationOrganizationInstitutionTelephonesSupported = false;
            }

            if (sourceSynchSupport.IsEducationOrganizationInternationalAddressesSupported)
            {
                targetSynchSupport.IsEducationOrganizationInternationalAddressIncluded = sourceSynchSupport.IsEducationOrganizationInternationalAddressIncluded;
                source.EducationOrganizationInternationalAddresses.MapListTo(target.EducationOrganizationInternationalAddresses);
            }
            else
            {
                targetSynchSupport.IsEducationOrganizationInternationalAddressesSupported = false;
            }

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IEducationServiceCenterSynchronizationSourceSupport
    {
        bool IsEducationOrganizationAddressesSupported { get; set; }
        bool IsEducationOrganizationCategoriesSupported { get; set; }
        bool IsEducationOrganizationIdentificationCodesSupported { get; set; }
        bool IsEducationOrganizationInstitutionTelephonesSupported { get; set; }
        bool IsEducationOrganizationInternationalAddressesSupported { get; set; }
        bool IsNameOfInstitutionSupported { get; set; }
        bool IsOperationalStatusTypeSupported { get; set; }
        bool IsShortNameOfInstitutionSupported { get; set; }
        bool IsStateEducationAgencyIdSupported { get; set; }
        bool IsStateOrganizationIdSupported { get; set; }
        bool IsWebSiteSupported { get; set; }
        Func<IEducationOrganizationAddress, bool> IsEducationOrganizationAddressIncluded { get; set; }
        Func<IEducationOrganizationCategory, bool> IsEducationOrganizationCategoryIncluded { get; set; }
        Func<IEducationOrganizationIdentificationCode, bool> IsEducationOrganizationIdentificationCodeIncluded { get; set; }
        Func<IEducationOrganizationInstitutionTelephone, bool> IsEducationOrganizationInstitutionTelephoneIncluded { get; set; }
        Func<IEducationOrganizationInternationalAddress, bool> IsEducationOrganizationInternationalAddressIncluded { get; set; }
    }
 
}
// Aggregate: ElectronicMailType

namespace EdFi.Ods.Entities.Common //.ElectronicMailTypeAggregate
{ 
    public static class ElectronicMailTypeMapper 
    {
        public static bool SynchronizeTo(this IElectronicMailType source, IElectronicMailType target)
        {
            bool isModified = false;

            var sourceSupport = source as IElectronicMailTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.ElectronicMailTypeId != target.ElectronicMailTypeId)
            {
                source.ElectronicMailTypeId = target.ElectronicMailTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IElectronicMailType source, IElectronicMailType target, Action<IElectronicMailType, IElectronicMailType> onMapped)
        {
            var sourceSynchSupport = source as IElectronicMailTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IElectronicMailTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.ElectronicMailTypeId = source.ElectronicMailTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IElectronicMailTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: EmploymentStatusDescriptor

namespace EdFi.Ods.Entities.Common //.EmploymentStatusDescriptorAggregate
{ 
    public static class EmploymentStatusDescriptorMapper 
    {
        public static bool SynchronizeTo(this IEmploymentStatusDescriptor source, IEmploymentStatusDescriptor target)
        {
            bool isModified = false;

            var sourceSupport = source as IEmploymentStatusDescriptorSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.EmploymentStatusDescriptorId != target.EmploymentStatusDescriptorId)
            {
                source.EmploymentStatusDescriptorId = target.EmploymentStatusDescriptorId;
            }

            // Copy inherited non-PK properties


            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveBeginDateSupported)
                && target.EffectiveBeginDate != source.EffectiveBeginDate)
            {
                target.EffectiveBeginDate = source.EffectiveBeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveEndDateSupported)
                && target.EffectiveEndDate != source.EffectiveEndDate)
            {
                target.EffectiveEndDate = source.EffectiveEndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNamespaceSupported)
                && target.Namespace != source.Namespace)
            {
                target.Namespace = source.Namespace;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPriorDescriptorIdSupported)
                && target.PriorDescriptorId != source.PriorDescriptorId)
            {
                target.PriorDescriptorId = source.PriorDescriptorId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsEmploymentStatusTypeSupported)
                && target.EmploymentStatusType != source.EmploymentStatusType)
            {
                target.EmploymentStatusType = source.EmploymentStatusType;
                isModified = true;
            }

            // Synch inherited lists


            // Sync lists

            return isModified;
        }



        public static void MapTo(this IEmploymentStatusDescriptor source, IEmploymentStatusDescriptor target, Action<IEmploymentStatusDescriptor, IEmploymentStatusDescriptor> onMapped)
        {
            var sourceSynchSupport = source as IEmploymentStatusDescriptorSynchronizationSourceSupport;
            var targetSynchSupport = target as IEmploymentStatusDescriptorSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.EmploymentStatusDescriptorId = source.EmploymentStatusDescriptorId;

            // Copy inherited non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsEffectiveBeginDateSupported)
                target.EffectiveBeginDate = source.EffectiveBeginDate;
            else
                targetSynchSupport.IsEffectiveBeginDateSupported = false;

            if (sourceSynchSupport.IsEffectiveEndDateSupported)
                target.EffectiveEndDate = source.EffectiveEndDate;
            else
                targetSynchSupport.IsEffectiveEndDateSupported = false;

            if (sourceSynchSupport.IsNamespaceSupported)
                target.Namespace = source.Namespace;
            else
                targetSynchSupport.IsNamespaceSupported = false;

            if (sourceSynchSupport.IsPriorDescriptorIdSupported)
                target.PriorDescriptorId = source.PriorDescriptorId;
            else
                targetSynchSupport.IsPriorDescriptorIdSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Copy non-PK properties

            if (sourceSynchSupport.IsEmploymentStatusTypeSupported)
                target.EmploymentStatusType = source.EmploymentStatusType;
            else
                targetSynchSupport.IsEmploymentStatusTypeSupported = false;

            // Map inherited lists

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IEmploymentStatusDescriptorSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsEffectiveBeginDateSupported { get; set; }
        bool IsEffectiveEndDateSupported { get; set; }
        bool IsEmploymentStatusTypeSupported { get; set; }
        bool IsNamespaceSupported { get; set; }
        bool IsPriorDescriptorIdSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: EmploymentStatusType

namespace EdFi.Ods.Entities.Common //.EmploymentStatusTypeAggregate
{ 
    public static class EmploymentStatusTypeMapper 
    {
        public static bool SynchronizeTo(this IEmploymentStatusType source, IEmploymentStatusType target)
        {
            bool isModified = false;

            var sourceSupport = source as IEmploymentStatusTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.EmploymentStatusTypeId != target.EmploymentStatusTypeId)
            {
                source.EmploymentStatusTypeId = target.EmploymentStatusTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IEmploymentStatusType source, IEmploymentStatusType target, Action<IEmploymentStatusType, IEmploymentStatusType> onMapped)
        {
            var sourceSynchSupport = source as IEmploymentStatusTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IEmploymentStatusTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.EmploymentStatusTypeId = source.EmploymentStatusTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IEmploymentStatusTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: EntryGradeLevelReasonType

namespace EdFi.Ods.Entities.Common //.EntryGradeLevelReasonTypeAggregate
{ 
    public static class EntryGradeLevelReasonTypeMapper 
    {
        public static bool SynchronizeTo(this IEntryGradeLevelReasonType source, IEntryGradeLevelReasonType target)
        {
            bool isModified = false;

            var sourceSupport = source as IEntryGradeLevelReasonTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.EntryGradeLevelReasonTypeId != target.EntryGradeLevelReasonTypeId)
            {
                source.EntryGradeLevelReasonTypeId = target.EntryGradeLevelReasonTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IEntryGradeLevelReasonType source, IEntryGradeLevelReasonType target, Action<IEntryGradeLevelReasonType, IEntryGradeLevelReasonType> onMapped)
        {
            var sourceSynchSupport = source as IEntryGradeLevelReasonTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IEntryGradeLevelReasonTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.EntryGradeLevelReasonTypeId = source.EntryGradeLevelReasonTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IEntryGradeLevelReasonTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: EntryType

namespace EdFi.Ods.Entities.Common //.EntryTypeAggregate
{ 
    public static class EntryTypeMapper 
    {
        public static bool SynchronizeTo(this IEntryType source, IEntryType target)
        {
            bool isModified = false;

            var sourceSupport = source as IEntryTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.EntryTypeId != target.EntryTypeId)
            {
                source.EntryTypeId = target.EntryTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IEntryType source, IEntryType target, Action<IEntryType, IEntryType> onMapped)
        {
            var sourceSynchSupport = source as IEntryTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IEntryTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.EntryTypeId = source.EntryTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IEntryTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: EntryTypeDescriptor

namespace EdFi.Ods.Entities.Common //.EntryTypeDescriptorAggregate
{ 
    public static class EntryTypeDescriptorMapper 
    {
        public static bool SynchronizeTo(this IEntryTypeDescriptor source, IEntryTypeDescriptor target)
        {
            bool isModified = false;

            var sourceSupport = source as IEntryTypeDescriptorSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.EntryTypeDescriptorId != target.EntryTypeDescriptorId)
            {
                source.EntryTypeDescriptorId = target.EntryTypeDescriptorId;
            }

            // Copy inherited non-PK properties


            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveBeginDateSupported)
                && target.EffectiveBeginDate != source.EffectiveBeginDate)
            {
                target.EffectiveBeginDate = source.EffectiveBeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveEndDateSupported)
                && target.EffectiveEndDate != source.EffectiveEndDate)
            {
                target.EffectiveEndDate = source.EffectiveEndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNamespaceSupported)
                && target.Namespace != source.Namespace)
            {
                target.Namespace = source.Namespace;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPriorDescriptorIdSupported)
                && target.PriorDescriptorId != source.PriorDescriptorId)
            {
                target.PriorDescriptorId = source.PriorDescriptorId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsEntryTypeSupported)
                && target.EntryType != source.EntryType)
            {
                target.EntryType = source.EntryType;
                isModified = true;
            }

            // Synch inherited lists


            // Sync lists

            return isModified;
        }



        public static void MapTo(this IEntryTypeDescriptor source, IEntryTypeDescriptor target, Action<IEntryTypeDescriptor, IEntryTypeDescriptor> onMapped)
        {
            var sourceSynchSupport = source as IEntryTypeDescriptorSynchronizationSourceSupport;
            var targetSynchSupport = target as IEntryTypeDescriptorSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.EntryTypeDescriptorId = source.EntryTypeDescriptorId;

            // Copy inherited non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsEffectiveBeginDateSupported)
                target.EffectiveBeginDate = source.EffectiveBeginDate;
            else
                targetSynchSupport.IsEffectiveBeginDateSupported = false;

            if (sourceSynchSupport.IsEffectiveEndDateSupported)
                target.EffectiveEndDate = source.EffectiveEndDate;
            else
                targetSynchSupport.IsEffectiveEndDateSupported = false;

            if (sourceSynchSupport.IsNamespaceSupported)
                target.Namespace = source.Namespace;
            else
                targetSynchSupport.IsNamespaceSupported = false;

            if (sourceSynchSupport.IsPriorDescriptorIdSupported)
                target.PriorDescriptorId = source.PriorDescriptorId;
            else
                targetSynchSupport.IsPriorDescriptorIdSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Copy non-PK properties

            if (sourceSynchSupport.IsEntryTypeSupported)
                target.EntryType = source.EntryType;
            else
                targetSynchSupport.IsEntryTypeSupported = false;

            // Map inherited lists

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IEntryTypeDescriptorSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsEffectiveBeginDateSupported { get; set; }
        bool IsEffectiveEndDateSupported { get; set; }
        bool IsEntryTypeSupported { get; set; }
        bool IsNamespaceSupported { get; set; }
        bool IsPriorDescriptorIdSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: EventCircumstanceType

namespace EdFi.Ods.Entities.Common //.EventCircumstanceTypeAggregate
{ 
    public static class EventCircumstanceTypeMapper 
    {
        public static bool SynchronizeTo(this IEventCircumstanceType source, IEventCircumstanceType target)
        {
            bool isModified = false;

            var sourceSupport = source as IEventCircumstanceTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.EventCircumstanceTypeId != target.EventCircumstanceTypeId)
            {
                source.EventCircumstanceTypeId = target.EventCircumstanceTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IEventCircumstanceType source, IEventCircumstanceType target, Action<IEventCircumstanceType, IEventCircumstanceType> onMapped)
        {
            var sourceSynchSupport = source as IEventCircumstanceTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IEventCircumstanceTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.EventCircumstanceTypeId = source.EventCircumstanceTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IEventCircumstanceTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: ExitWithdrawType

namespace EdFi.Ods.Entities.Common //.ExitWithdrawTypeAggregate
{ 
    public static class ExitWithdrawTypeMapper 
    {
        public static bool SynchronizeTo(this IExitWithdrawType source, IExitWithdrawType target)
        {
            bool isModified = false;

            var sourceSupport = source as IExitWithdrawTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.ExitWithdrawTypeId != target.ExitWithdrawTypeId)
            {
                source.ExitWithdrawTypeId = target.ExitWithdrawTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IExitWithdrawType source, IExitWithdrawType target, Action<IExitWithdrawType, IExitWithdrawType> onMapped)
        {
            var sourceSynchSupport = source as IExitWithdrawTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IExitWithdrawTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.ExitWithdrawTypeId = source.ExitWithdrawTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IExitWithdrawTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: ExitWithdrawTypeDescriptor

namespace EdFi.Ods.Entities.Common //.ExitWithdrawTypeDescriptorAggregate
{ 
    public static class ExitWithdrawTypeDescriptorMapper 
    {
        public static bool SynchronizeTo(this IExitWithdrawTypeDescriptor source, IExitWithdrawTypeDescriptor target)
        {
            bool isModified = false;

            var sourceSupport = source as IExitWithdrawTypeDescriptorSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.ExitWithdrawTypeDescriptorId != target.ExitWithdrawTypeDescriptorId)
            {
                source.ExitWithdrawTypeDescriptorId = target.ExitWithdrawTypeDescriptorId;
            }

            // Copy inherited non-PK properties


            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveBeginDateSupported)
                && target.EffectiveBeginDate != source.EffectiveBeginDate)
            {
                target.EffectiveBeginDate = source.EffectiveBeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveEndDateSupported)
                && target.EffectiveEndDate != source.EffectiveEndDate)
            {
                target.EffectiveEndDate = source.EffectiveEndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNamespaceSupported)
                && target.Namespace != source.Namespace)
            {
                target.Namespace = source.Namespace;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPriorDescriptorIdSupported)
                && target.PriorDescriptorId != source.PriorDescriptorId)
            {
                target.PriorDescriptorId = source.PriorDescriptorId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsExitWithdrawTypeSupported)
                && target.ExitWithdrawType != source.ExitWithdrawType)
            {
                target.ExitWithdrawType = source.ExitWithdrawType;
                isModified = true;
            }

            // Synch inherited lists


            // Sync lists

            return isModified;
        }



        public static void MapTo(this IExitWithdrawTypeDescriptor source, IExitWithdrawTypeDescriptor target, Action<IExitWithdrawTypeDescriptor, IExitWithdrawTypeDescriptor> onMapped)
        {
            var sourceSynchSupport = source as IExitWithdrawTypeDescriptorSynchronizationSourceSupport;
            var targetSynchSupport = target as IExitWithdrawTypeDescriptorSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.ExitWithdrawTypeDescriptorId = source.ExitWithdrawTypeDescriptorId;

            // Copy inherited non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsEffectiveBeginDateSupported)
                target.EffectiveBeginDate = source.EffectiveBeginDate;
            else
                targetSynchSupport.IsEffectiveBeginDateSupported = false;

            if (sourceSynchSupport.IsEffectiveEndDateSupported)
                target.EffectiveEndDate = source.EffectiveEndDate;
            else
                targetSynchSupport.IsEffectiveEndDateSupported = false;

            if (sourceSynchSupport.IsNamespaceSupported)
                target.Namespace = source.Namespace;
            else
                targetSynchSupport.IsNamespaceSupported = false;

            if (sourceSynchSupport.IsPriorDescriptorIdSupported)
                target.PriorDescriptorId = source.PriorDescriptorId;
            else
                targetSynchSupport.IsPriorDescriptorIdSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Copy non-PK properties

            if (sourceSynchSupport.IsExitWithdrawTypeSupported)
                target.ExitWithdrawType = source.ExitWithdrawType;
            else
                targetSynchSupport.IsExitWithdrawTypeSupported = false;

            // Map inherited lists

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IExitWithdrawTypeDescriptorSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsEffectiveBeginDateSupported { get; set; }
        bool IsEffectiveEndDateSupported { get; set; }
        bool IsExitWithdrawTypeSupported { get; set; }
        bool IsNamespaceSupported { get; set; }
        bool IsPriorDescriptorIdSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: FeederSchoolAssociation

namespace EdFi.Ods.Entities.Common //.FeederSchoolAssociationAggregate
{ 
    public static class FeederSchoolAssociationMapper 
    {
        public static bool SynchronizeTo(this IFeederSchoolAssociation source, IFeederSchoolAssociation target)
        {
            bool isModified = false;

            var sourceSupport = source as IFeederSchoolAssociationSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.BeginDate != target.BeginDate)
            {
                source.BeginDate = target.BeginDate;
            }
            if (source.FeederSchoolId != target.FeederSchoolId)
            {
                source.FeederSchoolId = target.FeederSchoolId;
            }
            if (source.SchoolId != target.SchoolId)
            {
                source.SchoolId = target.SchoolId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsEndDateSupported)
                && target.EndDate != source.EndDate)
            {
                target.EndDate = source.EndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsFeederRelationshipDescriptionSupported)
                && target.FeederRelationshipDescription != source.FeederRelationshipDescription)
            {
                target.FeederRelationshipDescription = source.FeederRelationshipDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IFeederSchoolAssociation source, IFeederSchoolAssociation target, Action<IFeederSchoolAssociation, IFeederSchoolAssociation> onMapped)
        {
            var sourceSynchSupport = source as IFeederSchoolAssociationSynchronizationSourceSupport;
            var targetSynchSupport = target as IFeederSchoolAssociationSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.BeginDate = source.BeginDate;
            target.FeederSchoolId = source.FeederSchoolId;
            target.SchoolId = source.SchoolId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsEndDateSupported)
                target.EndDate = source.EndDate;
            else
                targetSynchSupport.IsEndDateSupported = false;

            if (sourceSynchSupport.IsFeederRelationshipDescriptionSupported)
                target.FeederRelationshipDescription = source.FeederRelationshipDescription;
            else
                targetSynchSupport.IsFeederRelationshipDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IFeederSchoolAssociationSynchronizationSourceSupport
    {
        bool IsEndDateSupported { get; set; }
        bool IsFeederRelationshipDescriptionSupported { get; set; }
    }
 
}
// Aggregate: Grade

namespace EdFi.Ods.Entities.Common //.GradeAggregate
{ 
    public static class GradeMapper 
    {
        public static bool SynchronizeTo(this IGrade source, IGrade target)
        {
            bool isModified = false;

            var sourceSupport = source as IGradeSynchronizationSourceSupport;

            // Allow PK column updates on Grade
            if (
                 (target.BeginDate != source.BeginDate)
                || (target.ClassPeriodName != source.ClassPeriodName)
                || (target.ClassroomIdentificationCode != source.ClassroomIdentificationCode)
                || (target.GradeType != source.GradeType)
                || (target.GradingPeriodBeginDate != source.GradingPeriodBeginDate)
                || (target.GradingPeriodDescriptor != source.GradingPeriodDescriptor)
                || (target.LocalCourseCode != source.LocalCourseCode)
                || (target.SchoolId != source.SchoolId)
                || (target.SchoolYear != source.SchoolYear)
                || (target.SequenceOfCourse != source.SequenceOfCourse)
                || (target.StudentUniqueId != source.StudentUniqueId)
                || (target.TermDescriptor != source.TermDescriptor)
                || (target.UniqueSectionCode != source.UniqueSectionCode))
            {            
                isModified = true;

                var sourceWithPrimaryKeyValues = (source as IHasPrimaryKeyValues);

                if (sourceWithPrimaryKeyValues != null)
                {
                    var targetWithNewKeyValues = target as IHasCascadableKeyValues;

                    if (targetWithNewKeyValues != null)
                        targetWithNewKeyValues.NewKeyValues = sourceWithPrimaryKeyValues.GetPrimaryKeyValues();
                }
            }

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.BeginDate != target.BeginDate)
            {
                source.BeginDate = target.BeginDate;
            }
            if (source.ClassPeriodName != target.ClassPeriodName)
            {
                source.ClassPeriodName = target.ClassPeriodName;
            }
            if (source.ClassroomIdentificationCode != target.ClassroomIdentificationCode)
            {
                source.ClassroomIdentificationCode = target.ClassroomIdentificationCode;
            }
            if (source.GradeType != target.GradeType)
            {
                source.GradeType = target.GradeType;
            }
            if (source.GradingPeriodBeginDate != target.GradingPeriodBeginDate)
            {
                source.GradingPeriodBeginDate = target.GradingPeriodBeginDate;
            }
            if (source.GradingPeriodDescriptor != target.GradingPeriodDescriptor)
            {
                source.GradingPeriodDescriptor = target.GradingPeriodDescriptor;
            }
            if (source.LocalCourseCode != target.LocalCourseCode)
            {
                source.LocalCourseCode = target.LocalCourseCode;
            }
            if (source.SchoolId != target.SchoolId)
            {
                source.SchoolId = target.SchoolId;
            }
            if (source.SchoolYear != target.SchoolYear)
            {
                source.SchoolYear = target.SchoolYear;
            }
            if (source.SequenceOfCourse != target.SequenceOfCourse)
            {
                source.SequenceOfCourse = target.SequenceOfCourse;
            }
            if (source.StudentUniqueId != target.StudentUniqueId)
            {
                source.StudentUniqueId = target.StudentUniqueId;
            }
            if (source.TermDescriptor != target.TermDescriptor)
            {
                source.TermDescriptor = target.TermDescriptor;
            }
            if (source.UniqueSectionCode != target.UniqueSectionCode)
            {
                source.UniqueSectionCode = target.UniqueSectionCode;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsDiagnosticStatementSupported)
                && target.DiagnosticStatement != source.DiagnosticStatement)
            {
                target.DiagnosticStatement = source.DiagnosticStatement;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsLetterGradeEarnedSupported)
                && target.LetterGradeEarned != source.LetterGradeEarned)
            {
                target.LetterGradeEarned = source.LetterGradeEarned;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNumericGradeEarnedSupported)
                && target.NumericGradeEarned != source.NumericGradeEarned)
            {
                target.NumericGradeEarned = source.NumericGradeEarned;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPerformanceBaseConversionTypeSupported)
                && target.PerformanceBaseConversionType != source.PerformanceBaseConversionType)
            {
                target.PerformanceBaseConversionType = source.PerformanceBaseConversionType;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IGrade source, IGrade target, Action<IGrade, IGrade> onMapped)
        {
            var sourceSynchSupport = source as IGradeSynchronizationSourceSupport;
            var targetSynchSupport = target as IGradeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.BeginDate = source.BeginDate;
            target.ClassPeriodName = source.ClassPeriodName;
            target.ClassroomIdentificationCode = source.ClassroomIdentificationCode;
            target.GradeType = source.GradeType;
            target.GradingPeriodBeginDate = source.GradingPeriodBeginDate;
            target.GradingPeriodDescriptor = source.GradingPeriodDescriptor;
            target.LocalCourseCode = source.LocalCourseCode;
            target.SchoolId = source.SchoolId;
            target.SchoolYear = source.SchoolYear;
            target.SequenceOfCourse = source.SequenceOfCourse;
            target.StudentUniqueId = source.StudentUniqueId;
            target.TermDescriptor = source.TermDescriptor;
            target.UniqueSectionCode = source.UniqueSectionCode;

            // Copy non-PK properties

            if (sourceSynchSupport.IsDiagnosticStatementSupported)
                target.DiagnosticStatement = source.DiagnosticStatement;
            else
                targetSynchSupport.IsDiagnosticStatementSupported = false;

            if (sourceSynchSupport.IsLetterGradeEarnedSupported)
                target.LetterGradeEarned = source.LetterGradeEarned;
            else
                targetSynchSupport.IsLetterGradeEarnedSupported = false;

            if (sourceSynchSupport.IsNumericGradeEarnedSupported)
                target.NumericGradeEarned = source.NumericGradeEarned;
            else
                targetSynchSupport.IsNumericGradeEarnedSupported = false;

            if (sourceSynchSupport.IsPerformanceBaseConversionTypeSupported)
                target.PerformanceBaseConversionType = source.PerformanceBaseConversionType;
            else
                targetSynchSupport.IsPerformanceBaseConversionTypeSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IGradeSynchronizationSourceSupport
    {
        bool IsDiagnosticStatementSupported { get; set; }
        bool IsLetterGradeEarnedSupported { get; set; }
        bool IsNumericGradeEarnedSupported { get; set; }
        bool IsPerformanceBaseConversionTypeSupported { get; set; }
    }
 
}
// Aggregate: GradebookEntry

namespace EdFi.Ods.Entities.Common //.GradebookEntryAggregate
{ 
    public static class GradebookEntryMapper 
    {
        public static bool SynchronizeTo(this IGradebookEntry source, IGradebookEntry target)
        {
            bool isModified = false;

            var sourceSupport = source as IGradebookEntrySynchronizationSourceSupport;

            // Allow PK column updates on GradebookEntry
            if (
                 (target.ClassPeriodName != source.ClassPeriodName)
                || (target.ClassroomIdentificationCode != source.ClassroomIdentificationCode)
                || (target.DateAssigned != source.DateAssigned)
                || (target.GradebookEntryTitle != source.GradebookEntryTitle)
                || (target.LocalCourseCode != source.LocalCourseCode)
                || (target.SchoolId != source.SchoolId)
                || (target.SchoolYear != source.SchoolYear)
                || (target.SequenceOfCourse != source.SequenceOfCourse)
                || (target.TermDescriptor != source.TermDescriptor)
                || (target.UniqueSectionCode != source.UniqueSectionCode))
            {            
                isModified = true;

                var sourceWithPrimaryKeyValues = (source as IHasPrimaryKeyValues);

                if (sourceWithPrimaryKeyValues != null)
                {
                    var targetWithNewKeyValues = target as IHasCascadableKeyValues;

                    if (targetWithNewKeyValues != null)
                        targetWithNewKeyValues.NewKeyValues = sourceWithPrimaryKeyValues.GetPrimaryKeyValues();
                }
            }

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.ClassPeriodName != target.ClassPeriodName)
            {
                source.ClassPeriodName = target.ClassPeriodName;
            }
            if (source.ClassroomIdentificationCode != target.ClassroomIdentificationCode)
            {
                source.ClassroomIdentificationCode = target.ClassroomIdentificationCode;
            }
            if (source.DateAssigned != target.DateAssigned)
            {
                source.DateAssigned = target.DateAssigned;
            }
            if (source.GradebookEntryTitle != target.GradebookEntryTitle)
            {
                source.GradebookEntryTitle = target.GradebookEntryTitle;
            }
            if (source.LocalCourseCode != target.LocalCourseCode)
            {
                source.LocalCourseCode = target.LocalCourseCode;
            }
            if (source.SchoolId != target.SchoolId)
            {
                source.SchoolId = target.SchoolId;
            }
            if (source.SchoolYear != target.SchoolYear)
            {
                source.SchoolYear = target.SchoolYear;
            }
            if (source.SequenceOfCourse != target.SequenceOfCourse)
            {
                source.SequenceOfCourse = target.SequenceOfCourse;
            }
            if (source.TermDescriptor != target.TermDescriptor)
            {
                source.TermDescriptor = target.TermDescriptor;
            }
            if (source.UniqueSectionCode != target.UniqueSectionCode)
            {
                source.UniqueSectionCode = target.UniqueSectionCode;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsBeginDateSupported)
                && target.BeginDate != source.BeginDate)
            {
                target.BeginDate = source.BeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsGradebookEntryTypeSupported)
                && target.GradebookEntryType != source.GradebookEntryType)
            {
                target.GradebookEntryType = source.GradebookEntryType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsGradingPeriodDescriptorSupported)
                && target.GradingPeriodDescriptor != source.GradingPeriodDescriptor)
            {
                target.GradingPeriodDescriptor = source.GradingPeriodDescriptor;
                isModified = true;
            }



            // Sync lists
            if (sourceSupport == null || sourceSupport.IsGradebookEntryLearningObjectivesSupported)
                isModified |= source.GradebookEntryLearningObjectives.SynchronizeListTo(target.GradebookEntryLearningObjectives, child => child.GradebookEntry = target,
                                sourceSupport == null ? null : sourceSupport.IsGradebookEntryLearningObjectiveIncluded);

            if (sourceSupport == null || sourceSupport.IsGradebookEntryLearningStandardsSupported)
                isModified |= source.GradebookEntryLearningStandards.SynchronizeListTo(target.GradebookEntryLearningStandards, child => child.GradebookEntry = target,
                                sourceSupport == null ? null : sourceSupport.IsGradebookEntryLearningStandardIncluded);


            return isModified;
        }



        public static void MapTo(this IGradebookEntry source, IGradebookEntry target, Action<IGradebookEntry, IGradebookEntry> onMapped)
        {
            var sourceSynchSupport = source as IGradebookEntrySynchronizationSourceSupport;
            var targetSynchSupport = target as IGradebookEntrySynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.ClassPeriodName = source.ClassPeriodName;
            target.ClassroomIdentificationCode = source.ClassroomIdentificationCode;
            target.DateAssigned = source.DateAssigned;
            target.GradebookEntryTitle = source.GradebookEntryTitle;
            target.LocalCourseCode = source.LocalCourseCode;
            target.SchoolId = source.SchoolId;
            target.SchoolYear = source.SchoolYear;
            target.SequenceOfCourse = source.SequenceOfCourse;
            target.TermDescriptor = source.TermDescriptor;
            target.UniqueSectionCode = source.UniqueSectionCode;

            // Copy non-PK properties

            if (sourceSynchSupport.IsBeginDateSupported)
                target.BeginDate = source.BeginDate;
            else
                targetSynchSupport.IsBeginDateSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsGradebookEntryTypeSupported)
                target.GradebookEntryType = source.GradebookEntryType;
            else
                targetSynchSupport.IsGradebookEntryTypeSupported = false;

            if (sourceSynchSupport.IsGradingPeriodDescriptorSupported)
                target.GradingPeriodDescriptor = source.GradingPeriodDescriptor;
            else
                targetSynchSupport.IsGradingPeriodDescriptorSupported = false;

            // Map lists

            if (sourceSynchSupport.IsGradebookEntryLearningObjectivesSupported)
            {    
                targetSynchSupport.IsGradebookEntryLearningObjectiveIncluded = sourceSynchSupport.IsGradebookEntryLearningObjectiveIncluded;
                source.GradebookEntryLearningObjectives.MapListTo(target.GradebookEntryLearningObjectives);
            }
            else
            {
                targetSynchSupport.IsGradebookEntryLearningObjectivesSupported = false;
            }

            if (sourceSynchSupport.IsGradebookEntryLearningStandardsSupported)
            {    
                targetSynchSupport.IsGradebookEntryLearningStandardIncluded = sourceSynchSupport.IsGradebookEntryLearningStandardIncluded;
                source.GradebookEntryLearningStandards.MapListTo(target.GradebookEntryLearningStandards);
            }
            else
            {
                targetSynchSupport.IsGradebookEntryLearningStandardsSupported = false;
            }

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IGradebookEntrySynchronizationSourceSupport
    {
        bool IsBeginDateSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsGradebookEntryLearningObjectivesSupported { get; set; }
        bool IsGradebookEntryLearningStandardsSupported { get; set; }
        bool IsGradebookEntryTypeSupported { get; set; }
        bool IsGradingPeriodDescriptorSupported { get; set; }
        Func<IGradebookEntryLearningObjective, bool> IsGradebookEntryLearningObjectiveIncluded { get; set; }
        Func<IGradebookEntryLearningStandard, bool> IsGradebookEntryLearningStandardIncluded { get; set; }
    }
 
    public static class GradebookEntryLearningObjectiveMapper 
    {
        public static bool SynchronizeTo(this IGradebookEntryLearningObjective source, IGradebookEntryLearningObjective target)
        {
            bool isModified = false;

            var sourceSupport = source as IGradebookEntryLearningObjectiveSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.LearningObjectiveId != target.LearningObjectiveId)
            {
                source.LearningObjectiveId = target.LearningObjectiveId;
            }
            if (source.Namespace != target.Namespace)
            {
                source.Namespace = target.Namespace;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IGradebookEntryLearningObjective source, IGradebookEntryLearningObjective target, Action<IGradebookEntryLearningObjective, IGradebookEntryLearningObjective> onMapped)
        {
            var sourceSynchSupport = source as IGradebookEntryLearningObjectiveSynchronizationSourceSupport;
            var targetSynchSupport = target as IGradebookEntryLearningObjectiveSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.LearningObjectiveId = source.LearningObjectiveId;
            target.Namespace = source.Namespace;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IGradebookEntryLearningObjectiveSynchronizationSourceSupport
    {
    }
 
    public static class GradebookEntryLearningStandardMapper 
    {
        public static bool SynchronizeTo(this IGradebookEntryLearningStandard source, IGradebookEntryLearningStandard target)
        {
            bool isModified = false;

            var sourceSupport = source as IGradebookEntryLearningStandardSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.LearningStandardId != target.LearningStandardId)
            {
                source.LearningStandardId = target.LearningStandardId;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IGradebookEntryLearningStandard source, IGradebookEntryLearningStandard target, Action<IGradebookEntryLearningStandard, IGradebookEntryLearningStandard> onMapped)
        {
            var sourceSynchSupport = source as IGradebookEntryLearningStandardSynchronizationSourceSupport;
            var targetSynchSupport = target as IGradebookEntryLearningStandardSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.LearningStandardId = source.LearningStandardId;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IGradebookEntryLearningStandardSynchronizationSourceSupport
    {
    }
 
}
// Aggregate: GradebookEntryType

namespace EdFi.Ods.Entities.Common //.GradebookEntryTypeAggregate
{ 
    public static class GradebookEntryTypeMapper 
    {
        public static bool SynchronizeTo(this IGradebookEntryType source, IGradebookEntryType target)
        {
            bool isModified = false;

            var sourceSupport = source as IGradebookEntryTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.GradebookEntryTypeId != target.GradebookEntryTypeId)
            {
                source.GradebookEntryTypeId = target.GradebookEntryTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IGradebookEntryType source, IGradebookEntryType target, Action<IGradebookEntryType, IGradebookEntryType> onMapped)
        {
            var sourceSynchSupport = source as IGradebookEntryTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IGradebookEntryTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.GradebookEntryTypeId = source.GradebookEntryTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IGradebookEntryTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: GradeLevelDescriptor

namespace EdFi.Ods.Entities.Common //.GradeLevelDescriptorAggregate
{ 
    public static class GradeLevelDescriptorMapper 
    {
        public static bool SynchronizeTo(this IGradeLevelDescriptor source, IGradeLevelDescriptor target)
        {
            bool isModified = false;

            var sourceSupport = source as IGradeLevelDescriptorSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.GradeLevelDescriptorId != target.GradeLevelDescriptorId)
            {
                source.GradeLevelDescriptorId = target.GradeLevelDescriptorId;
            }

            // Copy inherited non-PK properties


            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveBeginDateSupported)
                && target.EffectiveBeginDate != source.EffectiveBeginDate)
            {
                target.EffectiveBeginDate = source.EffectiveBeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveEndDateSupported)
                && target.EffectiveEndDate != source.EffectiveEndDate)
            {
                target.EffectiveEndDate = source.EffectiveEndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNamespaceSupported)
                && target.Namespace != source.Namespace)
            {
                target.Namespace = source.Namespace;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPriorDescriptorIdSupported)
                && target.PriorDescriptorId != source.PriorDescriptorId)
            {
                target.PriorDescriptorId = source.PriorDescriptorId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsGradeLevelTypeSupported)
                && target.GradeLevelType != source.GradeLevelType)
            {
                target.GradeLevelType = source.GradeLevelType;
                isModified = true;
            }

            // Synch inherited lists


            // Sync lists

            return isModified;
        }



        public static void MapTo(this IGradeLevelDescriptor source, IGradeLevelDescriptor target, Action<IGradeLevelDescriptor, IGradeLevelDescriptor> onMapped)
        {
            var sourceSynchSupport = source as IGradeLevelDescriptorSynchronizationSourceSupport;
            var targetSynchSupport = target as IGradeLevelDescriptorSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.GradeLevelDescriptorId = source.GradeLevelDescriptorId;

            // Copy inherited non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsEffectiveBeginDateSupported)
                target.EffectiveBeginDate = source.EffectiveBeginDate;
            else
                targetSynchSupport.IsEffectiveBeginDateSupported = false;

            if (sourceSynchSupport.IsEffectiveEndDateSupported)
                target.EffectiveEndDate = source.EffectiveEndDate;
            else
                targetSynchSupport.IsEffectiveEndDateSupported = false;

            if (sourceSynchSupport.IsNamespaceSupported)
                target.Namespace = source.Namespace;
            else
                targetSynchSupport.IsNamespaceSupported = false;

            if (sourceSynchSupport.IsPriorDescriptorIdSupported)
                target.PriorDescriptorId = source.PriorDescriptorId;
            else
                targetSynchSupport.IsPriorDescriptorIdSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Copy non-PK properties

            if (sourceSynchSupport.IsGradeLevelTypeSupported)
                target.GradeLevelType = source.GradeLevelType;
            else
                targetSynchSupport.IsGradeLevelTypeSupported = false;

            // Map inherited lists

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IGradeLevelDescriptorSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsEffectiveBeginDateSupported { get; set; }
        bool IsEffectiveEndDateSupported { get; set; }
        bool IsGradeLevelTypeSupported { get; set; }
        bool IsNamespaceSupported { get; set; }
        bool IsPriorDescriptorIdSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: GradeLevelType

namespace EdFi.Ods.Entities.Common //.GradeLevelTypeAggregate
{ 
    public static class GradeLevelTypeMapper 
    {
        public static bool SynchronizeTo(this IGradeLevelType source, IGradeLevelType target)
        {
            bool isModified = false;

            var sourceSupport = source as IGradeLevelTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.GradeLevelTypeId != target.GradeLevelTypeId)
            {
                source.GradeLevelTypeId = target.GradeLevelTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IGradeLevelType source, IGradeLevelType target, Action<IGradeLevelType, IGradeLevelType> onMapped)
        {
            var sourceSynchSupport = source as IGradeLevelTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IGradeLevelTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.GradeLevelTypeId = source.GradeLevelTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IGradeLevelTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: GradeType

namespace EdFi.Ods.Entities.Common //.GradeTypeAggregate
{ 
    public static class GradeTypeMapper 
    {
        public static bool SynchronizeTo(this IGradeType source, IGradeType target)
        {
            bool isModified = false;

            var sourceSupport = source as IGradeTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.GradeTypeId != target.GradeTypeId)
            {
                source.GradeTypeId = target.GradeTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IGradeType source, IGradeType target, Action<IGradeType, IGradeType> onMapped)
        {
            var sourceSynchSupport = source as IGradeTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IGradeTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.GradeTypeId = source.GradeTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IGradeTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: GradingPeriod

namespace EdFi.Ods.Entities.Common //.GradingPeriodAggregate
{ 
    public static class GradingPeriodMapper 
    {
        public static bool SynchronizeTo(this IGradingPeriod source, IGradingPeriod target)
        {
            bool isModified = false;

            var sourceSupport = source as IGradingPeriodSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.BeginDate != target.BeginDate)
            {
                source.BeginDate = target.BeginDate;
            }
            if (source.GradingPeriodDescriptor != target.GradingPeriodDescriptor)
            {
                source.GradingPeriodDescriptor = target.GradingPeriodDescriptor;
            }
            if (source.SchoolId != target.SchoolId)
            {
                source.SchoolId = target.SchoolId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsEndDateSupported)
                && target.EndDate != source.EndDate)
            {
                target.EndDate = source.EndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPeriodSequenceSupported)
                && target.PeriodSequence != source.PeriodSequence)
            {
                target.PeriodSequence = source.PeriodSequence;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsTotalInstructionalDaysSupported)
                && target.TotalInstructionalDays != source.TotalInstructionalDays)
            {
                target.TotalInstructionalDays = source.TotalInstructionalDays;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IGradingPeriod source, IGradingPeriod target, Action<IGradingPeriod, IGradingPeriod> onMapped)
        {
            var sourceSynchSupport = source as IGradingPeriodSynchronizationSourceSupport;
            var targetSynchSupport = target as IGradingPeriodSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.BeginDate = source.BeginDate;
            target.GradingPeriodDescriptor = source.GradingPeriodDescriptor;
            target.SchoolId = source.SchoolId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsEndDateSupported)
                target.EndDate = source.EndDate;
            else
                targetSynchSupport.IsEndDateSupported = false;

            if (sourceSynchSupport.IsPeriodSequenceSupported)
                target.PeriodSequence = source.PeriodSequence;
            else
                targetSynchSupport.IsPeriodSequenceSupported = false;

            if (sourceSynchSupport.IsTotalInstructionalDaysSupported)
                target.TotalInstructionalDays = source.TotalInstructionalDays;
            else
                targetSynchSupport.IsTotalInstructionalDaysSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IGradingPeriodSynchronizationSourceSupport
    {
        bool IsEndDateSupported { get; set; }
        bool IsPeriodSequenceSupported { get; set; }
        bool IsTotalInstructionalDaysSupported { get; set; }
    }
 
}
// Aggregate: GradingPeriodDescriptor

namespace EdFi.Ods.Entities.Common //.GradingPeriodDescriptorAggregate
{ 
    public static class GradingPeriodDescriptorMapper 
    {
        public static bool SynchronizeTo(this IGradingPeriodDescriptor source, IGradingPeriodDescriptor target)
        {
            bool isModified = false;

            var sourceSupport = source as IGradingPeriodDescriptorSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.GradingPeriodDescriptorId != target.GradingPeriodDescriptorId)
            {
                source.GradingPeriodDescriptorId = target.GradingPeriodDescriptorId;
            }

            // Copy inherited non-PK properties


            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveBeginDateSupported)
                && target.EffectiveBeginDate != source.EffectiveBeginDate)
            {
                target.EffectiveBeginDate = source.EffectiveBeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveEndDateSupported)
                && target.EffectiveEndDate != source.EffectiveEndDate)
            {
                target.EffectiveEndDate = source.EffectiveEndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNamespaceSupported)
                && target.Namespace != source.Namespace)
            {
                target.Namespace = source.Namespace;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPriorDescriptorIdSupported)
                && target.PriorDescriptorId != source.PriorDescriptorId)
            {
                target.PriorDescriptorId = source.PriorDescriptorId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsGradingPeriodTypeSupported)
                && target.GradingPeriodType != source.GradingPeriodType)
            {
                target.GradingPeriodType = source.GradingPeriodType;
                isModified = true;
            }

            // Synch inherited lists


            // Sync lists

            return isModified;
        }



        public static void MapTo(this IGradingPeriodDescriptor source, IGradingPeriodDescriptor target, Action<IGradingPeriodDescriptor, IGradingPeriodDescriptor> onMapped)
        {
            var sourceSynchSupport = source as IGradingPeriodDescriptorSynchronizationSourceSupport;
            var targetSynchSupport = target as IGradingPeriodDescriptorSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.GradingPeriodDescriptorId = source.GradingPeriodDescriptorId;

            // Copy inherited non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsEffectiveBeginDateSupported)
                target.EffectiveBeginDate = source.EffectiveBeginDate;
            else
                targetSynchSupport.IsEffectiveBeginDateSupported = false;

            if (sourceSynchSupport.IsEffectiveEndDateSupported)
                target.EffectiveEndDate = source.EffectiveEndDate;
            else
                targetSynchSupport.IsEffectiveEndDateSupported = false;

            if (sourceSynchSupport.IsNamespaceSupported)
                target.Namespace = source.Namespace;
            else
                targetSynchSupport.IsNamespaceSupported = false;

            if (sourceSynchSupport.IsPriorDescriptorIdSupported)
                target.PriorDescriptorId = source.PriorDescriptorId;
            else
                targetSynchSupport.IsPriorDescriptorIdSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Copy non-PK properties

            if (sourceSynchSupport.IsGradingPeriodTypeSupported)
                target.GradingPeriodType = source.GradingPeriodType;
            else
                targetSynchSupport.IsGradingPeriodTypeSupported = false;

            // Map inherited lists

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IGradingPeriodDescriptorSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsEffectiveBeginDateSupported { get; set; }
        bool IsEffectiveEndDateSupported { get; set; }
        bool IsGradingPeriodTypeSupported { get; set; }
        bool IsNamespaceSupported { get; set; }
        bool IsPriorDescriptorIdSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: GradingPeriodType

namespace EdFi.Ods.Entities.Common //.GradingPeriodTypeAggregate
{ 
    public static class GradingPeriodTypeMapper 
    {
        public static bool SynchronizeTo(this IGradingPeriodType source, IGradingPeriodType target)
        {
            bool isModified = false;

            var sourceSupport = source as IGradingPeriodTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.GradingPeriodTypeId != target.GradingPeriodTypeId)
            {
                source.GradingPeriodTypeId = target.GradingPeriodTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPeriodSequenceSupported)
                && target.PeriodSequence != source.PeriodSequence)
            {
                target.PeriodSequence = source.PeriodSequence;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IGradingPeriodType source, IGradingPeriodType target, Action<IGradingPeriodType, IGradingPeriodType> onMapped)
        {
            var sourceSynchSupport = source as IGradingPeriodTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IGradingPeriodTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.GradingPeriodTypeId = source.GradingPeriodTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsPeriodSequenceSupported)
                target.PeriodSequence = source.PeriodSequence;
            else
                targetSynchSupport.IsPeriodSequenceSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IGradingPeriodTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsPeriodSequenceSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: GraduationPlan

namespace EdFi.Ods.Entities.Common //.GraduationPlanAggregate
{ 
    public static class GraduationPlanMapper 
    {
        public static bool SynchronizeTo(this IGraduationPlan source, IGraduationPlan target)
        {
            bool isModified = false;

            var sourceSupport = source as IGraduationPlanSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.EducationOrganizationId != target.EducationOrganizationId)
            {
                source.EducationOrganizationId = target.EducationOrganizationId;
            }
            if (source.GraduationPlanTypeDescriptor != target.GraduationPlanTypeDescriptor)
            {
                source.GraduationPlanTypeDescriptor = target.GraduationPlanTypeDescriptor;
            }
            if (source.GraduationSchoolYear != target.GraduationSchoolYear)
            {
                source.GraduationSchoolYear = target.GraduationSchoolYear;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsIndividualPlanSupported)
                && target.IndividualPlan != source.IndividualPlan)
            {
                target.IndividualPlan = source.IndividualPlan;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsTotalRequiredCreditConversionSupported)
                && target.TotalRequiredCreditConversion != source.TotalRequiredCreditConversion)
            {
                target.TotalRequiredCreditConversion = source.TotalRequiredCreditConversion;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsTotalRequiredCreditsSupported)
                && target.TotalRequiredCredits != source.TotalRequiredCredits)
            {
                target.TotalRequiredCredits = source.TotalRequiredCredits;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsTotalRequiredCreditTypeSupported)
                && target.TotalRequiredCreditType != source.TotalRequiredCreditType)
            {
                target.TotalRequiredCreditType = source.TotalRequiredCreditType;
                isModified = true;
            }



            // Sync lists
            if (sourceSupport == null || sourceSupport.IsGraduationPlanCreditsByCoursesSupported)
                isModified |= source.GraduationPlanCreditsByCourses.SynchronizeListTo(target.GraduationPlanCreditsByCourses, child => child.GraduationPlan = target,
                                sourceSupport == null ? null : sourceSupport.IsGraduationPlanCreditsByCourseIncluded);

            if (sourceSupport == null || sourceSupport.IsGraduationPlanCreditsBySubjectsSupported)
                isModified |= source.GraduationPlanCreditsBySubjects.SynchronizeListTo(target.GraduationPlanCreditsBySubjects, child => child.GraduationPlan = target,
                                sourceSupport == null ? null : sourceSupport.IsGraduationPlanCreditsBySubjectIncluded);

            if (sourceSupport == null || sourceSupport.IsGraduationPlanRequiredAssessmentsSupported)
                isModified |= source.GraduationPlanRequiredAssessments.SynchronizeListTo(target.GraduationPlanRequiredAssessments, child => child.GraduationPlan = target,
                                sourceSupport == null ? null : sourceSupport.IsGraduationPlanRequiredAssessmentIncluded);


            return isModified;
        }



        public static void MapTo(this IGraduationPlan source, IGraduationPlan target, Action<IGraduationPlan, IGraduationPlan> onMapped)
        {
            var sourceSynchSupport = source as IGraduationPlanSynchronizationSourceSupport;
            var targetSynchSupport = target as IGraduationPlanSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.EducationOrganizationId = source.EducationOrganizationId;
            target.GraduationPlanTypeDescriptor = source.GraduationPlanTypeDescriptor;
            target.GraduationSchoolYear = source.GraduationSchoolYear;

            // Copy non-PK properties

            if (sourceSynchSupport.IsIndividualPlanSupported)
                target.IndividualPlan = source.IndividualPlan;
            else
                targetSynchSupport.IsIndividualPlanSupported = false;

            if (sourceSynchSupport.IsTotalRequiredCreditConversionSupported)
                target.TotalRequiredCreditConversion = source.TotalRequiredCreditConversion;
            else
                targetSynchSupport.IsTotalRequiredCreditConversionSupported = false;

            if (sourceSynchSupport.IsTotalRequiredCreditsSupported)
                target.TotalRequiredCredits = source.TotalRequiredCredits;
            else
                targetSynchSupport.IsTotalRequiredCreditsSupported = false;

            if (sourceSynchSupport.IsTotalRequiredCreditTypeSupported)
                target.TotalRequiredCreditType = source.TotalRequiredCreditType;
            else
                targetSynchSupport.IsTotalRequiredCreditTypeSupported = false;

            // Map lists

            if (sourceSynchSupport.IsGraduationPlanCreditsByCoursesSupported)
            {    
                targetSynchSupport.IsGraduationPlanCreditsByCourseIncluded = sourceSynchSupport.IsGraduationPlanCreditsByCourseIncluded;
                source.GraduationPlanCreditsByCourses.MapListTo(target.GraduationPlanCreditsByCourses);
            }
            else
            {
                targetSynchSupport.IsGraduationPlanCreditsByCoursesSupported = false;
            }

            if (sourceSynchSupport.IsGraduationPlanCreditsBySubjectsSupported)
            {    
                targetSynchSupport.IsGraduationPlanCreditsBySubjectIncluded = sourceSynchSupport.IsGraduationPlanCreditsBySubjectIncluded;
                source.GraduationPlanCreditsBySubjects.MapListTo(target.GraduationPlanCreditsBySubjects);
            }
            else
            {
                targetSynchSupport.IsGraduationPlanCreditsBySubjectsSupported = false;
            }

            if (sourceSynchSupport.IsGraduationPlanRequiredAssessmentsSupported)
            {    
                targetSynchSupport.IsGraduationPlanRequiredAssessmentIncluded = sourceSynchSupport.IsGraduationPlanRequiredAssessmentIncluded;
                source.GraduationPlanRequiredAssessments.MapListTo(target.GraduationPlanRequiredAssessments);
            }
            else
            {
                targetSynchSupport.IsGraduationPlanRequiredAssessmentsSupported = false;
            }

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IGraduationPlanSynchronizationSourceSupport
    {
        bool IsGraduationPlanCreditsByCoursesSupported { get; set; }
        bool IsGraduationPlanCreditsBySubjectsSupported { get; set; }
        bool IsGraduationPlanRequiredAssessmentsSupported { get; set; }
        bool IsIndividualPlanSupported { get; set; }
        bool IsTotalRequiredCreditConversionSupported { get; set; }
        bool IsTotalRequiredCreditsSupported { get; set; }
        bool IsTotalRequiredCreditTypeSupported { get; set; }
        Func<IGraduationPlanCreditsByCourse, bool> IsGraduationPlanCreditsByCourseIncluded { get; set; }
        Func<IGraduationPlanCreditsBySubject, bool> IsGraduationPlanCreditsBySubjectIncluded { get; set; }
        Func<IGraduationPlanRequiredAssessment, bool> IsGraduationPlanRequiredAssessmentIncluded { get; set; }
    }
 
    public static class GraduationPlanCreditsByCourseMapper 
    {
        public static bool SynchronizeTo(this IGraduationPlanCreditsByCourse source, IGraduationPlanCreditsByCourse target)
        {
            bool isModified = false;

            var sourceSupport = source as IGraduationPlanCreditsByCourseSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.CourseSetName != target.CourseSetName)
            {
                source.CourseSetName = target.CourseSetName;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCreditConversionSupported)
                && target.CreditConversion != source.CreditConversion)
            {
                target.CreditConversion = source.CreditConversion;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsCreditsSupported)
                && target.Credits != source.Credits)
            {
                target.Credits = source.Credits;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsCreditTypeSupported)
                && target.CreditType != source.CreditType)
            {
                target.CreditType = source.CreditType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsWhenTakenGradeLevelDescriptorSupported)
                && target.WhenTakenGradeLevelDescriptor != source.WhenTakenGradeLevelDescriptor)
            {
                target.WhenTakenGradeLevelDescriptor = source.WhenTakenGradeLevelDescriptor;
                isModified = true;
            }



            // Sync lists
            if (sourceSupport == null || sourceSupport.IsGraduationPlanCreditsByCourseCoursesSupported)
                isModified |= source.GraduationPlanCreditsByCourseCourses.SynchronizeListTo(target.GraduationPlanCreditsByCourseCourses, child => child.GraduationPlanCreditsByCourse = target,
                                sourceSupport == null ? null : sourceSupport.IsGraduationPlanCreditsByCourseCourseIncluded);


            return isModified;
        }



        public static void MapTo(this IGraduationPlanCreditsByCourse source, IGraduationPlanCreditsByCourse target, Action<IGraduationPlanCreditsByCourse, IGraduationPlanCreditsByCourse> onMapped)
        {
            var sourceSynchSupport = source as IGraduationPlanCreditsByCourseSynchronizationSourceSupport;
            var targetSynchSupport = target as IGraduationPlanCreditsByCourseSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.CourseSetName = source.CourseSetName;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCreditConversionSupported)
                target.CreditConversion = source.CreditConversion;
            else
                targetSynchSupport.IsCreditConversionSupported = false;

            if (sourceSynchSupport.IsCreditsSupported)
                target.Credits = source.Credits;
            else
                targetSynchSupport.IsCreditsSupported = false;

            if (sourceSynchSupport.IsCreditTypeSupported)
                target.CreditType = source.CreditType;
            else
                targetSynchSupport.IsCreditTypeSupported = false;

            if (sourceSynchSupport.IsWhenTakenGradeLevelDescriptorSupported)
                target.WhenTakenGradeLevelDescriptor = source.WhenTakenGradeLevelDescriptor;
            else
                targetSynchSupport.IsWhenTakenGradeLevelDescriptorSupported = false;

            // Map lists

            if (sourceSynchSupport.IsGraduationPlanCreditsByCourseCoursesSupported)
            {    
                targetSynchSupport.IsGraduationPlanCreditsByCourseCourseIncluded = sourceSynchSupport.IsGraduationPlanCreditsByCourseCourseIncluded;
                source.GraduationPlanCreditsByCourseCourses.MapListTo(target.GraduationPlanCreditsByCourseCourses);
            }
            else
            {
                targetSynchSupport.IsGraduationPlanCreditsByCourseCoursesSupported = false;
            }

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IGraduationPlanCreditsByCourseSynchronizationSourceSupport
    {
        bool IsCreditConversionSupported { get; set; }
        bool IsCreditsSupported { get; set; }
        bool IsCreditTypeSupported { get; set; }
        bool IsGraduationPlanCreditsByCourseCoursesSupported { get; set; }
        bool IsWhenTakenGradeLevelDescriptorSupported { get; set; }
        Func<IGraduationPlanCreditsByCourseCourse, bool> IsGraduationPlanCreditsByCourseCourseIncluded { get; set; }
    }
 
    public static class GraduationPlanCreditsByCourseCourseMapper 
    {
        public static bool SynchronizeTo(this IGraduationPlanCreditsByCourseCourse source, IGraduationPlanCreditsByCourseCourse target)
        {
            bool isModified = false;

            var sourceSupport = source as IGraduationPlanCreditsByCourseCourseSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.CourseCode != target.CourseCode)
            {
                source.CourseCode = target.CourseCode;
            }
            if (source.CourseEducationOrganizationId != target.CourseEducationOrganizationId)
            {
                source.CourseEducationOrganizationId = target.CourseEducationOrganizationId;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IGraduationPlanCreditsByCourseCourse source, IGraduationPlanCreditsByCourseCourse target, Action<IGraduationPlanCreditsByCourseCourse, IGraduationPlanCreditsByCourseCourse> onMapped)
        {
            var sourceSynchSupport = source as IGraduationPlanCreditsByCourseCourseSynchronizationSourceSupport;
            var targetSynchSupport = target as IGraduationPlanCreditsByCourseCourseSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.CourseCode = source.CourseCode;
            target.CourseEducationOrganizationId = source.CourseEducationOrganizationId;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IGraduationPlanCreditsByCourseCourseSynchronizationSourceSupport
    {
    }
 
    public static class GraduationPlanCreditsBySubjectMapper 
    {
        public static bool SynchronizeTo(this IGraduationPlanCreditsBySubject source, IGraduationPlanCreditsBySubject target)
        {
            bool isModified = false;

            var sourceSupport = source as IGraduationPlanCreditsBySubjectSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AcademicSubjectDescriptor != target.AcademicSubjectDescriptor)
            {
                source.AcademicSubjectDescriptor = target.AcademicSubjectDescriptor;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCreditConversionSupported)
                && target.CreditConversion != source.CreditConversion)
            {
                target.CreditConversion = source.CreditConversion;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsCreditsSupported)
                && target.Credits != source.Credits)
            {
                target.Credits = source.Credits;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsCreditTypeSupported)
                && target.CreditType != source.CreditType)
            {
                target.CreditType = source.CreditType;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IGraduationPlanCreditsBySubject source, IGraduationPlanCreditsBySubject target, Action<IGraduationPlanCreditsBySubject, IGraduationPlanCreditsBySubject> onMapped)
        {
            var sourceSynchSupport = source as IGraduationPlanCreditsBySubjectSynchronizationSourceSupport;
            var targetSynchSupport = target as IGraduationPlanCreditsBySubjectSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.AcademicSubjectDescriptor = source.AcademicSubjectDescriptor;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCreditConversionSupported)
                target.CreditConversion = source.CreditConversion;
            else
                targetSynchSupport.IsCreditConversionSupported = false;

            if (sourceSynchSupport.IsCreditsSupported)
                target.Credits = source.Credits;
            else
                targetSynchSupport.IsCreditsSupported = false;

            if (sourceSynchSupport.IsCreditTypeSupported)
                target.CreditType = source.CreditType;
            else
                targetSynchSupport.IsCreditTypeSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IGraduationPlanCreditsBySubjectSynchronizationSourceSupport
    {
        bool IsCreditConversionSupported { get; set; }
        bool IsCreditsSupported { get; set; }
        bool IsCreditTypeSupported { get; set; }
    }
 
    public static class GraduationPlanRequiredAssessmentMapper 
    {
        public static bool SynchronizeTo(this IGraduationPlanRequiredAssessment source, IGraduationPlanRequiredAssessment target)
        {
            bool isModified = false;

            var sourceSupport = source as IGraduationPlanRequiredAssessmentSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AssessmentIdentifier != target.AssessmentIdentifier)
            {
                source.AssessmentIdentifier = target.AssessmentIdentifier;
            }
            if (source.Namespace != target.Namespace)
            {
                source.Namespace = target.Namespace;
            }

            // Copy non-PK properties

            // ----------------------------------            
            //   Synch One-to-one relationships
            // ----------------------------------            
            // GraduationPlanRequiredAssessmentAssessmentPerformanceLevel
            if (sourceSupport == null || sourceSupport.IsGraduationPlanRequiredAssessmentAssessmentPerformanceLevelSupported)
            {
                if (source.GraduationPlanRequiredAssessmentAssessmentPerformanceLevel == null)
                {
                    if (target.GraduationPlanRequiredAssessmentAssessmentPerformanceLevel != null)
                    {
                        target.GraduationPlanRequiredAssessmentAssessmentPerformanceLevel = null;
                        isModified = true;
                    }
                }
                else
                {
                    if (target.GraduationPlanRequiredAssessmentAssessmentPerformanceLevel == null)
                    {
                        var itemType = target.GetType().GetProperty("GraduationPlanRequiredAssessmentAssessmentPerformanceLevel").PropertyType;
                        var newItem = Activator.CreateInstance(itemType);
                        target.GraduationPlanRequiredAssessmentAssessmentPerformanceLevel = (IGraduationPlanRequiredAssessmentAssessmentPerformanceLevel) newItem;
                    }

                    isModified |= source.GraduationPlanRequiredAssessmentAssessmentPerformanceLevel.Synchronize(target.GraduationPlanRequiredAssessmentAssessmentPerformanceLevel);
                }
            }
            
            // -------------------------------------------------------------



            // Sync lists
            if (sourceSupport == null || sourceSupport.IsGraduationPlanRequiredAssessmentScoresSupported)
                isModified |= source.GraduationPlanRequiredAssessmentScores.SynchronizeListTo(target.GraduationPlanRequiredAssessmentScores, child => child.GraduationPlanRequiredAssessment = target,
                                sourceSupport == null ? null : sourceSupport.IsGraduationPlanRequiredAssessmentScoreIncluded);


            return isModified;
        }



        public static void MapTo(this IGraduationPlanRequiredAssessment source, IGraduationPlanRequiredAssessment target, Action<IGraduationPlanRequiredAssessment, IGraduationPlanRequiredAssessment> onMapped)
        {
            var sourceSynchSupport = source as IGraduationPlanRequiredAssessmentSynchronizationSourceSupport;
            var targetSynchSupport = target as IGraduationPlanRequiredAssessmentSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.AssessmentIdentifier = source.AssessmentIdentifier;
            target.Namespace = source.Namespace;

            // Copy non-PK properties

            // ----------------------------------
            //   Map One-to-one relationships
            // ----------------------------------
            // GraduationPlanRequiredAssessmentAssessmentPerformanceLevel (Source)
            if (sourceSynchSupport.IsGraduationPlanRequiredAssessmentAssessmentPerformanceLevelSupported)
            {
                var itemProperty = target.GetType().GetProperty("GraduationPlanRequiredAssessmentAssessmentPerformanceLevel");
                
                if (itemProperty != null)
                {                    
                    if (source.GraduationPlanRequiredAssessmentAssessmentPerformanceLevel == null)
                    {
                        target.GraduationPlanRequiredAssessmentAssessmentPerformanceLevel = null;
                    }
                    else
                    {
                        var itemType = itemProperty.PropertyType;
                        object targetGraduationPlanRequiredAssessmentAssessmentPerformanceLevel = Activator.CreateInstance(itemType);

                        source.GraduationPlanRequiredAssessmentAssessmentPerformanceLevel.Map(targetGraduationPlanRequiredAssessmentAssessmentPerformanceLevel);
                        
                        // Update the target reference appropriately
                        target.GraduationPlanRequiredAssessmentAssessmentPerformanceLevel = (IGraduationPlanRequiredAssessmentAssessmentPerformanceLevel) targetGraduationPlanRequiredAssessmentAssessmentPerformanceLevel;
                    }
                }
            }
            else
            {
                targetSynchSupport.IsGraduationPlanRequiredAssessmentAssessmentPerformanceLevelSupported = false; 
            }
            // -------------------------------------------------------------

            // Map lists

            if (sourceSynchSupport.IsGraduationPlanRequiredAssessmentScoresSupported)
            {    
                targetSynchSupport.IsGraduationPlanRequiredAssessmentScoreIncluded = sourceSynchSupport.IsGraduationPlanRequiredAssessmentScoreIncluded;
                source.GraduationPlanRequiredAssessmentScores.MapListTo(target.GraduationPlanRequiredAssessmentScores);
            }
            else
            {
                targetSynchSupport.IsGraduationPlanRequiredAssessmentScoresSupported = false;
            }

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IGraduationPlanRequiredAssessmentSynchronizationSourceSupport
    {
        bool IsGraduationPlanRequiredAssessmentAssessmentPerformanceLevelSupported { get; set; }
        bool IsGraduationPlanRequiredAssessmentScoresSupported { get; set; }
        Func<IGraduationPlanRequiredAssessmentScore, bool> IsGraduationPlanRequiredAssessmentScoreIncluded { get; set; }
    }
 
    public static class GraduationPlanRequiredAssessmentAssessmentPerformanceLevelMapper 
    {
        public static bool SynchronizeTo(this IGraduationPlanRequiredAssessmentAssessmentPerformanceLevel source, IGraduationPlanRequiredAssessmentAssessmentPerformanceLevel target)
        {
            bool isModified = false;

            var sourceSupport = source as IGraduationPlanRequiredAssessmentAssessmentPerformanceLevelSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsAssessmentReportingMethodTypeSupported)
                && target.AssessmentReportingMethodType != source.AssessmentReportingMethodType)
            {
                target.AssessmentReportingMethodType = source.AssessmentReportingMethodType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsMaximumScoreSupported)
                && target.MaximumScore != source.MaximumScore)
            {
                target.MaximumScore = source.MaximumScore;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsMinimumScoreSupported)
                && target.MinimumScore != source.MinimumScore)
            {
                target.MinimumScore = source.MinimumScore;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPerformanceLevelDescriptorSupported)
                && target.PerformanceLevelDescriptor != source.PerformanceLevelDescriptor)
            {
                target.PerformanceLevelDescriptor = source.PerformanceLevelDescriptor;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsResultDatatypeTypeSupported)
                && target.ResultDatatypeType != source.ResultDatatypeType)
            {
                target.ResultDatatypeType = source.ResultDatatypeType;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IGraduationPlanRequiredAssessmentAssessmentPerformanceLevel source, IGraduationPlanRequiredAssessmentAssessmentPerformanceLevel target, Action<IGraduationPlanRequiredAssessmentAssessmentPerformanceLevel, IGraduationPlanRequiredAssessmentAssessmentPerformanceLevel> onMapped)
        {
            var sourceSynchSupport = source as IGraduationPlanRequiredAssessmentAssessmentPerformanceLevelSynchronizationSourceSupport;
            var targetSynchSupport = target as IGraduationPlanRequiredAssessmentAssessmentPerformanceLevelSynchronizationSourceSupport;

            // Copy contextual primary key values

            // Copy non-PK properties

            if (sourceSynchSupport.IsAssessmentReportingMethodTypeSupported)
                target.AssessmentReportingMethodType = source.AssessmentReportingMethodType;
            else
                targetSynchSupport.IsAssessmentReportingMethodTypeSupported = false;

            if (sourceSynchSupport.IsMaximumScoreSupported)
                target.MaximumScore = source.MaximumScore;
            else
                targetSynchSupport.IsMaximumScoreSupported = false;

            if (sourceSynchSupport.IsMinimumScoreSupported)
                target.MinimumScore = source.MinimumScore;
            else
                targetSynchSupport.IsMinimumScoreSupported = false;

            if (sourceSynchSupport.IsPerformanceLevelDescriptorSupported)
                target.PerformanceLevelDescriptor = source.PerformanceLevelDescriptor;
            else
                targetSynchSupport.IsPerformanceLevelDescriptorSupported = false;

            if (sourceSynchSupport.IsResultDatatypeTypeSupported)
                target.ResultDatatypeType = source.ResultDatatypeType;
            else
                targetSynchSupport.IsResultDatatypeTypeSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IGraduationPlanRequiredAssessmentAssessmentPerformanceLevelSynchronizationSourceSupport
    {
        bool IsAssessmentReportingMethodTypeSupported { get; set; }
        bool IsMaximumScoreSupported { get; set; }
        bool IsMinimumScoreSupported { get; set; }
        bool IsPerformanceLevelDescriptorSupported { get; set; }
        bool IsResultDatatypeTypeSupported { get; set; }
    }
 
    public static class GraduationPlanRequiredAssessmentScoreMapper 
    {
        public static bool SynchronizeTo(this IGraduationPlanRequiredAssessmentScore source, IGraduationPlanRequiredAssessmentScore target)
        {
            bool isModified = false;

            var sourceSupport = source as IGraduationPlanRequiredAssessmentScoreSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AssessmentReportingMethodType != target.AssessmentReportingMethodType)
            {
                source.AssessmentReportingMethodType = target.AssessmentReportingMethodType;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsMaximumScoreSupported)
                && target.MaximumScore != source.MaximumScore)
            {
                target.MaximumScore = source.MaximumScore;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsMinimumScoreSupported)
                && target.MinimumScore != source.MinimumScore)
            {
                target.MinimumScore = source.MinimumScore;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsResultDatatypeTypeSupported)
                && target.ResultDatatypeType != source.ResultDatatypeType)
            {
                target.ResultDatatypeType = source.ResultDatatypeType;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IGraduationPlanRequiredAssessmentScore source, IGraduationPlanRequiredAssessmentScore target, Action<IGraduationPlanRequiredAssessmentScore, IGraduationPlanRequiredAssessmentScore> onMapped)
        {
            var sourceSynchSupport = source as IGraduationPlanRequiredAssessmentScoreSynchronizationSourceSupport;
            var targetSynchSupport = target as IGraduationPlanRequiredAssessmentScoreSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.AssessmentReportingMethodType = source.AssessmentReportingMethodType;

            // Copy non-PK properties

            if (sourceSynchSupport.IsMaximumScoreSupported)
                target.MaximumScore = source.MaximumScore;
            else
                targetSynchSupport.IsMaximumScoreSupported = false;

            if (sourceSynchSupport.IsMinimumScoreSupported)
                target.MinimumScore = source.MinimumScore;
            else
                targetSynchSupport.IsMinimumScoreSupported = false;

            if (sourceSynchSupport.IsResultDatatypeTypeSupported)
                target.ResultDatatypeType = source.ResultDatatypeType;
            else
                targetSynchSupport.IsResultDatatypeTypeSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IGraduationPlanRequiredAssessmentScoreSynchronizationSourceSupport
    {
        bool IsMaximumScoreSupported { get; set; }
        bool IsMinimumScoreSupported { get; set; }
        bool IsResultDatatypeTypeSupported { get; set; }
    }
 
}
// Aggregate: GraduationPlanType

namespace EdFi.Ods.Entities.Common //.GraduationPlanTypeAggregate
{ 
    public static class GraduationPlanTypeMapper 
    {
        public static bool SynchronizeTo(this IGraduationPlanType source, IGraduationPlanType target)
        {
            bool isModified = false;

            var sourceSupport = source as IGraduationPlanTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.GraduationPlanTypeId != target.GraduationPlanTypeId)
            {
                source.GraduationPlanTypeId = target.GraduationPlanTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IGraduationPlanType source, IGraduationPlanType target, Action<IGraduationPlanType, IGraduationPlanType> onMapped)
        {
            var sourceSynchSupport = source as IGraduationPlanTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IGraduationPlanTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.GraduationPlanTypeId = source.GraduationPlanTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IGraduationPlanTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: GraduationPlanTypeDescriptor

namespace EdFi.Ods.Entities.Common //.GraduationPlanTypeDescriptorAggregate
{ 
    public static class GraduationPlanTypeDescriptorMapper 
    {
        public static bool SynchronizeTo(this IGraduationPlanTypeDescriptor source, IGraduationPlanTypeDescriptor target)
        {
            bool isModified = false;

            var sourceSupport = source as IGraduationPlanTypeDescriptorSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.GraduationPlanTypeDescriptorId != target.GraduationPlanTypeDescriptorId)
            {
                source.GraduationPlanTypeDescriptorId = target.GraduationPlanTypeDescriptorId;
            }

            // Copy inherited non-PK properties


            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveBeginDateSupported)
                && target.EffectiveBeginDate != source.EffectiveBeginDate)
            {
                target.EffectiveBeginDate = source.EffectiveBeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveEndDateSupported)
                && target.EffectiveEndDate != source.EffectiveEndDate)
            {
                target.EffectiveEndDate = source.EffectiveEndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNamespaceSupported)
                && target.Namespace != source.Namespace)
            {
                target.Namespace = source.Namespace;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPriorDescriptorIdSupported)
                && target.PriorDescriptorId != source.PriorDescriptorId)
            {
                target.PriorDescriptorId = source.PriorDescriptorId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsGraduationPlanTypeSupported)
                && target.GraduationPlanType != source.GraduationPlanType)
            {
                target.GraduationPlanType = source.GraduationPlanType;
                isModified = true;
            }

            // Synch inherited lists


            // Sync lists

            return isModified;
        }



        public static void MapTo(this IGraduationPlanTypeDescriptor source, IGraduationPlanTypeDescriptor target, Action<IGraduationPlanTypeDescriptor, IGraduationPlanTypeDescriptor> onMapped)
        {
            var sourceSynchSupport = source as IGraduationPlanTypeDescriptorSynchronizationSourceSupport;
            var targetSynchSupport = target as IGraduationPlanTypeDescriptorSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.GraduationPlanTypeDescriptorId = source.GraduationPlanTypeDescriptorId;

            // Copy inherited non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsEffectiveBeginDateSupported)
                target.EffectiveBeginDate = source.EffectiveBeginDate;
            else
                targetSynchSupport.IsEffectiveBeginDateSupported = false;

            if (sourceSynchSupport.IsEffectiveEndDateSupported)
                target.EffectiveEndDate = source.EffectiveEndDate;
            else
                targetSynchSupport.IsEffectiveEndDateSupported = false;

            if (sourceSynchSupport.IsNamespaceSupported)
                target.Namespace = source.Namespace;
            else
                targetSynchSupport.IsNamespaceSupported = false;

            if (sourceSynchSupport.IsPriorDescriptorIdSupported)
                target.PriorDescriptorId = source.PriorDescriptorId;
            else
                targetSynchSupport.IsPriorDescriptorIdSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Copy non-PK properties

            if (sourceSynchSupport.IsGraduationPlanTypeSupported)
                target.GraduationPlanType = source.GraduationPlanType;
            else
                targetSynchSupport.IsGraduationPlanTypeSupported = false;

            // Map inherited lists

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IGraduationPlanTypeDescriptorSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsEffectiveBeginDateSupported { get; set; }
        bool IsEffectiveEndDateSupported { get; set; }
        bool IsGraduationPlanTypeSupported { get; set; }
        bool IsNamespaceSupported { get; set; }
        bool IsPriorDescriptorIdSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: GunFreeSchoolsActReportingStatusType

namespace EdFi.Ods.Entities.Common //.GunFreeSchoolsActReportingStatusTypeAggregate
{ 
    public static class GunFreeSchoolsActReportingStatusTypeMapper 
    {
        public static bool SynchronizeTo(this IGunFreeSchoolsActReportingStatusType source, IGunFreeSchoolsActReportingStatusType target)
        {
            bool isModified = false;

            var sourceSupport = source as IGunFreeSchoolsActReportingStatusTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.GunFreeSchoolsActReportingStatusTypeId != target.GunFreeSchoolsActReportingStatusTypeId)
            {
                source.GunFreeSchoolsActReportingStatusTypeId = target.GunFreeSchoolsActReportingStatusTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IGunFreeSchoolsActReportingStatusType source, IGunFreeSchoolsActReportingStatusType target, Action<IGunFreeSchoolsActReportingStatusType, IGunFreeSchoolsActReportingStatusType> onMapped)
        {
            var sourceSynchSupport = source as IGunFreeSchoolsActReportingStatusTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IGunFreeSchoolsActReportingStatusTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.GunFreeSchoolsActReportingStatusTypeId = source.GunFreeSchoolsActReportingStatusTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IGunFreeSchoolsActReportingStatusTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: IdentificationDocumentUseType

namespace EdFi.Ods.Entities.Common //.IdentificationDocumentUseTypeAggregate
{ 
    public static class IdentificationDocumentUseTypeMapper 
    {
        public static bool SynchronizeTo(this IIdentificationDocumentUseType source, IIdentificationDocumentUseType target)
        {
            bool isModified = false;

            var sourceSupport = source as IIdentificationDocumentUseTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.IdentificationDocumentUseTypeId != target.IdentificationDocumentUseTypeId)
            {
                source.IdentificationDocumentUseTypeId = target.IdentificationDocumentUseTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IIdentificationDocumentUseType source, IIdentificationDocumentUseType target, Action<IIdentificationDocumentUseType, IIdentificationDocumentUseType> onMapped)
        {
            var sourceSynchSupport = source as IIdentificationDocumentUseTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IIdentificationDocumentUseTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.IdentificationDocumentUseTypeId = source.IdentificationDocumentUseTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IIdentificationDocumentUseTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: IncidentLocationType

namespace EdFi.Ods.Entities.Common //.IncidentLocationTypeAggregate
{ 
    public static class IncidentLocationTypeMapper 
    {
        public static bool SynchronizeTo(this IIncidentLocationType source, IIncidentLocationType target)
        {
            bool isModified = false;

            var sourceSupport = source as IIncidentLocationTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.IncidentLocationTypeId != target.IncidentLocationTypeId)
            {
                source.IncidentLocationTypeId = target.IncidentLocationTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IIncidentLocationType source, IIncidentLocationType target, Action<IIncidentLocationType, IIncidentLocationType> onMapped)
        {
            var sourceSynchSupport = source as IIncidentLocationTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IIncidentLocationTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.IncidentLocationTypeId = source.IncidentLocationTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IIncidentLocationTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: InstitutionTelephoneNumberType

namespace EdFi.Ods.Entities.Common //.InstitutionTelephoneNumberTypeAggregate
{ 
    public static class InstitutionTelephoneNumberTypeMapper 
    {
        public static bool SynchronizeTo(this IInstitutionTelephoneNumberType source, IInstitutionTelephoneNumberType target)
        {
            bool isModified = false;

            var sourceSupport = source as IInstitutionTelephoneNumberTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.InstitutionTelephoneNumberTypeId != target.InstitutionTelephoneNumberTypeId)
            {
                source.InstitutionTelephoneNumberTypeId = target.InstitutionTelephoneNumberTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IInstitutionTelephoneNumberType source, IInstitutionTelephoneNumberType target, Action<IInstitutionTelephoneNumberType, IInstitutionTelephoneNumberType> onMapped)
        {
            var sourceSynchSupport = source as IInstitutionTelephoneNumberTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IInstitutionTelephoneNumberTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.InstitutionTelephoneNumberTypeId = source.InstitutionTelephoneNumberTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IInstitutionTelephoneNumberTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: IntegratedTechnologyStatusType

namespace EdFi.Ods.Entities.Common //.IntegratedTechnologyStatusTypeAggregate
{ 
    public static class IntegratedTechnologyStatusTypeMapper 
    {
        public static bool SynchronizeTo(this IIntegratedTechnologyStatusType source, IIntegratedTechnologyStatusType target)
        {
            bool isModified = false;

            var sourceSupport = source as IIntegratedTechnologyStatusTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.IntegratedTechnologyStatusTypeId != target.IntegratedTechnologyStatusTypeId)
            {
                source.IntegratedTechnologyStatusTypeId = target.IntegratedTechnologyStatusTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IIntegratedTechnologyStatusType source, IIntegratedTechnologyStatusType target, Action<IIntegratedTechnologyStatusType, IIntegratedTechnologyStatusType> onMapped)
        {
            var sourceSynchSupport = source as IIntegratedTechnologyStatusTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IIntegratedTechnologyStatusTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.IntegratedTechnologyStatusTypeId = source.IntegratedTechnologyStatusTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IIntegratedTechnologyStatusTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: InteractivityStyleType

namespace EdFi.Ods.Entities.Common //.InteractivityStyleTypeAggregate
{ 
    public static class InteractivityStyleTypeMapper 
    {
        public static bool SynchronizeTo(this IInteractivityStyleType source, IInteractivityStyleType target)
        {
            bool isModified = false;

            var sourceSupport = source as IInteractivityStyleTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.InteractivityStyleTypeId != target.InteractivityStyleTypeId)
            {
                source.InteractivityStyleTypeId = target.InteractivityStyleTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IInteractivityStyleType source, IInteractivityStyleType target, Action<IInteractivityStyleType, IInteractivityStyleType> onMapped)
        {
            var sourceSynchSupport = source as IInteractivityStyleTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IInteractivityStyleTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.InteractivityStyleTypeId = source.InteractivityStyleTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IInteractivityStyleTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: InternetAccessType

namespace EdFi.Ods.Entities.Common //.InternetAccessTypeAggregate
{ 
    public static class InternetAccessTypeMapper 
    {
        public static bool SynchronizeTo(this IInternetAccessType source, IInternetAccessType target)
        {
            bool isModified = false;

            var sourceSupport = source as IInternetAccessTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.InternetAccessTypeId != target.InternetAccessTypeId)
            {
                source.InternetAccessTypeId = target.InternetAccessTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IInternetAccessType source, IInternetAccessType target, Action<IInternetAccessType, IInternetAccessType> onMapped)
        {
            var sourceSynchSupport = source as IInternetAccessTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IInternetAccessTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.InternetAccessTypeId = source.InternetAccessTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IInternetAccessTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: Intervention

namespace EdFi.Ods.Entities.Common //.InterventionAggregate
{ 
    public static class InterventionMapper 
    {
        public static bool SynchronizeTo(this IIntervention source, IIntervention target)
        {
            bool isModified = false;

            var sourceSupport = source as IInterventionSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.EducationOrganizationId != target.EducationOrganizationId)
            {
                source.EducationOrganizationId = target.EducationOrganizationId;
            }
            if (source.InterventionIdentificationCode != target.InterventionIdentificationCode)
            {
                source.InterventionIdentificationCode = target.InterventionIdentificationCode;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsBeginDateSupported)
                && target.BeginDate != source.BeginDate)
            {
                target.BeginDate = source.BeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDeliveryMethodTypeSupported)
                && target.DeliveryMethodType != source.DeliveryMethodType)
            {
                target.DeliveryMethodType = source.DeliveryMethodType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEndDateSupported)
                && target.EndDate != source.EndDate)
            {
                target.EndDate = source.EndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsInterventionClassTypeSupported)
                && target.InterventionClassType != source.InterventionClassType)
            {
                target.InterventionClassType = source.InterventionClassType;
                isModified = true;
            }



            // Sync lists
            if (sourceSupport == null || sourceSupport.IsInterventionAppropriateGradeLevelsSupported)
                isModified |= source.InterventionAppropriateGradeLevels.SynchronizeListTo(target.InterventionAppropriateGradeLevels, child => child.Intervention = target,
                                sourceSupport == null ? null : sourceSupport.IsInterventionAppropriateGradeLevelIncluded);

            if (sourceSupport == null || sourceSupport.IsInterventionAppropriateSexesSupported)
                isModified |= source.InterventionAppropriateSexes.SynchronizeListTo(target.InterventionAppropriateSexes, child => child.Intervention = target,
                                sourceSupport == null ? null : sourceSupport.IsInterventionAppropriateSexIncluded);

            if (sourceSupport == null || sourceSupport.IsInterventionDiagnosesSupported)
                isModified |= source.InterventionDiagnoses.SynchronizeListTo(target.InterventionDiagnoses, child => child.Intervention = target,
                                sourceSupport == null ? null : sourceSupport.IsInterventionDiagnosisIncluded);

            if (sourceSupport == null || sourceSupport.IsInterventionEducationContentsSupported)
                isModified |= source.InterventionEducationContents.SynchronizeListTo(target.InterventionEducationContents, child => child.Intervention = target,
                                sourceSupport == null ? null : sourceSupport.IsInterventionEducationContentIncluded);

            if (sourceSupport == null || sourceSupport.IsInterventionInterventionPrescriptionsSupported)
                isModified |= source.InterventionInterventionPrescriptions.SynchronizeListTo(target.InterventionInterventionPrescriptions, child => child.Intervention = target,
                                sourceSupport == null ? null : sourceSupport.IsInterventionInterventionPrescriptionIncluded);

            if (sourceSupport == null || sourceSupport.IsInterventionLearningResourceMetadataURIsSupported)
                isModified |= source.InterventionLearningResourceMetadataURIs.SynchronizeListTo(target.InterventionLearningResourceMetadataURIs, child => child.Intervention = target,
                                sourceSupport == null ? null : sourceSupport.IsInterventionLearningResourceMetadataURIIncluded);

            if (sourceSupport == null || sourceSupport.IsInterventionMeetingTimesSupported)
                isModified |= source.InterventionMeetingTimes.SynchronizeListTo(target.InterventionMeetingTimes, child => child.Intervention = target,
                                sourceSupport == null ? null : sourceSupport.IsInterventionMeetingTimeIncluded);

            if (sourceSupport == null || sourceSupport.IsInterventionPopulationServedsSupported)
                isModified |= source.InterventionPopulationServeds.SynchronizeListTo(target.InterventionPopulationServeds, child => child.Intervention = target,
                                sourceSupport == null ? null : sourceSupport.IsInterventionPopulationServedIncluded);

            if (sourceSupport == null || sourceSupport.IsInterventionStaffsSupported)
                isModified |= source.InterventionStaffs.SynchronizeListTo(target.InterventionStaffs, child => child.Intervention = target,
                                sourceSupport == null ? null : sourceSupport.IsInterventionStaffIncluded);

            if (sourceSupport == null || sourceSupport.IsInterventionURIsSupported)
                isModified |= source.InterventionURIs.SynchronizeListTo(target.InterventionURIs, child => child.Intervention = target,
                                sourceSupport == null ? null : sourceSupport.IsInterventionURIIncluded);


            return isModified;
        }



        public static void MapTo(this IIntervention source, IIntervention target, Action<IIntervention, IIntervention> onMapped)
        {
            var sourceSynchSupport = source as IInterventionSynchronizationSourceSupport;
            var targetSynchSupport = target as IInterventionSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.EducationOrganizationId = source.EducationOrganizationId;
            target.InterventionIdentificationCode = source.InterventionIdentificationCode;

            // Copy non-PK properties

            if (sourceSynchSupport.IsBeginDateSupported)
                target.BeginDate = source.BeginDate;
            else
                targetSynchSupport.IsBeginDateSupported = false;

            if (sourceSynchSupport.IsDeliveryMethodTypeSupported)
                target.DeliveryMethodType = source.DeliveryMethodType;
            else
                targetSynchSupport.IsDeliveryMethodTypeSupported = false;

            if (sourceSynchSupport.IsEndDateSupported)
                target.EndDate = source.EndDate;
            else
                targetSynchSupport.IsEndDateSupported = false;

            if (sourceSynchSupport.IsInterventionClassTypeSupported)
                target.InterventionClassType = source.InterventionClassType;
            else
                targetSynchSupport.IsInterventionClassTypeSupported = false;

            // Map lists

            if (sourceSynchSupport.IsInterventionAppropriateGradeLevelsSupported)
            {    
                targetSynchSupport.IsInterventionAppropriateGradeLevelIncluded = sourceSynchSupport.IsInterventionAppropriateGradeLevelIncluded;
                source.InterventionAppropriateGradeLevels.MapListTo(target.InterventionAppropriateGradeLevels);
            }
            else
            {
                targetSynchSupport.IsInterventionAppropriateGradeLevelsSupported = false;
            }

            if (sourceSynchSupport.IsInterventionAppropriateSexesSupported)
            {    
                targetSynchSupport.IsInterventionAppropriateSexIncluded = sourceSynchSupport.IsInterventionAppropriateSexIncluded;
                source.InterventionAppropriateSexes.MapListTo(target.InterventionAppropriateSexes);
            }
            else
            {
                targetSynchSupport.IsInterventionAppropriateSexesSupported = false;
            }

            if (sourceSynchSupport.IsInterventionDiagnosesSupported)
            {    
                targetSynchSupport.IsInterventionDiagnosisIncluded = sourceSynchSupport.IsInterventionDiagnosisIncluded;
                source.InterventionDiagnoses.MapListTo(target.InterventionDiagnoses);
            }
            else
            {
                targetSynchSupport.IsInterventionDiagnosesSupported = false;
            }

            if (sourceSynchSupport.IsInterventionEducationContentsSupported)
            {    
                targetSynchSupport.IsInterventionEducationContentIncluded = sourceSynchSupport.IsInterventionEducationContentIncluded;
                source.InterventionEducationContents.MapListTo(target.InterventionEducationContents);
            }
            else
            {
                targetSynchSupport.IsInterventionEducationContentsSupported = false;
            }

            if (sourceSynchSupport.IsInterventionInterventionPrescriptionsSupported)
            {    
                targetSynchSupport.IsInterventionInterventionPrescriptionIncluded = sourceSynchSupport.IsInterventionInterventionPrescriptionIncluded;
                source.InterventionInterventionPrescriptions.MapListTo(target.InterventionInterventionPrescriptions);
            }
            else
            {
                targetSynchSupport.IsInterventionInterventionPrescriptionsSupported = false;
            }

            if (sourceSynchSupport.IsInterventionLearningResourceMetadataURIsSupported)
            {    
                targetSynchSupport.IsInterventionLearningResourceMetadataURIIncluded = sourceSynchSupport.IsInterventionLearningResourceMetadataURIIncluded;
                source.InterventionLearningResourceMetadataURIs.MapListTo(target.InterventionLearningResourceMetadataURIs);
            }
            else
            {
                targetSynchSupport.IsInterventionLearningResourceMetadataURIsSupported = false;
            }

            if (sourceSynchSupport.IsInterventionMeetingTimesSupported)
            {    
                targetSynchSupport.IsInterventionMeetingTimeIncluded = sourceSynchSupport.IsInterventionMeetingTimeIncluded;
                source.InterventionMeetingTimes.MapListTo(target.InterventionMeetingTimes);
            }
            else
            {
                targetSynchSupport.IsInterventionMeetingTimesSupported = false;
            }

            if (sourceSynchSupport.IsInterventionPopulationServedsSupported)
            {    
                targetSynchSupport.IsInterventionPopulationServedIncluded = sourceSynchSupport.IsInterventionPopulationServedIncluded;
                source.InterventionPopulationServeds.MapListTo(target.InterventionPopulationServeds);
            }
            else
            {
                targetSynchSupport.IsInterventionPopulationServedsSupported = false;
            }

            if (sourceSynchSupport.IsInterventionStaffsSupported)
            {    
                targetSynchSupport.IsInterventionStaffIncluded = sourceSynchSupport.IsInterventionStaffIncluded;
                source.InterventionStaffs.MapListTo(target.InterventionStaffs);
            }
            else
            {
                targetSynchSupport.IsInterventionStaffsSupported = false;
            }

            if (sourceSynchSupport.IsInterventionURIsSupported)
            {    
                targetSynchSupport.IsInterventionURIIncluded = sourceSynchSupport.IsInterventionURIIncluded;
                source.InterventionURIs.MapListTo(target.InterventionURIs);
            }
            else
            {
                targetSynchSupport.IsInterventionURIsSupported = false;
            }

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IInterventionSynchronizationSourceSupport
    {
        bool IsBeginDateSupported { get; set; }
        bool IsDeliveryMethodTypeSupported { get; set; }
        bool IsEndDateSupported { get; set; }
        bool IsInterventionAppropriateGradeLevelsSupported { get; set; }
        bool IsInterventionAppropriateSexesSupported { get; set; }
        bool IsInterventionClassTypeSupported { get; set; }
        bool IsInterventionDiagnosesSupported { get; set; }
        bool IsInterventionEducationContentsSupported { get; set; }
        bool IsInterventionInterventionPrescriptionsSupported { get; set; }
        bool IsInterventionLearningResourceMetadataURIsSupported { get; set; }
        bool IsInterventionMeetingTimesSupported { get; set; }
        bool IsInterventionPopulationServedsSupported { get; set; }
        bool IsInterventionStaffsSupported { get; set; }
        bool IsInterventionURIsSupported { get; set; }
        Func<IInterventionAppropriateGradeLevel, bool> IsInterventionAppropriateGradeLevelIncluded { get; set; }
        Func<IInterventionAppropriateSex, bool> IsInterventionAppropriateSexIncluded { get; set; }
        Func<IInterventionDiagnosis, bool> IsInterventionDiagnosisIncluded { get; set; }
        Func<IInterventionEducationContent, bool> IsInterventionEducationContentIncluded { get; set; }
        Func<IInterventionInterventionPrescription, bool> IsInterventionInterventionPrescriptionIncluded { get; set; }
        Func<IInterventionLearningResourceMetadataURI, bool> IsInterventionLearningResourceMetadataURIIncluded { get; set; }
        Func<IInterventionMeetingTime, bool> IsInterventionMeetingTimeIncluded { get; set; }
        Func<IInterventionPopulationServed, bool> IsInterventionPopulationServedIncluded { get; set; }
        Func<IInterventionStaff, bool> IsInterventionStaffIncluded { get; set; }
        Func<IInterventionURI, bool> IsInterventionURIIncluded { get; set; }
    }
 
    public static class InterventionAppropriateGradeLevelMapper 
    {
        public static bool SynchronizeTo(this IInterventionAppropriateGradeLevel source, IInterventionAppropriateGradeLevel target)
        {
            bool isModified = false;

            var sourceSupport = source as IInterventionAppropriateGradeLevelSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.GradeLevelDescriptor != target.GradeLevelDescriptor)
            {
                source.GradeLevelDescriptor = target.GradeLevelDescriptor;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IInterventionAppropriateGradeLevel source, IInterventionAppropriateGradeLevel target, Action<IInterventionAppropriateGradeLevel, IInterventionAppropriateGradeLevel> onMapped)
        {
            var sourceSynchSupport = source as IInterventionAppropriateGradeLevelSynchronizationSourceSupport;
            var targetSynchSupport = target as IInterventionAppropriateGradeLevelSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.GradeLevelDescriptor = source.GradeLevelDescriptor;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IInterventionAppropriateGradeLevelSynchronizationSourceSupport
    {
    }
 
    public static class InterventionAppropriateSexMapper 
    {
        public static bool SynchronizeTo(this IInterventionAppropriateSex source, IInterventionAppropriateSex target)
        {
            bool isModified = false;

            var sourceSupport = source as IInterventionAppropriateSexSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.SexType != target.SexType)
            {
                source.SexType = target.SexType;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IInterventionAppropriateSex source, IInterventionAppropriateSex target, Action<IInterventionAppropriateSex, IInterventionAppropriateSex> onMapped)
        {
            var sourceSynchSupport = source as IInterventionAppropriateSexSynchronizationSourceSupport;
            var targetSynchSupport = target as IInterventionAppropriateSexSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.SexType = source.SexType;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IInterventionAppropriateSexSynchronizationSourceSupport
    {
    }
 
    public static class InterventionDiagnosisMapper 
    {
        public static bool SynchronizeTo(this IInterventionDiagnosis source, IInterventionDiagnosis target)
        {
            bool isModified = false;

            var sourceSupport = source as IInterventionDiagnosisSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.DiagnosisDescriptor != target.DiagnosisDescriptor)
            {
                source.DiagnosisDescriptor = target.DiagnosisDescriptor;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IInterventionDiagnosis source, IInterventionDiagnosis target, Action<IInterventionDiagnosis, IInterventionDiagnosis> onMapped)
        {
            var sourceSynchSupport = source as IInterventionDiagnosisSynchronizationSourceSupport;
            var targetSynchSupport = target as IInterventionDiagnosisSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.DiagnosisDescriptor = source.DiagnosisDescriptor;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IInterventionDiagnosisSynchronizationSourceSupport
    {
    }
 
    public static class InterventionEducationContentMapper 
    {
        public static bool SynchronizeTo(this IInterventionEducationContent source, IInterventionEducationContent target)
        {
            bool isModified = false;

            var sourceSupport = source as IInterventionEducationContentSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.ContentIdentifier != target.ContentIdentifier)
            {
                source.ContentIdentifier = target.ContentIdentifier;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IInterventionEducationContent source, IInterventionEducationContent target, Action<IInterventionEducationContent, IInterventionEducationContent> onMapped)
        {
            var sourceSynchSupport = source as IInterventionEducationContentSynchronizationSourceSupport;
            var targetSynchSupport = target as IInterventionEducationContentSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.ContentIdentifier = source.ContentIdentifier;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IInterventionEducationContentSynchronizationSourceSupport
    {
    }
 
    public static class InterventionInterventionPrescriptionMapper 
    {
        public static bool SynchronizeTo(this IInterventionInterventionPrescription source, IInterventionInterventionPrescription target)
        {
            bool isModified = false;

            var sourceSupport = source as IInterventionInterventionPrescriptionSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.InterventionPrescriptionEducationOrganizationId != target.InterventionPrescriptionEducationOrganizationId)
            {
                source.InterventionPrescriptionEducationOrganizationId = target.InterventionPrescriptionEducationOrganizationId;
            }
            if (source.InterventionPrescriptionIdentificationCode != target.InterventionPrescriptionIdentificationCode)
            {
                source.InterventionPrescriptionIdentificationCode = target.InterventionPrescriptionIdentificationCode;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IInterventionInterventionPrescription source, IInterventionInterventionPrescription target, Action<IInterventionInterventionPrescription, IInterventionInterventionPrescription> onMapped)
        {
            var sourceSynchSupport = source as IInterventionInterventionPrescriptionSynchronizationSourceSupport;
            var targetSynchSupport = target as IInterventionInterventionPrescriptionSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.InterventionPrescriptionEducationOrganizationId = source.InterventionPrescriptionEducationOrganizationId;
            target.InterventionPrescriptionIdentificationCode = source.InterventionPrescriptionIdentificationCode;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IInterventionInterventionPrescriptionSynchronizationSourceSupport
    {
    }
 
    public static class InterventionLearningResourceMetadataURIMapper 
    {
        public static bool SynchronizeTo(this IInterventionLearningResourceMetadataURI source, IInterventionLearningResourceMetadataURI target)
        {
            bool isModified = false;

            var sourceSupport = source as IInterventionLearningResourceMetadataURISynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.LearningResourceMetadataURI != target.LearningResourceMetadataURI)
            {
                source.LearningResourceMetadataURI = target.LearningResourceMetadataURI;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IInterventionLearningResourceMetadataURI source, IInterventionLearningResourceMetadataURI target, Action<IInterventionLearningResourceMetadataURI, IInterventionLearningResourceMetadataURI> onMapped)
        {
            var sourceSynchSupport = source as IInterventionLearningResourceMetadataURISynchronizationSourceSupport;
            var targetSynchSupport = target as IInterventionLearningResourceMetadataURISynchronizationSourceSupport;

            // Copy contextual primary key values
            target.LearningResourceMetadataURI = source.LearningResourceMetadataURI;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IInterventionLearningResourceMetadataURISynchronizationSourceSupport
    {
    }
 
    public static class InterventionMeetingTimeMapper 
    {
        public static bool SynchronizeTo(this IInterventionMeetingTime source, IInterventionMeetingTime target)
        {
            bool isModified = false;

            var sourceSupport = source as IInterventionMeetingTimeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.ClassPeriodName != target.ClassPeriodName)
            {
                source.ClassPeriodName = target.ClassPeriodName;
            }
            if (source.SchoolId != target.SchoolId)
            {
                source.SchoolId = target.SchoolId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsAlternateDayNameSupported)
                && target.AlternateDayName != source.AlternateDayName)
            {
                target.AlternateDayName = source.AlternateDayName;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEndTimeSupported)
                && target.EndTime != source.EndTime)
            {
                target.EndTime = source.EndTime;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsOfficialAttendancePeriodSupported)
                && target.OfficialAttendancePeriod != source.OfficialAttendancePeriod)
            {
                target.OfficialAttendancePeriod = source.OfficialAttendancePeriod;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsStartTimeSupported)
                && target.StartTime != source.StartTime)
            {
                target.StartTime = source.StartTime;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IInterventionMeetingTime source, IInterventionMeetingTime target, Action<IInterventionMeetingTime, IInterventionMeetingTime> onMapped)
        {
            var sourceSynchSupport = source as IInterventionMeetingTimeSynchronizationSourceSupport;
            var targetSynchSupport = target as IInterventionMeetingTimeSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.ClassPeriodName = source.ClassPeriodName;
            target.SchoolId = source.SchoolId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsAlternateDayNameSupported)
                target.AlternateDayName = source.AlternateDayName;
            else
                targetSynchSupport.IsAlternateDayNameSupported = false;

            if (sourceSynchSupport.IsEndTimeSupported)
                target.EndTime = source.EndTime;
            else
                targetSynchSupport.IsEndTimeSupported = false;

            if (sourceSynchSupport.IsOfficialAttendancePeriodSupported)
                target.OfficialAttendancePeriod = source.OfficialAttendancePeriod;
            else
                targetSynchSupport.IsOfficialAttendancePeriodSupported = false;

            if (sourceSynchSupport.IsStartTimeSupported)
                target.StartTime = source.StartTime;
            else
                targetSynchSupport.IsStartTimeSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IInterventionMeetingTimeSynchronizationSourceSupport
    {
        bool IsAlternateDayNameSupported { get; set; }
        bool IsEndTimeSupported { get; set; }
        bool IsOfficialAttendancePeriodSupported { get; set; }
        bool IsStartTimeSupported { get; set; }
    }
 
    public static class InterventionPopulationServedMapper 
    {
        public static bool SynchronizeTo(this IInterventionPopulationServed source, IInterventionPopulationServed target)
        {
            bool isModified = false;

            var sourceSupport = source as IInterventionPopulationServedSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.PopulationServedType != target.PopulationServedType)
            {
                source.PopulationServedType = target.PopulationServedType;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IInterventionPopulationServed source, IInterventionPopulationServed target, Action<IInterventionPopulationServed, IInterventionPopulationServed> onMapped)
        {
            var sourceSynchSupport = source as IInterventionPopulationServedSynchronizationSourceSupport;
            var targetSynchSupport = target as IInterventionPopulationServedSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.PopulationServedType = source.PopulationServedType;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IInterventionPopulationServedSynchronizationSourceSupport
    {
    }
 
    public static class InterventionStaffMapper 
    {
        public static bool SynchronizeTo(this IInterventionStaff source, IInterventionStaff target)
        {
            bool isModified = false;

            var sourceSupport = source as IInterventionStaffSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.StaffUniqueId != target.StaffUniqueId)
            {
                source.StaffUniqueId = target.StaffUniqueId;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IInterventionStaff source, IInterventionStaff target, Action<IInterventionStaff, IInterventionStaff> onMapped)
        {
            var sourceSynchSupport = source as IInterventionStaffSynchronizationSourceSupport;
            var targetSynchSupport = target as IInterventionStaffSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.StaffUniqueId = source.StaffUniqueId;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IInterventionStaffSynchronizationSourceSupport
    {
    }
 
    public static class InterventionURIMapper 
    {
        public static bool SynchronizeTo(this IInterventionURI source, IInterventionURI target)
        {
            bool isModified = false;

            var sourceSupport = source as IInterventionURISynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.URI != target.URI)
            {
                source.URI = target.URI;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IInterventionURI source, IInterventionURI target, Action<IInterventionURI, IInterventionURI> onMapped)
        {
            var sourceSynchSupport = source as IInterventionURISynchronizationSourceSupport;
            var targetSynchSupport = target as IInterventionURISynchronizationSourceSupport;

            // Copy contextual primary key values
            target.URI = source.URI;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IInterventionURISynchronizationSourceSupport
    {
    }
 
}
// Aggregate: InterventionClassType

namespace EdFi.Ods.Entities.Common //.InterventionClassTypeAggregate
{ 
    public static class InterventionClassTypeMapper 
    {
        public static bool SynchronizeTo(this IInterventionClassType source, IInterventionClassType target)
        {
            bool isModified = false;

            var sourceSupport = source as IInterventionClassTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.InterventionClassTypeId != target.InterventionClassTypeId)
            {
                source.InterventionClassTypeId = target.InterventionClassTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IInterventionClassType source, IInterventionClassType target, Action<IInterventionClassType, IInterventionClassType> onMapped)
        {
            var sourceSynchSupport = source as IInterventionClassTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IInterventionClassTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.InterventionClassTypeId = source.InterventionClassTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IInterventionClassTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: InterventionEffectivenessRatingType

namespace EdFi.Ods.Entities.Common //.InterventionEffectivenessRatingTypeAggregate
{ 
    public static class InterventionEffectivenessRatingTypeMapper 
    {
        public static bool SynchronizeTo(this IInterventionEffectivenessRatingType source, IInterventionEffectivenessRatingType target)
        {
            bool isModified = false;

            var sourceSupport = source as IInterventionEffectivenessRatingTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.InterventionEffectivenessRatingTypeId != target.InterventionEffectivenessRatingTypeId)
            {
                source.InterventionEffectivenessRatingTypeId = target.InterventionEffectivenessRatingTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IInterventionEffectivenessRatingType source, IInterventionEffectivenessRatingType target, Action<IInterventionEffectivenessRatingType, IInterventionEffectivenessRatingType> onMapped)
        {
            var sourceSynchSupport = source as IInterventionEffectivenessRatingTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IInterventionEffectivenessRatingTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.InterventionEffectivenessRatingTypeId = source.InterventionEffectivenessRatingTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IInterventionEffectivenessRatingTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: InterventionPrescription

namespace EdFi.Ods.Entities.Common //.InterventionPrescriptionAggregate
{ 
    public static class InterventionPrescriptionMapper 
    {
        public static bool SynchronizeTo(this IInterventionPrescription source, IInterventionPrescription target)
        {
            bool isModified = false;

            var sourceSupport = source as IInterventionPrescriptionSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.EducationOrganizationId != target.EducationOrganizationId)
            {
                source.EducationOrganizationId = target.EducationOrganizationId;
            }
            if (source.InterventionPrescriptionIdentificationCode != target.InterventionPrescriptionIdentificationCode)
            {
                source.InterventionPrescriptionIdentificationCode = target.InterventionPrescriptionIdentificationCode;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsDeliveryMethodTypeSupported)
                && target.DeliveryMethodType != source.DeliveryMethodType)
            {
                target.DeliveryMethodType = source.DeliveryMethodType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsInterventionClassTypeSupported)
                && target.InterventionClassType != source.InterventionClassType)
            {
                target.InterventionClassType = source.InterventionClassType;
                isModified = true;
            }



            // Sync lists
            if (sourceSupport == null || sourceSupport.IsInterventionPrescriptionAppropriateGradeLevelsSupported)
                isModified |= source.InterventionPrescriptionAppropriateGradeLevels.SynchronizeListTo(target.InterventionPrescriptionAppropriateGradeLevels, child => child.InterventionPrescription = target,
                                sourceSupport == null ? null : sourceSupport.IsInterventionPrescriptionAppropriateGradeLevelIncluded);

            if (sourceSupport == null || sourceSupport.IsInterventionPrescriptionAppropriateSexesSupported)
                isModified |= source.InterventionPrescriptionAppropriateSexes.SynchronizeListTo(target.InterventionPrescriptionAppropriateSexes, child => child.InterventionPrescription = target,
                                sourceSupport == null ? null : sourceSupport.IsInterventionPrescriptionAppropriateSexIncluded);

            if (sourceSupport == null || sourceSupport.IsInterventionPrescriptionDiagnosesSupported)
                isModified |= source.InterventionPrescriptionDiagnoses.SynchronizeListTo(target.InterventionPrescriptionDiagnoses, child => child.InterventionPrescription = target,
                                sourceSupport == null ? null : sourceSupport.IsInterventionPrescriptionDiagnosisIncluded);

            if (sourceSupport == null || sourceSupport.IsInterventionPrescriptionEducationContentsSupported)
                isModified |= source.InterventionPrescriptionEducationContents.SynchronizeListTo(target.InterventionPrescriptionEducationContents, child => child.InterventionPrescription = target,
                                sourceSupport == null ? null : sourceSupport.IsInterventionPrescriptionEducationContentIncluded);

            if (sourceSupport == null || sourceSupport.IsInterventionPrescriptionLearningResourceMetadataURIsSupported)
                isModified |= source.InterventionPrescriptionLearningResourceMetadataURIs.SynchronizeListTo(target.InterventionPrescriptionLearningResourceMetadataURIs, child => child.InterventionPrescription = target,
                                sourceSupport == null ? null : sourceSupport.IsInterventionPrescriptionLearningResourceMetadataURIIncluded);

            if (sourceSupport == null || sourceSupport.IsInterventionPrescriptionPopulationServedsSupported)
                isModified |= source.InterventionPrescriptionPopulationServeds.SynchronizeListTo(target.InterventionPrescriptionPopulationServeds, child => child.InterventionPrescription = target,
                                sourceSupport == null ? null : sourceSupport.IsInterventionPrescriptionPopulationServedIncluded);

            if (sourceSupport == null || sourceSupport.IsInterventionPrescriptionURIsSupported)
                isModified |= source.InterventionPrescriptionURIs.SynchronizeListTo(target.InterventionPrescriptionURIs, child => child.InterventionPrescription = target,
                                sourceSupport == null ? null : sourceSupport.IsInterventionPrescriptionURIIncluded);


            return isModified;
        }



        public static void MapTo(this IInterventionPrescription source, IInterventionPrescription target, Action<IInterventionPrescription, IInterventionPrescription> onMapped)
        {
            var sourceSynchSupport = source as IInterventionPrescriptionSynchronizationSourceSupport;
            var targetSynchSupport = target as IInterventionPrescriptionSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.EducationOrganizationId = source.EducationOrganizationId;
            target.InterventionPrescriptionIdentificationCode = source.InterventionPrescriptionIdentificationCode;

            // Copy non-PK properties

            if (sourceSynchSupport.IsDeliveryMethodTypeSupported)
                target.DeliveryMethodType = source.DeliveryMethodType;
            else
                targetSynchSupport.IsDeliveryMethodTypeSupported = false;

            if (sourceSynchSupport.IsInterventionClassTypeSupported)
                target.InterventionClassType = source.InterventionClassType;
            else
                targetSynchSupport.IsInterventionClassTypeSupported = false;

            // Map lists

            if (sourceSynchSupport.IsInterventionPrescriptionAppropriateGradeLevelsSupported)
            {    
                targetSynchSupport.IsInterventionPrescriptionAppropriateGradeLevelIncluded = sourceSynchSupport.IsInterventionPrescriptionAppropriateGradeLevelIncluded;
                source.InterventionPrescriptionAppropriateGradeLevels.MapListTo(target.InterventionPrescriptionAppropriateGradeLevels);
            }
            else
            {
                targetSynchSupport.IsInterventionPrescriptionAppropriateGradeLevelsSupported = false;
            }

            if (sourceSynchSupport.IsInterventionPrescriptionAppropriateSexesSupported)
            {    
                targetSynchSupport.IsInterventionPrescriptionAppropriateSexIncluded = sourceSynchSupport.IsInterventionPrescriptionAppropriateSexIncluded;
                source.InterventionPrescriptionAppropriateSexes.MapListTo(target.InterventionPrescriptionAppropriateSexes);
            }
            else
            {
                targetSynchSupport.IsInterventionPrescriptionAppropriateSexesSupported = false;
            }

            if (sourceSynchSupport.IsInterventionPrescriptionDiagnosesSupported)
            {    
                targetSynchSupport.IsInterventionPrescriptionDiagnosisIncluded = sourceSynchSupport.IsInterventionPrescriptionDiagnosisIncluded;
                source.InterventionPrescriptionDiagnoses.MapListTo(target.InterventionPrescriptionDiagnoses);
            }
            else
            {
                targetSynchSupport.IsInterventionPrescriptionDiagnosesSupported = false;
            }

            if (sourceSynchSupport.IsInterventionPrescriptionEducationContentsSupported)
            {    
                targetSynchSupport.IsInterventionPrescriptionEducationContentIncluded = sourceSynchSupport.IsInterventionPrescriptionEducationContentIncluded;
                source.InterventionPrescriptionEducationContents.MapListTo(target.InterventionPrescriptionEducationContents);
            }
            else
            {
                targetSynchSupport.IsInterventionPrescriptionEducationContentsSupported = false;
            }

            if (sourceSynchSupport.IsInterventionPrescriptionLearningResourceMetadataURIsSupported)
            {    
                targetSynchSupport.IsInterventionPrescriptionLearningResourceMetadataURIIncluded = sourceSynchSupport.IsInterventionPrescriptionLearningResourceMetadataURIIncluded;
                source.InterventionPrescriptionLearningResourceMetadataURIs.MapListTo(target.InterventionPrescriptionLearningResourceMetadataURIs);
            }
            else
            {
                targetSynchSupport.IsInterventionPrescriptionLearningResourceMetadataURIsSupported = false;
            }

            if (sourceSynchSupport.IsInterventionPrescriptionPopulationServedsSupported)
            {    
                targetSynchSupport.IsInterventionPrescriptionPopulationServedIncluded = sourceSynchSupport.IsInterventionPrescriptionPopulationServedIncluded;
                source.InterventionPrescriptionPopulationServeds.MapListTo(target.InterventionPrescriptionPopulationServeds);
            }
            else
            {
                targetSynchSupport.IsInterventionPrescriptionPopulationServedsSupported = false;
            }

            if (sourceSynchSupport.IsInterventionPrescriptionURIsSupported)
            {    
                targetSynchSupport.IsInterventionPrescriptionURIIncluded = sourceSynchSupport.IsInterventionPrescriptionURIIncluded;
                source.InterventionPrescriptionURIs.MapListTo(target.InterventionPrescriptionURIs);
            }
            else
            {
                targetSynchSupport.IsInterventionPrescriptionURIsSupported = false;
            }

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IInterventionPrescriptionSynchronizationSourceSupport
    {
        bool IsDeliveryMethodTypeSupported { get; set; }
        bool IsInterventionClassTypeSupported { get; set; }
        bool IsInterventionPrescriptionAppropriateGradeLevelsSupported { get; set; }
        bool IsInterventionPrescriptionAppropriateSexesSupported { get; set; }
        bool IsInterventionPrescriptionDiagnosesSupported { get; set; }
        bool IsInterventionPrescriptionEducationContentsSupported { get; set; }
        bool IsInterventionPrescriptionLearningResourceMetadataURIsSupported { get; set; }
        bool IsInterventionPrescriptionPopulationServedsSupported { get; set; }
        bool IsInterventionPrescriptionURIsSupported { get; set; }
        Func<IInterventionPrescriptionAppropriateGradeLevel, bool> IsInterventionPrescriptionAppropriateGradeLevelIncluded { get; set; }
        Func<IInterventionPrescriptionAppropriateSex, bool> IsInterventionPrescriptionAppropriateSexIncluded { get; set; }
        Func<IInterventionPrescriptionDiagnosis, bool> IsInterventionPrescriptionDiagnosisIncluded { get; set; }
        Func<IInterventionPrescriptionEducationContent, bool> IsInterventionPrescriptionEducationContentIncluded { get; set; }
        Func<IInterventionPrescriptionLearningResourceMetadataURI, bool> IsInterventionPrescriptionLearningResourceMetadataURIIncluded { get; set; }
        Func<IInterventionPrescriptionPopulationServed, bool> IsInterventionPrescriptionPopulationServedIncluded { get; set; }
        Func<IInterventionPrescriptionURI, bool> IsInterventionPrescriptionURIIncluded { get; set; }
    }
 
    public static class InterventionPrescriptionAppropriateGradeLevelMapper 
    {
        public static bool SynchronizeTo(this IInterventionPrescriptionAppropriateGradeLevel source, IInterventionPrescriptionAppropriateGradeLevel target)
        {
            bool isModified = false;

            var sourceSupport = source as IInterventionPrescriptionAppropriateGradeLevelSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.GradeLevelDescriptor != target.GradeLevelDescriptor)
            {
                source.GradeLevelDescriptor = target.GradeLevelDescriptor;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IInterventionPrescriptionAppropriateGradeLevel source, IInterventionPrescriptionAppropriateGradeLevel target, Action<IInterventionPrescriptionAppropriateGradeLevel, IInterventionPrescriptionAppropriateGradeLevel> onMapped)
        {
            var sourceSynchSupport = source as IInterventionPrescriptionAppropriateGradeLevelSynchronizationSourceSupport;
            var targetSynchSupport = target as IInterventionPrescriptionAppropriateGradeLevelSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.GradeLevelDescriptor = source.GradeLevelDescriptor;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IInterventionPrescriptionAppropriateGradeLevelSynchronizationSourceSupport
    {
    }
 
    public static class InterventionPrescriptionAppropriateSexMapper 
    {
        public static bool SynchronizeTo(this IInterventionPrescriptionAppropriateSex source, IInterventionPrescriptionAppropriateSex target)
        {
            bool isModified = false;

            var sourceSupport = source as IInterventionPrescriptionAppropriateSexSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.SexType != target.SexType)
            {
                source.SexType = target.SexType;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IInterventionPrescriptionAppropriateSex source, IInterventionPrescriptionAppropriateSex target, Action<IInterventionPrescriptionAppropriateSex, IInterventionPrescriptionAppropriateSex> onMapped)
        {
            var sourceSynchSupport = source as IInterventionPrescriptionAppropriateSexSynchronizationSourceSupport;
            var targetSynchSupport = target as IInterventionPrescriptionAppropriateSexSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.SexType = source.SexType;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IInterventionPrescriptionAppropriateSexSynchronizationSourceSupport
    {
    }
 
    public static class InterventionPrescriptionDiagnosisMapper 
    {
        public static bool SynchronizeTo(this IInterventionPrescriptionDiagnosis source, IInterventionPrescriptionDiagnosis target)
        {
            bool isModified = false;

            var sourceSupport = source as IInterventionPrescriptionDiagnosisSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.DiagnosisDescriptor != target.DiagnosisDescriptor)
            {
                source.DiagnosisDescriptor = target.DiagnosisDescriptor;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IInterventionPrescriptionDiagnosis source, IInterventionPrescriptionDiagnosis target, Action<IInterventionPrescriptionDiagnosis, IInterventionPrescriptionDiagnosis> onMapped)
        {
            var sourceSynchSupport = source as IInterventionPrescriptionDiagnosisSynchronizationSourceSupport;
            var targetSynchSupport = target as IInterventionPrescriptionDiagnosisSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.DiagnosisDescriptor = source.DiagnosisDescriptor;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IInterventionPrescriptionDiagnosisSynchronizationSourceSupport
    {
    }
 
    public static class InterventionPrescriptionEducationContentMapper 
    {
        public static bool SynchronizeTo(this IInterventionPrescriptionEducationContent source, IInterventionPrescriptionEducationContent target)
        {
            bool isModified = false;

            var sourceSupport = source as IInterventionPrescriptionEducationContentSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.ContentIdentifier != target.ContentIdentifier)
            {
                source.ContentIdentifier = target.ContentIdentifier;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IInterventionPrescriptionEducationContent source, IInterventionPrescriptionEducationContent target, Action<IInterventionPrescriptionEducationContent, IInterventionPrescriptionEducationContent> onMapped)
        {
            var sourceSynchSupport = source as IInterventionPrescriptionEducationContentSynchronizationSourceSupport;
            var targetSynchSupport = target as IInterventionPrescriptionEducationContentSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.ContentIdentifier = source.ContentIdentifier;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IInterventionPrescriptionEducationContentSynchronizationSourceSupport
    {
    }
 
    public static class InterventionPrescriptionLearningResourceMetadataURIMapper 
    {
        public static bool SynchronizeTo(this IInterventionPrescriptionLearningResourceMetadataURI source, IInterventionPrescriptionLearningResourceMetadataURI target)
        {
            bool isModified = false;

            var sourceSupport = source as IInterventionPrescriptionLearningResourceMetadataURISynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.LearningResourceMetadataURI != target.LearningResourceMetadataURI)
            {
                source.LearningResourceMetadataURI = target.LearningResourceMetadataURI;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IInterventionPrescriptionLearningResourceMetadataURI source, IInterventionPrescriptionLearningResourceMetadataURI target, Action<IInterventionPrescriptionLearningResourceMetadataURI, IInterventionPrescriptionLearningResourceMetadataURI> onMapped)
        {
            var sourceSynchSupport = source as IInterventionPrescriptionLearningResourceMetadataURISynchronizationSourceSupport;
            var targetSynchSupport = target as IInterventionPrescriptionLearningResourceMetadataURISynchronizationSourceSupport;

            // Copy contextual primary key values
            target.LearningResourceMetadataURI = source.LearningResourceMetadataURI;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IInterventionPrescriptionLearningResourceMetadataURISynchronizationSourceSupport
    {
    }
 
    public static class InterventionPrescriptionPopulationServedMapper 
    {
        public static bool SynchronizeTo(this IInterventionPrescriptionPopulationServed source, IInterventionPrescriptionPopulationServed target)
        {
            bool isModified = false;

            var sourceSupport = source as IInterventionPrescriptionPopulationServedSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.PopulationServedType != target.PopulationServedType)
            {
                source.PopulationServedType = target.PopulationServedType;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IInterventionPrescriptionPopulationServed source, IInterventionPrescriptionPopulationServed target, Action<IInterventionPrescriptionPopulationServed, IInterventionPrescriptionPopulationServed> onMapped)
        {
            var sourceSynchSupport = source as IInterventionPrescriptionPopulationServedSynchronizationSourceSupport;
            var targetSynchSupport = target as IInterventionPrescriptionPopulationServedSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.PopulationServedType = source.PopulationServedType;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IInterventionPrescriptionPopulationServedSynchronizationSourceSupport
    {
    }
 
    public static class InterventionPrescriptionURIMapper 
    {
        public static bool SynchronizeTo(this IInterventionPrescriptionURI source, IInterventionPrescriptionURI target)
        {
            bool isModified = false;

            var sourceSupport = source as IInterventionPrescriptionURISynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.URI != target.URI)
            {
                source.URI = target.URI;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IInterventionPrescriptionURI source, IInterventionPrescriptionURI target, Action<IInterventionPrescriptionURI, IInterventionPrescriptionURI> onMapped)
        {
            var sourceSynchSupport = source as IInterventionPrescriptionURISynchronizationSourceSupport;
            var targetSynchSupport = target as IInterventionPrescriptionURISynchronizationSourceSupport;

            // Copy contextual primary key values
            target.URI = source.URI;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IInterventionPrescriptionURISynchronizationSourceSupport
    {
    }
 
}
// Aggregate: InterventionStudy

namespace EdFi.Ods.Entities.Common //.InterventionStudyAggregate
{ 
    public static class InterventionStudyMapper 
    {
        public static bool SynchronizeTo(this IInterventionStudy source, IInterventionStudy target)
        {
            bool isModified = false;

            var sourceSupport = source as IInterventionStudySynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.EducationOrganizationId != target.EducationOrganizationId)
            {
                source.EducationOrganizationId = target.EducationOrganizationId;
            }
            if (source.InterventionStudyIdentificationCode != target.InterventionStudyIdentificationCode)
            {
                source.InterventionStudyIdentificationCode = target.InterventionStudyIdentificationCode;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsDeliveryMethodTypeSupported)
                && target.DeliveryMethodType != source.DeliveryMethodType)
            {
                target.DeliveryMethodType = source.DeliveryMethodType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsInterventionClassTypeSupported)
                && target.InterventionClassType != source.InterventionClassType)
            {
                target.InterventionClassType = source.InterventionClassType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsInterventionPrescriptionEducationOrganizationIdSupported)
                && target.InterventionPrescriptionEducationOrganizationId != source.InterventionPrescriptionEducationOrganizationId)
            {
                target.InterventionPrescriptionEducationOrganizationId = source.InterventionPrescriptionEducationOrganizationId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsInterventionPrescriptionIdentificationCodeSupported)
                && target.InterventionPrescriptionIdentificationCode != source.InterventionPrescriptionIdentificationCode)
            {
                target.InterventionPrescriptionIdentificationCode = source.InterventionPrescriptionIdentificationCode;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsParticipantsSupported)
                && target.Participants != source.Participants)
            {
                target.Participants = source.Participants;
                isModified = true;
            }



            // Sync lists
            if (sourceSupport == null || sourceSupport.IsInterventionStudyAppropriateGradeLevelsSupported)
                isModified |= source.InterventionStudyAppropriateGradeLevels.SynchronizeListTo(target.InterventionStudyAppropriateGradeLevels, child => child.InterventionStudy = target,
                                sourceSupport == null ? null : sourceSupport.IsInterventionStudyAppropriateGradeLevelIncluded);

            if (sourceSupport == null || sourceSupport.IsInterventionStudyAppropriateSexesSupported)
                isModified |= source.InterventionStudyAppropriateSexes.SynchronizeListTo(target.InterventionStudyAppropriateSexes, child => child.InterventionStudy = target,
                                sourceSupport == null ? null : sourceSupport.IsInterventionStudyAppropriateSexIncluded);

            if (sourceSupport == null || sourceSupport.IsInterventionStudyEducationContentsSupported)
                isModified |= source.InterventionStudyEducationContents.SynchronizeListTo(target.InterventionStudyEducationContents, child => child.InterventionStudy = target,
                                sourceSupport == null ? null : sourceSupport.IsInterventionStudyEducationContentIncluded);

            if (sourceSupport == null || sourceSupport.IsInterventionStudyInterventionEffectivenessesSupported)
                isModified |= source.InterventionStudyInterventionEffectivenesses.SynchronizeListTo(target.InterventionStudyInterventionEffectivenesses, child => child.InterventionStudy = target,
                                sourceSupport == null ? null : sourceSupport.IsInterventionStudyInterventionEffectivenessIncluded);

            if (sourceSupport == null || sourceSupport.IsInterventionStudyLearningResourceMetadataURIsSupported)
                isModified |= source.InterventionStudyLearningResourceMetadataURIs.SynchronizeListTo(target.InterventionStudyLearningResourceMetadataURIs, child => child.InterventionStudy = target,
                                sourceSupport == null ? null : sourceSupport.IsInterventionStudyLearningResourceMetadataURIIncluded);

            if (sourceSupport == null || sourceSupport.IsInterventionStudyPopulationServedsSupported)
                isModified |= source.InterventionStudyPopulationServeds.SynchronizeListTo(target.InterventionStudyPopulationServeds, child => child.InterventionStudy = target,
                                sourceSupport == null ? null : sourceSupport.IsInterventionStudyPopulationServedIncluded);

            if (sourceSupport == null || sourceSupport.IsInterventionStudyStateAbbreviationsSupported)
                isModified |= source.InterventionStudyStateAbbreviations.SynchronizeListTo(target.InterventionStudyStateAbbreviations, child => child.InterventionStudy = target,
                                sourceSupport == null ? null : sourceSupport.IsInterventionStudyStateAbbreviationIncluded);

            if (sourceSupport == null || sourceSupport.IsInterventionStudyURIsSupported)
                isModified |= source.InterventionStudyURIs.SynchronizeListTo(target.InterventionStudyURIs, child => child.InterventionStudy = target,
                                sourceSupport == null ? null : sourceSupport.IsInterventionStudyURIIncluded);


            return isModified;
        }



        public static void MapTo(this IInterventionStudy source, IInterventionStudy target, Action<IInterventionStudy, IInterventionStudy> onMapped)
        {
            var sourceSynchSupport = source as IInterventionStudySynchronizationSourceSupport;
            var targetSynchSupport = target as IInterventionStudySynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.EducationOrganizationId = source.EducationOrganizationId;
            target.InterventionStudyIdentificationCode = source.InterventionStudyIdentificationCode;

            // Copy non-PK properties

            if (sourceSynchSupport.IsDeliveryMethodTypeSupported)
                target.DeliveryMethodType = source.DeliveryMethodType;
            else
                targetSynchSupport.IsDeliveryMethodTypeSupported = false;

            if (sourceSynchSupport.IsInterventionClassTypeSupported)
                target.InterventionClassType = source.InterventionClassType;
            else
                targetSynchSupport.IsInterventionClassTypeSupported = false;

            if (sourceSynchSupport.IsInterventionPrescriptionEducationOrganizationIdSupported)
                target.InterventionPrescriptionEducationOrganizationId = source.InterventionPrescriptionEducationOrganizationId;
            else
                targetSynchSupport.IsInterventionPrescriptionEducationOrganizationIdSupported = false;

            if (sourceSynchSupport.IsInterventionPrescriptionIdentificationCodeSupported)
                target.InterventionPrescriptionIdentificationCode = source.InterventionPrescriptionIdentificationCode;
            else
                targetSynchSupport.IsInterventionPrescriptionIdentificationCodeSupported = false;

            if (sourceSynchSupport.IsParticipantsSupported)
                target.Participants = source.Participants;
            else
                targetSynchSupport.IsParticipantsSupported = false;

            // Map lists

            if (sourceSynchSupport.IsInterventionStudyAppropriateGradeLevelsSupported)
            {    
                targetSynchSupport.IsInterventionStudyAppropriateGradeLevelIncluded = sourceSynchSupport.IsInterventionStudyAppropriateGradeLevelIncluded;
                source.InterventionStudyAppropriateGradeLevels.MapListTo(target.InterventionStudyAppropriateGradeLevels);
            }
            else
            {
                targetSynchSupport.IsInterventionStudyAppropriateGradeLevelsSupported = false;
            }

            if (sourceSynchSupport.IsInterventionStudyAppropriateSexesSupported)
            {    
                targetSynchSupport.IsInterventionStudyAppropriateSexIncluded = sourceSynchSupport.IsInterventionStudyAppropriateSexIncluded;
                source.InterventionStudyAppropriateSexes.MapListTo(target.InterventionStudyAppropriateSexes);
            }
            else
            {
                targetSynchSupport.IsInterventionStudyAppropriateSexesSupported = false;
            }

            if (sourceSynchSupport.IsInterventionStudyEducationContentsSupported)
            {    
                targetSynchSupport.IsInterventionStudyEducationContentIncluded = sourceSynchSupport.IsInterventionStudyEducationContentIncluded;
                source.InterventionStudyEducationContents.MapListTo(target.InterventionStudyEducationContents);
            }
            else
            {
                targetSynchSupport.IsInterventionStudyEducationContentsSupported = false;
            }

            if (sourceSynchSupport.IsInterventionStudyInterventionEffectivenessesSupported)
            {    
                targetSynchSupport.IsInterventionStudyInterventionEffectivenessIncluded = sourceSynchSupport.IsInterventionStudyInterventionEffectivenessIncluded;
                source.InterventionStudyInterventionEffectivenesses.MapListTo(target.InterventionStudyInterventionEffectivenesses);
            }
            else
            {
                targetSynchSupport.IsInterventionStudyInterventionEffectivenessesSupported = false;
            }

            if (sourceSynchSupport.IsInterventionStudyLearningResourceMetadataURIsSupported)
            {    
                targetSynchSupport.IsInterventionStudyLearningResourceMetadataURIIncluded = sourceSynchSupport.IsInterventionStudyLearningResourceMetadataURIIncluded;
                source.InterventionStudyLearningResourceMetadataURIs.MapListTo(target.InterventionStudyLearningResourceMetadataURIs);
            }
            else
            {
                targetSynchSupport.IsInterventionStudyLearningResourceMetadataURIsSupported = false;
            }

            if (sourceSynchSupport.IsInterventionStudyPopulationServedsSupported)
            {    
                targetSynchSupport.IsInterventionStudyPopulationServedIncluded = sourceSynchSupport.IsInterventionStudyPopulationServedIncluded;
                source.InterventionStudyPopulationServeds.MapListTo(target.InterventionStudyPopulationServeds);
            }
            else
            {
                targetSynchSupport.IsInterventionStudyPopulationServedsSupported = false;
            }

            if (sourceSynchSupport.IsInterventionStudyStateAbbreviationsSupported)
            {    
                targetSynchSupport.IsInterventionStudyStateAbbreviationIncluded = sourceSynchSupport.IsInterventionStudyStateAbbreviationIncluded;
                source.InterventionStudyStateAbbreviations.MapListTo(target.InterventionStudyStateAbbreviations);
            }
            else
            {
                targetSynchSupport.IsInterventionStudyStateAbbreviationsSupported = false;
            }

            if (sourceSynchSupport.IsInterventionStudyURIsSupported)
            {    
                targetSynchSupport.IsInterventionStudyURIIncluded = sourceSynchSupport.IsInterventionStudyURIIncluded;
                source.InterventionStudyURIs.MapListTo(target.InterventionStudyURIs);
            }
            else
            {
                targetSynchSupport.IsInterventionStudyURIsSupported = false;
            }

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IInterventionStudySynchronizationSourceSupport
    {
        bool IsDeliveryMethodTypeSupported { get; set; }
        bool IsInterventionClassTypeSupported { get; set; }
        bool IsInterventionPrescriptionEducationOrganizationIdSupported { get; set; }
        bool IsInterventionPrescriptionIdentificationCodeSupported { get; set; }
        bool IsInterventionStudyAppropriateGradeLevelsSupported { get; set; }
        bool IsInterventionStudyAppropriateSexesSupported { get; set; }
        bool IsInterventionStudyEducationContentsSupported { get; set; }
        bool IsInterventionStudyInterventionEffectivenessesSupported { get; set; }
        bool IsInterventionStudyLearningResourceMetadataURIsSupported { get; set; }
        bool IsInterventionStudyPopulationServedsSupported { get; set; }
        bool IsInterventionStudyStateAbbreviationsSupported { get; set; }
        bool IsInterventionStudyURIsSupported { get; set; }
        bool IsParticipantsSupported { get; set; }
        Func<IInterventionStudyAppropriateGradeLevel, bool> IsInterventionStudyAppropriateGradeLevelIncluded { get; set; }
        Func<IInterventionStudyAppropriateSex, bool> IsInterventionStudyAppropriateSexIncluded { get; set; }
        Func<IInterventionStudyEducationContent, bool> IsInterventionStudyEducationContentIncluded { get; set; }
        Func<IInterventionStudyInterventionEffectiveness, bool> IsInterventionStudyInterventionEffectivenessIncluded { get; set; }
        Func<IInterventionStudyLearningResourceMetadataURI, bool> IsInterventionStudyLearningResourceMetadataURIIncluded { get; set; }
        Func<IInterventionStudyPopulationServed, bool> IsInterventionStudyPopulationServedIncluded { get; set; }
        Func<IInterventionStudyStateAbbreviation, bool> IsInterventionStudyStateAbbreviationIncluded { get; set; }
        Func<IInterventionStudyURI, bool> IsInterventionStudyURIIncluded { get; set; }
    }
 
    public static class InterventionStudyAppropriateGradeLevelMapper 
    {
        public static bool SynchronizeTo(this IInterventionStudyAppropriateGradeLevel source, IInterventionStudyAppropriateGradeLevel target)
        {
            bool isModified = false;

            var sourceSupport = source as IInterventionStudyAppropriateGradeLevelSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.GradeLevelDescriptor != target.GradeLevelDescriptor)
            {
                source.GradeLevelDescriptor = target.GradeLevelDescriptor;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IInterventionStudyAppropriateGradeLevel source, IInterventionStudyAppropriateGradeLevel target, Action<IInterventionStudyAppropriateGradeLevel, IInterventionStudyAppropriateGradeLevel> onMapped)
        {
            var sourceSynchSupport = source as IInterventionStudyAppropriateGradeLevelSynchronizationSourceSupport;
            var targetSynchSupport = target as IInterventionStudyAppropriateGradeLevelSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.GradeLevelDescriptor = source.GradeLevelDescriptor;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IInterventionStudyAppropriateGradeLevelSynchronizationSourceSupport
    {
    }
 
    public static class InterventionStudyAppropriateSexMapper 
    {
        public static bool SynchronizeTo(this IInterventionStudyAppropriateSex source, IInterventionStudyAppropriateSex target)
        {
            bool isModified = false;

            var sourceSupport = source as IInterventionStudyAppropriateSexSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.SexType != target.SexType)
            {
                source.SexType = target.SexType;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IInterventionStudyAppropriateSex source, IInterventionStudyAppropriateSex target, Action<IInterventionStudyAppropriateSex, IInterventionStudyAppropriateSex> onMapped)
        {
            var sourceSynchSupport = source as IInterventionStudyAppropriateSexSynchronizationSourceSupport;
            var targetSynchSupport = target as IInterventionStudyAppropriateSexSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.SexType = source.SexType;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IInterventionStudyAppropriateSexSynchronizationSourceSupport
    {
    }
 
    public static class InterventionStudyEducationContentMapper 
    {
        public static bool SynchronizeTo(this IInterventionStudyEducationContent source, IInterventionStudyEducationContent target)
        {
            bool isModified = false;

            var sourceSupport = source as IInterventionStudyEducationContentSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.ContentIdentifier != target.ContentIdentifier)
            {
                source.ContentIdentifier = target.ContentIdentifier;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IInterventionStudyEducationContent source, IInterventionStudyEducationContent target, Action<IInterventionStudyEducationContent, IInterventionStudyEducationContent> onMapped)
        {
            var sourceSynchSupport = source as IInterventionStudyEducationContentSynchronizationSourceSupport;
            var targetSynchSupport = target as IInterventionStudyEducationContentSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.ContentIdentifier = source.ContentIdentifier;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IInterventionStudyEducationContentSynchronizationSourceSupport
    {
    }
 
    public static class InterventionStudyInterventionEffectivenessMapper 
    {
        public static bool SynchronizeTo(this IInterventionStudyInterventionEffectiveness source, IInterventionStudyInterventionEffectiveness target)
        {
            bool isModified = false;

            var sourceSupport = source as IInterventionStudyInterventionEffectivenessSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.DiagnosisDescriptor != target.DiagnosisDescriptor)
            {
                source.DiagnosisDescriptor = target.DiagnosisDescriptor;
            }
            if (source.GradeLevelDescriptor != target.GradeLevelDescriptor)
            {
                source.GradeLevelDescriptor = target.GradeLevelDescriptor;
            }
            if (source.PopulationServedType != target.PopulationServedType)
            {
                source.PopulationServedType = target.PopulationServedType;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsImprovementIndexSupported)
                && target.ImprovementIndex != source.ImprovementIndex)
            {
                target.ImprovementIndex = source.ImprovementIndex;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsInterventionEffectivenessRatingTypeSupported)
                && target.InterventionEffectivenessRatingType != source.InterventionEffectivenessRatingType)
            {
                target.InterventionEffectivenessRatingType = source.InterventionEffectivenessRatingType;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IInterventionStudyInterventionEffectiveness source, IInterventionStudyInterventionEffectiveness target, Action<IInterventionStudyInterventionEffectiveness, IInterventionStudyInterventionEffectiveness> onMapped)
        {
            var sourceSynchSupport = source as IInterventionStudyInterventionEffectivenessSynchronizationSourceSupport;
            var targetSynchSupport = target as IInterventionStudyInterventionEffectivenessSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.DiagnosisDescriptor = source.DiagnosisDescriptor;
            target.GradeLevelDescriptor = source.GradeLevelDescriptor;
            target.PopulationServedType = source.PopulationServedType;

            // Copy non-PK properties

            if (sourceSynchSupport.IsImprovementIndexSupported)
                target.ImprovementIndex = source.ImprovementIndex;
            else
                targetSynchSupport.IsImprovementIndexSupported = false;

            if (sourceSynchSupport.IsInterventionEffectivenessRatingTypeSupported)
                target.InterventionEffectivenessRatingType = source.InterventionEffectivenessRatingType;
            else
                targetSynchSupport.IsInterventionEffectivenessRatingTypeSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IInterventionStudyInterventionEffectivenessSynchronizationSourceSupport
    {
        bool IsImprovementIndexSupported { get; set; }
        bool IsInterventionEffectivenessRatingTypeSupported { get; set; }
    }
 
    public static class InterventionStudyLearningResourceMetadataURIMapper 
    {
        public static bool SynchronizeTo(this IInterventionStudyLearningResourceMetadataURI source, IInterventionStudyLearningResourceMetadataURI target)
        {
            bool isModified = false;

            var sourceSupport = source as IInterventionStudyLearningResourceMetadataURISynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.LearningResourceMetadataURI != target.LearningResourceMetadataURI)
            {
                source.LearningResourceMetadataURI = target.LearningResourceMetadataURI;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IInterventionStudyLearningResourceMetadataURI source, IInterventionStudyLearningResourceMetadataURI target, Action<IInterventionStudyLearningResourceMetadataURI, IInterventionStudyLearningResourceMetadataURI> onMapped)
        {
            var sourceSynchSupport = source as IInterventionStudyLearningResourceMetadataURISynchronizationSourceSupport;
            var targetSynchSupport = target as IInterventionStudyLearningResourceMetadataURISynchronizationSourceSupport;

            // Copy contextual primary key values
            target.LearningResourceMetadataURI = source.LearningResourceMetadataURI;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IInterventionStudyLearningResourceMetadataURISynchronizationSourceSupport
    {
    }
 
    public static class InterventionStudyPopulationServedMapper 
    {
        public static bool SynchronizeTo(this IInterventionStudyPopulationServed source, IInterventionStudyPopulationServed target)
        {
            bool isModified = false;

            var sourceSupport = source as IInterventionStudyPopulationServedSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.PopulationServedType != target.PopulationServedType)
            {
                source.PopulationServedType = target.PopulationServedType;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IInterventionStudyPopulationServed source, IInterventionStudyPopulationServed target, Action<IInterventionStudyPopulationServed, IInterventionStudyPopulationServed> onMapped)
        {
            var sourceSynchSupport = source as IInterventionStudyPopulationServedSynchronizationSourceSupport;
            var targetSynchSupport = target as IInterventionStudyPopulationServedSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.PopulationServedType = source.PopulationServedType;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IInterventionStudyPopulationServedSynchronizationSourceSupport
    {
    }
 
    public static class InterventionStudyStateAbbreviationMapper 
    {
        public static bool SynchronizeTo(this IInterventionStudyStateAbbreviation source, IInterventionStudyStateAbbreviation target)
        {
            bool isModified = false;

            var sourceSupport = source as IInterventionStudyStateAbbreviationSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.StateAbbreviationType != target.StateAbbreviationType)
            {
                source.StateAbbreviationType = target.StateAbbreviationType;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IInterventionStudyStateAbbreviation source, IInterventionStudyStateAbbreviation target, Action<IInterventionStudyStateAbbreviation, IInterventionStudyStateAbbreviation> onMapped)
        {
            var sourceSynchSupport = source as IInterventionStudyStateAbbreviationSynchronizationSourceSupport;
            var targetSynchSupport = target as IInterventionStudyStateAbbreviationSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.StateAbbreviationType = source.StateAbbreviationType;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IInterventionStudyStateAbbreviationSynchronizationSourceSupport
    {
    }
 
    public static class InterventionStudyURIMapper 
    {
        public static bool SynchronizeTo(this IInterventionStudyURI source, IInterventionStudyURI target)
        {
            bool isModified = false;

            var sourceSupport = source as IInterventionStudyURISynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.URI != target.URI)
            {
                source.URI = target.URI;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IInterventionStudyURI source, IInterventionStudyURI target, Action<IInterventionStudyURI, IInterventionStudyURI> onMapped)
        {
            var sourceSynchSupport = source as IInterventionStudyURISynchronizationSourceSupport;
            var targetSynchSupport = target as IInterventionStudyURISynchronizationSourceSupport;

            // Copy contextual primary key values
            target.URI = source.URI;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IInterventionStudyURISynchronizationSourceSupport
    {
    }
 
}
// Aggregate: LanguageDescriptor

namespace EdFi.Ods.Entities.Common //.LanguageDescriptorAggregate
{ 
    public static class LanguageDescriptorMapper 
    {
        public static bool SynchronizeTo(this ILanguageDescriptor source, ILanguageDescriptor target)
        {
            bool isModified = false;

            var sourceSupport = source as ILanguageDescriptorSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.LanguageDescriptorId != target.LanguageDescriptorId)
            {
                source.LanguageDescriptorId = target.LanguageDescriptorId;
            }

            // Copy inherited non-PK properties


            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveBeginDateSupported)
                && target.EffectiveBeginDate != source.EffectiveBeginDate)
            {
                target.EffectiveBeginDate = source.EffectiveBeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveEndDateSupported)
                && target.EffectiveEndDate != source.EffectiveEndDate)
            {
                target.EffectiveEndDate = source.EffectiveEndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNamespaceSupported)
                && target.Namespace != source.Namespace)
            {
                target.Namespace = source.Namespace;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPriorDescriptorIdSupported)
                && target.PriorDescriptorId != source.PriorDescriptorId)
            {
                target.PriorDescriptorId = source.PriorDescriptorId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsLanguageTypeSupported)
                && target.LanguageType != source.LanguageType)
            {
                target.LanguageType = source.LanguageType;
                isModified = true;
            }

            // Synch inherited lists


            // Sync lists

            return isModified;
        }



        public static void MapTo(this ILanguageDescriptor source, ILanguageDescriptor target, Action<ILanguageDescriptor, ILanguageDescriptor> onMapped)
        {
            var sourceSynchSupport = source as ILanguageDescriptorSynchronizationSourceSupport;
            var targetSynchSupport = target as ILanguageDescriptorSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.LanguageDescriptorId = source.LanguageDescriptorId;

            // Copy inherited non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsEffectiveBeginDateSupported)
                target.EffectiveBeginDate = source.EffectiveBeginDate;
            else
                targetSynchSupport.IsEffectiveBeginDateSupported = false;

            if (sourceSynchSupport.IsEffectiveEndDateSupported)
                target.EffectiveEndDate = source.EffectiveEndDate;
            else
                targetSynchSupport.IsEffectiveEndDateSupported = false;

            if (sourceSynchSupport.IsNamespaceSupported)
                target.Namespace = source.Namespace;
            else
                targetSynchSupport.IsNamespaceSupported = false;

            if (sourceSynchSupport.IsPriorDescriptorIdSupported)
                target.PriorDescriptorId = source.PriorDescriptorId;
            else
                targetSynchSupport.IsPriorDescriptorIdSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Copy non-PK properties

            if (sourceSynchSupport.IsLanguageTypeSupported)
                target.LanguageType = source.LanguageType;
            else
                targetSynchSupport.IsLanguageTypeSupported = false;

            // Map inherited lists

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ILanguageDescriptorSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsEffectiveBeginDateSupported { get; set; }
        bool IsEffectiveEndDateSupported { get; set; }
        bool IsLanguageTypeSupported { get; set; }
        bool IsNamespaceSupported { get; set; }
        bool IsPriorDescriptorIdSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: LanguageType

namespace EdFi.Ods.Entities.Common //.LanguageTypeAggregate
{ 
    public static class LanguageTypeMapper 
    {
        public static bool SynchronizeTo(this ILanguageType source, ILanguageType target)
        {
            bool isModified = false;

            var sourceSupport = source as ILanguageTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.LanguageTypeId != target.LanguageTypeId)
            {
                source.LanguageTypeId = target.LanguageTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ILanguageType source, ILanguageType target, Action<ILanguageType, ILanguageType> onMapped)
        {
            var sourceSynchSupport = source as ILanguageTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as ILanguageTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.LanguageTypeId = source.LanguageTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ILanguageTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: LanguageUseType

namespace EdFi.Ods.Entities.Common //.LanguageUseTypeAggregate
{ 
    public static class LanguageUseTypeMapper 
    {
        public static bool SynchronizeTo(this ILanguageUseType source, ILanguageUseType target)
        {
            bool isModified = false;

            var sourceSupport = source as ILanguageUseTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.LanguageUseTypeId != target.LanguageUseTypeId)
            {
                source.LanguageUseTypeId = target.LanguageUseTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ILanguageUseType source, ILanguageUseType target, Action<ILanguageUseType, ILanguageUseType> onMapped)
        {
            var sourceSynchSupport = source as ILanguageUseTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as ILanguageUseTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.LanguageUseTypeId = source.LanguageUseTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ILanguageUseTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: LearningObjective

namespace EdFi.Ods.Entities.Common //.LearningObjectiveAggregate
{ 
    public static class LearningObjectiveMapper 
    {
        public static bool SynchronizeTo(this ILearningObjective source, ILearningObjective target)
        {
            bool isModified = false;

            var sourceSupport = source as ILearningObjectiveSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.LearningObjectiveId != target.LearningObjectiveId)
            {
                source.LearningObjectiveId = target.LearningObjectiveId;
            }
            if (source.Namespace != target.Namespace)
            {
                source.Namespace = target.Namespace;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNomenclatureSupported)
                && target.Nomenclature != source.Nomenclature)
            {
                target.Nomenclature = source.Nomenclature;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsObjectiveSupported)
                && target.Objective != source.Objective)
            {
                target.Objective = source.Objective;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsParentLearningObjectiveIdSupported)
                && target.ParentLearningObjectiveId != source.ParentLearningObjectiveId)
            {
                target.ParentLearningObjectiveId = source.ParentLearningObjectiveId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsParentNamespaceSupported)
                && target.ParentNamespace != source.ParentNamespace)
            {
                target.ParentNamespace = source.ParentNamespace;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsSuccessCriteriaSupported)
                && target.SuccessCriteria != source.SuccessCriteria)
            {
                target.SuccessCriteria = source.SuccessCriteria;
                isModified = true;
            }

            // ----------------------------------            
            //   Synch One-to-one relationships
            // ----------------------------------            
            // LearningObjectiveContentStandard
            if (sourceSupport == null || sourceSupport.IsLearningObjectiveContentStandardSupported)
            {
                if (source.LearningObjectiveContentStandard == null)
                {
                    if (target.LearningObjectiveContentStandard != null)
                    {
                        target.LearningObjectiveContentStandard = null;
                        isModified = true;
                    }
                }
                else
                {
                    if (target.LearningObjectiveContentStandard == null)
                    {
                        var itemType = target.GetType().GetProperty("LearningObjectiveContentStandard").PropertyType;
                        var newItem = Activator.CreateInstance(itemType);
                        target.LearningObjectiveContentStandard = (ILearningObjectiveContentStandard) newItem;
                    }

                    isModified |= source.LearningObjectiveContentStandard.Synchronize(target.LearningObjectiveContentStandard);
                }
            }
            
            // -------------------------------------------------------------



            // Sync lists
            if (sourceSupport == null || sourceSupport.IsLearningObjectiveAcademicSubjectsSupported)
                isModified |= source.LearningObjectiveAcademicSubjects.SynchronizeListTo(target.LearningObjectiveAcademicSubjects, child => child.LearningObjective = target,
                                sourceSupport == null ? null : sourceSupport.IsLearningObjectiveAcademicSubjectIncluded);

            if (sourceSupport == null || sourceSupport.IsLearningObjectiveGradeLevelsSupported)
                isModified |= source.LearningObjectiveGradeLevels.SynchronizeListTo(target.LearningObjectiveGradeLevels, child => child.LearningObjective = target,
                                sourceSupport == null ? null : sourceSupport.IsLearningObjectiveGradeLevelIncluded);

            if (sourceSupport == null || sourceSupport.IsLearningObjectiveLearningStandardsSupported)
                isModified |= source.LearningObjectiveLearningStandards.SynchronizeListTo(target.LearningObjectiveLearningStandards, child => child.LearningObjective = target,
                                sourceSupport == null ? null : sourceSupport.IsLearningObjectiveLearningStandardIncluded);


            return isModified;
        }



        public static void MapTo(this ILearningObjective source, ILearningObjective target, Action<ILearningObjective, ILearningObjective> onMapped)
        {
            var sourceSynchSupport = source as ILearningObjectiveSynchronizationSourceSupport;
            var targetSynchSupport = target as ILearningObjectiveSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.LearningObjectiveId = source.LearningObjectiveId;
            target.Namespace = source.Namespace;

            // Copy non-PK properties

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsNomenclatureSupported)
                target.Nomenclature = source.Nomenclature;
            else
                targetSynchSupport.IsNomenclatureSupported = false;

            if (sourceSynchSupport.IsObjectiveSupported)
                target.Objective = source.Objective;
            else
                targetSynchSupport.IsObjectiveSupported = false;

            if (sourceSynchSupport.IsParentLearningObjectiveIdSupported)
                target.ParentLearningObjectiveId = source.ParentLearningObjectiveId;
            else
                targetSynchSupport.IsParentLearningObjectiveIdSupported = false;

            if (sourceSynchSupport.IsParentNamespaceSupported)
                target.ParentNamespace = source.ParentNamespace;
            else
                targetSynchSupport.IsParentNamespaceSupported = false;

            if (sourceSynchSupport.IsSuccessCriteriaSupported)
                target.SuccessCriteria = source.SuccessCriteria;
            else
                targetSynchSupport.IsSuccessCriteriaSupported = false;

            // ----------------------------------
            //   Map One-to-one relationships
            // ----------------------------------
            // LearningObjectiveContentStandard (Source)
            if (sourceSynchSupport.IsLearningObjectiveContentStandardSupported)
            {
                var itemProperty = target.GetType().GetProperty("LearningObjectiveContentStandard");
                
                if (itemProperty != null)
                {                    
                    if (source.LearningObjectiveContentStandard == null)
                    {
                        target.LearningObjectiveContentStandard = null;
                    }
                    else
                    {
                        var itemType = itemProperty.PropertyType;
                        object targetLearningObjectiveContentStandard = Activator.CreateInstance(itemType);

                        source.LearningObjectiveContentStandard.Map(targetLearningObjectiveContentStandard);
                        
                        // Update the target reference appropriately
                        target.LearningObjectiveContentStandard = (ILearningObjectiveContentStandard) targetLearningObjectiveContentStandard;
                    }
                }
            }
            else
            {
                targetSynchSupport.IsLearningObjectiveContentStandardSupported = false; 
            }
            // -------------------------------------------------------------

            // Map lists

            if (sourceSynchSupport.IsLearningObjectiveAcademicSubjectsSupported)
            {    
                targetSynchSupport.IsLearningObjectiveAcademicSubjectIncluded = sourceSynchSupport.IsLearningObjectiveAcademicSubjectIncluded;
                source.LearningObjectiveAcademicSubjects.MapListTo(target.LearningObjectiveAcademicSubjects);
            }
            else
            {
                targetSynchSupport.IsLearningObjectiveAcademicSubjectsSupported = false;
            }

            if (sourceSynchSupport.IsLearningObjectiveGradeLevelsSupported)
            {    
                targetSynchSupport.IsLearningObjectiveGradeLevelIncluded = sourceSynchSupport.IsLearningObjectiveGradeLevelIncluded;
                source.LearningObjectiveGradeLevels.MapListTo(target.LearningObjectiveGradeLevels);
            }
            else
            {
                targetSynchSupport.IsLearningObjectiveGradeLevelsSupported = false;
            }

            if (sourceSynchSupport.IsLearningObjectiveLearningStandardsSupported)
            {    
                targetSynchSupport.IsLearningObjectiveLearningStandardIncluded = sourceSynchSupport.IsLearningObjectiveLearningStandardIncluded;
                source.LearningObjectiveLearningStandards.MapListTo(target.LearningObjectiveLearningStandards);
            }
            else
            {
                targetSynchSupport.IsLearningObjectiveLearningStandardsSupported = false;
            }

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ILearningObjectiveSynchronizationSourceSupport
    {
        bool IsDescriptionSupported { get; set; }
        bool IsLearningObjectiveAcademicSubjectsSupported { get; set; }
        bool IsLearningObjectiveContentStandardSupported { get; set; }
        bool IsLearningObjectiveGradeLevelsSupported { get; set; }
        bool IsLearningObjectiveLearningStandardsSupported { get; set; }
        bool IsNomenclatureSupported { get; set; }
        bool IsObjectiveSupported { get; set; }
        bool IsParentLearningObjectiveIdSupported { get; set; }
        bool IsParentNamespaceSupported { get; set; }
        bool IsSuccessCriteriaSupported { get; set; }
        Func<ILearningObjectiveAcademicSubject, bool> IsLearningObjectiveAcademicSubjectIncluded { get; set; }
        Func<ILearningObjectiveGradeLevel, bool> IsLearningObjectiveGradeLevelIncluded { get; set; }
        Func<ILearningObjectiveLearningStandard, bool> IsLearningObjectiveLearningStandardIncluded { get; set; }
    }
 
    public static class LearningObjectiveAcademicSubjectMapper 
    {
        public static bool SynchronizeTo(this ILearningObjectiveAcademicSubject source, ILearningObjectiveAcademicSubject target)
        {
            bool isModified = false;

            var sourceSupport = source as ILearningObjectiveAcademicSubjectSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AcademicSubjectDescriptor != target.AcademicSubjectDescriptor)
            {
                source.AcademicSubjectDescriptor = target.AcademicSubjectDescriptor;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ILearningObjectiveAcademicSubject source, ILearningObjectiveAcademicSubject target, Action<ILearningObjectiveAcademicSubject, ILearningObjectiveAcademicSubject> onMapped)
        {
            var sourceSynchSupport = source as ILearningObjectiveAcademicSubjectSynchronizationSourceSupport;
            var targetSynchSupport = target as ILearningObjectiveAcademicSubjectSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.AcademicSubjectDescriptor = source.AcademicSubjectDescriptor;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ILearningObjectiveAcademicSubjectSynchronizationSourceSupport
    {
    }
 
    public static class LearningObjectiveContentStandardMapper 
    {
        public static bool SynchronizeTo(this ILearningObjectiveContentStandard source, ILearningObjectiveContentStandard target)
        {
            bool isModified = false;

            var sourceSupport = source as ILearningObjectiveContentStandardSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsBeginDateSupported)
                && target.BeginDate != source.BeginDate)
            {
                target.BeginDate = source.BeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEndDateSupported)
                && target.EndDate != source.EndDate)
            {
                target.EndDate = source.EndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsMandatingEducationOrganizationIdSupported)
                && target.MandatingEducationOrganizationId != source.MandatingEducationOrganizationId)
            {
                target.MandatingEducationOrganizationId = source.MandatingEducationOrganizationId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPublicationDateSupported)
                && target.PublicationDate != source.PublicationDate)
            {
                target.PublicationDate = source.PublicationDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPublicationStatusTypeSupported)
                && target.PublicationStatusType != source.PublicationStatusType)
            {
                target.PublicationStatusType = source.PublicationStatusType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPublicationYearSupported)
                && target.PublicationYear != source.PublicationYear)
            {
                target.PublicationYear = source.PublicationYear;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsTitleSupported)
                && target.Title != source.Title)
            {
                target.Title = source.Title;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsURISupported)
                && target.URI != source.URI)
            {
                target.URI = source.URI;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsVersionSupported)
                && target.Version != source.Version)
            {
                target.Version = source.Version;
                isModified = true;
            }



            // Sync lists
            if (sourceSupport == null || sourceSupport.IsLearningObjectiveContentStandardAuthorsSupported)
                isModified |= source.LearningObjectiveContentStandardAuthors.SynchronizeListTo(target.LearningObjectiveContentStandardAuthors, child => child.LearningObjectiveContentStandard = target,
                                sourceSupport == null ? null : sourceSupport.IsLearningObjectiveContentStandardAuthorIncluded);


            return isModified;
        }



        public static void MapTo(this ILearningObjectiveContentStandard source, ILearningObjectiveContentStandard target, Action<ILearningObjectiveContentStandard, ILearningObjectiveContentStandard> onMapped)
        {
            var sourceSynchSupport = source as ILearningObjectiveContentStandardSynchronizationSourceSupport;
            var targetSynchSupport = target as ILearningObjectiveContentStandardSynchronizationSourceSupport;

            // Copy contextual primary key values

            // Copy non-PK properties

            if (sourceSynchSupport.IsBeginDateSupported)
                target.BeginDate = source.BeginDate;
            else
                targetSynchSupport.IsBeginDateSupported = false;

            if (sourceSynchSupport.IsEndDateSupported)
                target.EndDate = source.EndDate;
            else
                targetSynchSupport.IsEndDateSupported = false;

            if (sourceSynchSupport.IsMandatingEducationOrganizationIdSupported)
                target.MandatingEducationOrganizationId = source.MandatingEducationOrganizationId;
            else
                targetSynchSupport.IsMandatingEducationOrganizationIdSupported = false;

            if (sourceSynchSupport.IsPublicationDateSupported)
                target.PublicationDate = source.PublicationDate;
            else
                targetSynchSupport.IsPublicationDateSupported = false;

            if (sourceSynchSupport.IsPublicationStatusTypeSupported)
                target.PublicationStatusType = source.PublicationStatusType;
            else
                targetSynchSupport.IsPublicationStatusTypeSupported = false;

            if (sourceSynchSupport.IsPublicationYearSupported)
                target.PublicationYear = source.PublicationYear;
            else
                targetSynchSupport.IsPublicationYearSupported = false;

            if (sourceSynchSupport.IsTitleSupported)
                target.Title = source.Title;
            else
                targetSynchSupport.IsTitleSupported = false;

            if (sourceSynchSupport.IsURISupported)
                target.URI = source.URI;
            else
                targetSynchSupport.IsURISupported = false;

            if (sourceSynchSupport.IsVersionSupported)
                target.Version = source.Version;
            else
                targetSynchSupport.IsVersionSupported = false;

            // Map lists

            if (sourceSynchSupport.IsLearningObjectiveContentStandardAuthorsSupported)
            {    
                targetSynchSupport.IsLearningObjectiveContentStandardAuthorIncluded = sourceSynchSupport.IsLearningObjectiveContentStandardAuthorIncluded;
                source.LearningObjectiveContentStandardAuthors.MapListTo(target.LearningObjectiveContentStandardAuthors);
            }
            else
            {
                targetSynchSupport.IsLearningObjectiveContentStandardAuthorsSupported = false;
            }

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ILearningObjectiveContentStandardSynchronizationSourceSupport
    {
        bool IsBeginDateSupported { get; set; }
        bool IsEndDateSupported { get; set; }
        bool IsLearningObjectiveContentStandardAuthorsSupported { get; set; }
        bool IsMandatingEducationOrganizationIdSupported { get; set; }
        bool IsPublicationDateSupported { get; set; }
        bool IsPublicationStatusTypeSupported { get; set; }
        bool IsPublicationYearSupported { get; set; }
        bool IsTitleSupported { get; set; }
        bool IsURISupported { get; set; }
        bool IsVersionSupported { get; set; }
        Func<ILearningObjectiveContentStandardAuthor, bool> IsLearningObjectiveContentStandardAuthorIncluded { get; set; }
    }
 
    public static class LearningObjectiveContentStandardAuthorMapper 
    {
        public static bool SynchronizeTo(this ILearningObjectiveContentStandardAuthor source, ILearningObjectiveContentStandardAuthor target)
        {
            bool isModified = false;

            var sourceSupport = source as ILearningObjectiveContentStandardAuthorSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.Author != target.Author)
            {
                source.Author = target.Author;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ILearningObjectiveContentStandardAuthor source, ILearningObjectiveContentStandardAuthor target, Action<ILearningObjectiveContentStandardAuthor, ILearningObjectiveContentStandardAuthor> onMapped)
        {
            var sourceSynchSupport = source as ILearningObjectiveContentStandardAuthorSynchronizationSourceSupport;
            var targetSynchSupport = target as ILearningObjectiveContentStandardAuthorSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.Author = source.Author;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ILearningObjectiveContentStandardAuthorSynchronizationSourceSupport
    {
    }
 
    public static class LearningObjectiveGradeLevelMapper 
    {
        public static bool SynchronizeTo(this ILearningObjectiveGradeLevel source, ILearningObjectiveGradeLevel target)
        {
            bool isModified = false;

            var sourceSupport = source as ILearningObjectiveGradeLevelSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.GradeLevelDescriptor != target.GradeLevelDescriptor)
            {
                source.GradeLevelDescriptor = target.GradeLevelDescriptor;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ILearningObjectiveGradeLevel source, ILearningObjectiveGradeLevel target, Action<ILearningObjectiveGradeLevel, ILearningObjectiveGradeLevel> onMapped)
        {
            var sourceSynchSupport = source as ILearningObjectiveGradeLevelSynchronizationSourceSupport;
            var targetSynchSupport = target as ILearningObjectiveGradeLevelSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.GradeLevelDescriptor = source.GradeLevelDescriptor;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ILearningObjectiveGradeLevelSynchronizationSourceSupport
    {
    }
 
    public static class LearningObjectiveLearningStandardMapper 
    {
        public static bool SynchronizeTo(this ILearningObjectiveLearningStandard source, ILearningObjectiveLearningStandard target)
        {
            bool isModified = false;

            var sourceSupport = source as ILearningObjectiveLearningStandardSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.LearningStandardId != target.LearningStandardId)
            {
                source.LearningStandardId = target.LearningStandardId;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ILearningObjectiveLearningStandard source, ILearningObjectiveLearningStandard target, Action<ILearningObjectiveLearningStandard, ILearningObjectiveLearningStandard> onMapped)
        {
            var sourceSynchSupport = source as ILearningObjectiveLearningStandardSynchronizationSourceSupport;
            var targetSynchSupport = target as ILearningObjectiveLearningStandardSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.LearningStandardId = source.LearningStandardId;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ILearningObjectiveLearningStandardSynchronizationSourceSupport
    {
    }
 
}
// Aggregate: LearningStandard

namespace EdFi.Ods.Entities.Common //.LearningStandardAggregate
{ 
    public static class LearningStandardMapper 
    {
        public static bool SynchronizeTo(this ILearningStandard source, ILearningStandard target)
        {
            bool isModified = false;

            var sourceSupport = source as ILearningStandardSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.LearningStandardId != target.LearningStandardId)
            {
                source.LearningStandardId = target.LearningStandardId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsAcademicSubjectDescriptorSupported)
                && target.AcademicSubjectDescriptor != source.AcademicSubjectDescriptor)
            {
                target.AcademicSubjectDescriptor = source.AcademicSubjectDescriptor;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsCourseTitleSupported)
                && target.CourseTitle != source.CourseTitle)
            {
                target.CourseTitle = source.CourseTitle;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsLearningStandardItemCodeSupported)
                && target.LearningStandardItemCode != source.LearningStandardItemCode)
            {
                target.LearningStandardItemCode = source.LearningStandardItemCode;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNamespaceSupported)
                && target.Namespace != source.Namespace)
            {
                target.Namespace = source.Namespace;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsParentLearningStandardIdSupported)
                && target.ParentLearningStandardId != source.ParentLearningStandardId)
            {
                target.ParentLearningStandardId = source.ParentLearningStandardId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsSuccessCriteriaSupported)
                && target.SuccessCriteria != source.SuccessCriteria)
            {
                target.SuccessCriteria = source.SuccessCriteria;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsURISupported)
                && target.URI != source.URI)
            {
                target.URI = source.URI;
                isModified = true;
            }

            // ----------------------------------            
            //   Synch One-to-one relationships
            // ----------------------------------            
            // LearningStandardContentStandard
            if (sourceSupport == null || sourceSupport.IsLearningStandardContentStandardSupported)
            {
                if (source.LearningStandardContentStandard == null)
                {
                    if (target.LearningStandardContentStandard != null)
                    {
                        target.LearningStandardContentStandard = null;
                        isModified = true;
                    }
                }
                else
                {
                    if (target.LearningStandardContentStandard == null)
                    {
                        var itemType = target.GetType().GetProperty("LearningStandardContentStandard").PropertyType;
                        var newItem = Activator.CreateInstance(itemType);
                        target.LearningStandardContentStandard = (ILearningStandardContentStandard) newItem;
                    }

                    isModified |= source.LearningStandardContentStandard.Synchronize(target.LearningStandardContentStandard);
                }
            }
            
            // -------------------------------------------------------------



            // Sync lists
            if (sourceSupport == null || sourceSupport.IsLearningStandardGradeLevelsSupported)
                isModified |= source.LearningStandardGradeLevels.SynchronizeListTo(target.LearningStandardGradeLevels, child => child.LearningStandard = target,
                                sourceSupport == null ? null : sourceSupport.IsLearningStandardGradeLevelIncluded);

            if (sourceSupport == null || sourceSupport.IsLearningStandardIdentificationCodesSupported)
                isModified |= source.LearningStandardIdentificationCodes.SynchronizeListTo(target.LearningStandardIdentificationCodes, child => child.LearningStandard = target,
                                sourceSupport == null ? null : sourceSupport.IsLearningStandardIdentificationCodeIncluded);

            if (sourceSupport == null || sourceSupport.IsLearningStandardPrerequisiteLearningStandardsSupported)
                isModified |= source.LearningStandardPrerequisiteLearningStandards.SynchronizeListTo(target.LearningStandardPrerequisiteLearningStandards, child => child.LearningStandard = target,
                                sourceSupport == null ? null : sourceSupport.IsLearningStandardPrerequisiteLearningStandardIncluded);


            return isModified;
        }



        public static void MapTo(this ILearningStandard source, ILearningStandard target, Action<ILearningStandard, ILearningStandard> onMapped)
        {
            var sourceSynchSupport = source as ILearningStandardSynchronizationSourceSupport;
            var targetSynchSupport = target as ILearningStandardSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.LearningStandardId = source.LearningStandardId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsAcademicSubjectDescriptorSupported)
                target.AcademicSubjectDescriptor = source.AcademicSubjectDescriptor;
            else
                targetSynchSupport.IsAcademicSubjectDescriptorSupported = false;

            if (sourceSynchSupport.IsCourseTitleSupported)
                target.CourseTitle = source.CourseTitle;
            else
                targetSynchSupport.IsCourseTitleSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsLearningStandardItemCodeSupported)
                target.LearningStandardItemCode = source.LearningStandardItemCode;
            else
                targetSynchSupport.IsLearningStandardItemCodeSupported = false;

            if (sourceSynchSupport.IsNamespaceSupported)
                target.Namespace = source.Namespace;
            else
                targetSynchSupport.IsNamespaceSupported = false;

            if (sourceSynchSupport.IsParentLearningStandardIdSupported)
                target.ParentLearningStandardId = source.ParentLearningStandardId;
            else
                targetSynchSupport.IsParentLearningStandardIdSupported = false;

            if (sourceSynchSupport.IsSuccessCriteriaSupported)
                target.SuccessCriteria = source.SuccessCriteria;
            else
                targetSynchSupport.IsSuccessCriteriaSupported = false;

            if (sourceSynchSupport.IsURISupported)
                target.URI = source.URI;
            else
                targetSynchSupport.IsURISupported = false;

            // ----------------------------------
            //   Map One-to-one relationships
            // ----------------------------------
            // LearningStandardContentStandard (Source)
            if (sourceSynchSupport.IsLearningStandardContentStandardSupported)
            {
                var itemProperty = target.GetType().GetProperty("LearningStandardContentStandard");
                
                if (itemProperty != null)
                {                    
                    if (source.LearningStandardContentStandard == null)
                    {
                        target.LearningStandardContentStandard = null;
                    }
                    else
                    {
                        var itemType = itemProperty.PropertyType;
                        object targetLearningStandardContentStandard = Activator.CreateInstance(itemType);

                        source.LearningStandardContentStandard.Map(targetLearningStandardContentStandard);
                        
                        // Update the target reference appropriately
                        target.LearningStandardContentStandard = (ILearningStandardContentStandard) targetLearningStandardContentStandard;
                    }
                }
            }
            else
            {
                targetSynchSupport.IsLearningStandardContentStandardSupported = false; 
            }
            // -------------------------------------------------------------

            // Map lists

            if (sourceSynchSupport.IsLearningStandardGradeLevelsSupported)
            {    
                targetSynchSupport.IsLearningStandardGradeLevelIncluded = sourceSynchSupport.IsLearningStandardGradeLevelIncluded;
                source.LearningStandardGradeLevels.MapListTo(target.LearningStandardGradeLevels);
            }
            else
            {
                targetSynchSupport.IsLearningStandardGradeLevelsSupported = false;
            }

            if (sourceSynchSupport.IsLearningStandardIdentificationCodesSupported)
            {    
                targetSynchSupport.IsLearningStandardIdentificationCodeIncluded = sourceSynchSupport.IsLearningStandardIdentificationCodeIncluded;
                source.LearningStandardIdentificationCodes.MapListTo(target.LearningStandardIdentificationCodes);
            }
            else
            {
                targetSynchSupport.IsLearningStandardIdentificationCodesSupported = false;
            }

            if (sourceSynchSupport.IsLearningStandardPrerequisiteLearningStandardsSupported)
            {    
                targetSynchSupport.IsLearningStandardPrerequisiteLearningStandardIncluded = sourceSynchSupport.IsLearningStandardPrerequisiteLearningStandardIncluded;
                source.LearningStandardPrerequisiteLearningStandards.MapListTo(target.LearningStandardPrerequisiteLearningStandards);
            }
            else
            {
                targetSynchSupport.IsLearningStandardPrerequisiteLearningStandardsSupported = false;
            }

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ILearningStandardSynchronizationSourceSupport
    {
        bool IsAcademicSubjectDescriptorSupported { get; set; }
        bool IsCourseTitleSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsLearningStandardContentStandardSupported { get; set; }
        bool IsLearningStandardGradeLevelsSupported { get; set; }
        bool IsLearningStandardIdentificationCodesSupported { get; set; }
        bool IsLearningStandardItemCodeSupported { get; set; }
        bool IsLearningStandardPrerequisiteLearningStandardsSupported { get; set; }
        bool IsNamespaceSupported { get; set; }
        bool IsParentLearningStandardIdSupported { get; set; }
        bool IsSuccessCriteriaSupported { get; set; }
        bool IsURISupported { get; set; }
        Func<ILearningStandardGradeLevel, bool> IsLearningStandardGradeLevelIncluded { get; set; }
        Func<ILearningStandardIdentificationCode, bool> IsLearningStandardIdentificationCodeIncluded { get; set; }
        Func<ILearningStandardPrerequisiteLearningStandard, bool> IsLearningStandardPrerequisiteLearningStandardIncluded { get; set; }
    }
 
    public static class LearningStandardContentStandardMapper 
    {
        public static bool SynchronizeTo(this ILearningStandardContentStandard source, ILearningStandardContentStandard target)
        {
            bool isModified = false;

            var sourceSupport = source as ILearningStandardContentStandardSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsBeginDateSupported)
                && target.BeginDate != source.BeginDate)
            {
                target.BeginDate = source.BeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEndDateSupported)
                && target.EndDate != source.EndDate)
            {
                target.EndDate = source.EndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsMandatingEducationOrganizationIdSupported)
                && target.MandatingEducationOrganizationId != source.MandatingEducationOrganizationId)
            {
                target.MandatingEducationOrganizationId = source.MandatingEducationOrganizationId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPublicationDateSupported)
                && target.PublicationDate != source.PublicationDate)
            {
                target.PublicationDate = source.PublicationDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPublicationStatusTypeSupported)
                && target.PublicationStatusType != source.PublicationStatusType)
            {
                target.PublicationStatusType = source.PublicationStatusType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPublicationYearSupported)
                && target.PublicationYear != source.PublicationYear)
            {
                target.PublicationYear = source.PublicationYear;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsTitleSupported)
                && target.Title != source.Title)
            {
                target.Title = source.Title;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsURISupported)
                && target.URI != source.URI)
            {
                target.URI = source.URI;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsVersionSupported)
                && target.Version != source.Version)
            {
                target.Version = source.Version;
                isModified = true;
            }



            // Sync lists
            if (sourceSupport == null || sourceSupport.IsLearningStandardContentStandardAuthorsSupported)
                isModified |= source.LearningStandardContentStandardAuthors.SynchronizeListTo(target.LearningStandardContentStandardAuthors, child => child.LearningStandardContentStandard = target,
                                sourceSupport == null ? null : sourceSupport.IsLearningStandardContentStandardAuthorIncluded);


            return isModified;
        }



        public static void MapTo(this ILearningStandardContentStandard source, ILearningStandardContentStandard target, Action<ILearningStandardContentStandard, ILearningStandardContentStandard> onMapped)
        {
            var sourceSynchSupport = source as ILearningStandardContentStandardSynchronizationSourceSupport;
            var targetSynchSupport = target as ILearningStandardContentStandardSynchronizationSourceSupport;

            // Copy contextual primary key values

            // Copy non-PK properties

            if (sourceSynchSupport.IsBeginDateSupported)
                target.BeginDate = source.BeginDate;
            else
                targetSynchSupport.IsBeginDateSupported = false;

            if (sourceSynchSupport.IsEndDateSupported)
                target.EndDate = source.EndDate;
            else
                targetSynchSupport.IsEndDateSupported = false;

            if (sourceSynchSupport.IsMandatingEducationOrganizationIdSupported)
                target.MandatingEducationOrganizationId = source.MandatingEducationOrganizationId;
            else
                targetSynchSupport.IsMandatingEducationOrganizationIdSupported = false;

            if (sourceSynchSupport.IsPublicationDateSupported)
                target.PublicationDate = source.PublicationDate;
            else
                targetSynchSupport.IsPublicationDateSupported = false;

            if (sourceSynchSupport.IsPublicationStatusTypeSupported)
                target.PublicationStatusType = source.PublicationStatusType;
            else
                targetSynchSupport.IsPublicationStatusTypeSupported = false;

            if (sourceSynchSupport.IsPublicationYearSupported)
                target.PublicationYear = source.PublicationYear;
            else
                targetSynchSupport.IsPublicationYearSupported = false;

            if (sourceSynchSupport.IsTitleSupported)
                target.Title = source.Title;
            else
                targetSynchSupport.IsTitleSupported = false;

            if (sourceSynchSupport.IsURISupported)
                target.URI = source.URI;
            else
                targetSynchSupport.IsURISupported = false;

            if (sourceSynchSupport.IsVersionSupported)
                target.Version = source.Version;
            else
                targetSynchSupport.IsVersionSupported = false;

            // Map lists

            if (sourceSynchSupport.IsLearningStandardContentStandardAuthorsSupported)
            {    
                targetSynchSupport.IsLearningStandardContentStandardAuthorIncluded = sourceSynchSupport.IsLearningStandardContentStandardAuthorIncluded;
                source.LearningStandardContentStandardAuthors.MapListTo(target.LearningStandardContentStandardAuthors);
            }
            else
            {
                targetSynchSupport.IsLearningStandardContentStandardAuthorsSupported = false;
            }

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ILearningStandardContentStandardSynchronizationSourceSupport
    {
        bool IsBeginDateSupported { get; set; }
        bool IsEndDateSupported { get; set; }
        bool IsLearningStandardContentStandardAuthorsSupported { get; set; }
        bool IsMandatingEducationOrganizationIdSupported { get; set; }
        bool IsPublicationDateSupported { get; set; }
        bool IsPublicationStatusTypeSupported { get; set; }
        bool IsPublicationYearSupported { get; set; }
        bool IsTitleSupported { get; set; }
        bool IsURISupported { get; set; }
        bool IsVersionSupported { get; set; }
        Func<ILearningStandardContentStandardAuthor, bool> IsLearningStandardContentStandardAuthorIncluded { get; set; }
    }
 
    public static class LearningStandardContentStandardAuthorMapper 
    {
        public static bool SynchronizeTo(this ILearningStandardContentStandardAuthor source, ILearningStandardContentStandardAuthor target)
        {
            bool isModified = false;

            var sourceSupport = source as ILearningStandardContentStandardAuthorSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.Author != target.Author)
            {
                source.Author = target.Author;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ILearningStandardContentStandardAuthor source, ILearningStandardContentStandardAuthor target, Action<ILearningStandardContentStandardAuthor, ILearningStandardContentStandardAuthor> onMapped)
        {
            var sourceSynchSupport = source as ILearningStandardContentStandardAuthorSynchronizationSourceSupport;
            var targetSynchSupport = target as ILearningStandardContentStandardAuthorSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.Author = source.Author;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ILearningStandardContentStandardAuthorSynchronizationSourceSupport
    {
    }
 
    public static class LearningStandardGradeLevelMapper 
    {
        public static bool SynchronizeTo(this ILearningStandardGradeLevel source, ILearningStandardGradeLevel target)
        {
            bool isModified = false;

            var sourceSupport = source as ILearningStandardGradeLevelSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.GradeLevelDescriptor != target.GradeLevelDescriptor)
            {
                source.GradeLevelDescriptor = target.GradeLevelDescriptor;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ILearningStandardGradeLevel source, ILearningStandardGradeLevel target, Action<ILearningStandardGradeLevel, ILearningStandardGradeLevel> onMapped)
        {
            var sourceSynchSupport = source as ILearningStandardGradeLevelSynchronizationSourceSupport;
            var targetSynchSupport = target as ILearningStandardGradeLevelSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.GradeLevelDescriptor = source.GradeLevelDescriptor;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ILearningStandardGradeLevelSynchronizationSourceSupport
    {
    }
 
    public static class LearningStandardIdentificationCodeMapper 
    {
        public static bool SynchronizeTo(this ILearningStandardIdentificationCode source, ILearningStandardIdentificationCode target)
        {
            bool isModified = false;

            var sourceSupport = source as ILearningStandardIdentificationCodeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.ContentStandardName != target.ContentStandardName)
            {
                source.ContentStandardName = target.ContentStandardName;
            }
            if (source.IdentificationCode != target.IdentificationCode)
            {
                source.IdentificationCode = target.IdentificationCode;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ILearningStandardIdentificationCode source, ILearningStandardIdentificationCode target, Action<ILearningStandardIdentificationCode, ILearningStandardIdentificationCode> onMapped)
        {
            var sourceSynchSupport = source as ILearningStandardIdentificationCodeSynchronizationSourceSupport;
            var targetSynchSupport = target as ILearningStandardIdentificationCodeSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.ContentStandardName = source.ContentStandardName;
            target.IdentificationCode = source.IdentificationCode;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ILearningStandardIdentificationCodeSynchronizationSourceSupport
    {
    }
 
    public static class LearningStandardPrerequisiteLearningStandardMapper 
    {
        public static bool SynchronizeTo(this ILearningStandardPrerequisiteLearningStandard source, ILearningStandardPrerequisiteLearningStandard target)
        {
            bool isModified = false;

            var sourceSupport = source as ILearningStandardPrerequisiteLearningStandardSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.PrerequisiteLearningStandardId != target.PrerequisiteLearningStandardId)
            {
                source.PrerequisiteLearningStandardId = target.PrerequisiteLearningStandardId;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ILearningStandardPrerequisiteLearningStandard source, ILearningStandardPrerequisiteLearningStandard target, Action<ILearningStandardPrerequisiteLearningStandard, ILearningStandardPrerequisiteLearningStandard> onMapped)
        {
            var sourceSynchSupport = source as ILearningStandardPrerequisiteLearningStandardSynchronizationSourceSupport;
            var targetSynchSupport = target as ILearningStandardPrerequisiteLearningStandardSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.PrerequisiteLearningStandardId = source.PrerequisiteLearningStandardId;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ILearningStandardPrerequisiteLearningStandardSynchronizationSourceSupport
    {
    }
 
}
// Aggregate: LeaveEvent

namespace EdFi.Ods.Entities.Common //.LeaveEventAggregate
{ 
    public static class LeaveEventMapper 
    {
        public static bool SynchronizeTo(this ILeaveEvent source, ILeaveEvent target)
        {
            bool isModified = false;

            var sourceSupport = source as ILeaveEventSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.EventDate != target.EventDate)
            {
                source.EventDate = target.EventDate;
            }
            if (source.LeaveEventCategoryType != target.LeaveEventCategoryType)
            {
                source.LeaveEventCategoryType = target.LeaveEventCategoryType;
            }
            if (source.StaffUniqueId != target.StaffUniqueId)
            {
                source.StaffUniqueId = target.StaffUniqueId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsHoursOnLeaveSupported)
                && target.HoursOnLeave != source.HoursOnLeave)
            {
                target.HoursOnLeave = source.HoursOnLeave;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsLeaveEventReasonSupported)
                && target.LeaveEventReason != source.LeaveEventReason)
            {
                target.LeaveEventReason = source.LeaveEventReason;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsSubstituteAssignedSupported)
                && target.SubstituteAssigned != source.SubstituteAssigned)
            {
                target.SubstituteAssigned = source.SubstituteAssigned;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ILeaveEvent source, ILeaveEvent target, Action<ILeaveEvent, ILeaveEvent> onMapped)
        {
            var sourceSynchSupport = source as ILeaveEventSynchronizationSourceSupport;
            var targetSynchSupport = target as ILeaveEventSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.EventDate = source.EventDate;
            target.LeaveEventCategoryType = source.LeaveEventCategoryType;
            target.StaffUniqueId = source.StaffUniqueId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsHoursOnLeaveSupported)
                target.HoursOnLeave = source.HoursOnLeave;
            else
                targetSynchSupport.IsHoursOnLeaveSupported = false;

            if (sourceSynchSupport.IsLeaveEventReasonSupported)
                target.LeaveEventReason = source.LeaveEventReason;
            else
                targetSynchSupport.IsLeaveEventReasonSupported = false;

            if (sourceSynchSupport.IsSubstituteAssignedSupported)
                target.SubstituteAssigned = source.SubstituteAssigned;
            else
                targetSynchSupport.IsSubstituteAssignedSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ILeaveEventSynchronizationSourceSupport
    {
        bool IsHoursOnLeaveSupported { get; set; }
        bool IsLeaveEventReasonSupported { get; set; }
        bool IsSubstituteAssignedSupported { get; set; }
    }
 
}
// Aggregate: LeaveEventCategoryType

namespace EdFi.Ods.Entities.Common //.LeaveEventCategoryTypeAggregate
{ 
    public static class LeaveEventCategoryTypeMapper 
    {
        public static bool SynchronizeTo(this ILeaveEventCategoryType source, ILeaveEventCategoryType target)
        {
            bool isModified = false;

            var sourceSupport = source as ILeaveEventCategoryTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.LeaveEventCategoryTypeId != target.LeaveEventCategoryTypeId)
            {
                source.LeaveEventCategoryTypeId = target.LeaveEventCategoryTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ILeaveEventCategoryType source, ILeaveEventCategoryType target, Action<ILeaveEventCategoryType, ILeaveEventCategoryType> onMapped)
        {
            var sourceSynchSupport = source as ILeaveEventCategoryTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as ILeaveEventCategoryTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.LeaveEventCategoryTypeId = source.LeaveEventCategoryTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ILeaveEventCategoryTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: LevelDescriptor

namespace EdFi.Ods.Entities.Common //.LevelDescriptorAggregate
{ 
    public static class LevelDescriptorMapper 
    {
        public static bool SynchronizeTo(this ILevelDescriptor source, ILevelDescriptor target)
        {
            bool isModified = false;

            var sourceSupport = source as ILevelDescriptorSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.LevelDescriptorId != target.LevelDescriptorId)
            {
                source.LevelDescriptorId = target.LevelDescriptorId;
            }

            // Copy inherited non-PK properties


            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveBeginDateSupported)
                && target.EffectiveBeginDate != source.EffectiveBeginDate)
            {
                target.EffectiveBeginDate = source.EffectiveBeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveEndDateSupported)
                && target.EffectiveEndDate != source.EffectiveEndDate)
            {
                target.EffectiveEndDate = source.EffectiveEndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNamespaceSupported)
                && target.Namespace != source.Namespace)
            {
                target.Namespace = source.Namespace;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPriorDescriptorIdSupported)
                && target.PriorDescriptorId != source.PriorDescriptorId)
            {
                target.PriorDescriptorId = source.PriorDescriptorId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }

            // Copy non-PK properties

            // Synch inherited lists


            // Sync lists
            if (sourceSupport == null || sourceSupport.IsLevelDescriptorGradeLevelsSupported)
                isModified |= source.LevelDescriptorGradeLevels.SynchronizeListTo(target.LevelDescriptorGradeLevels, child => child.LevelDescriptor = target,
                                sourceSupport == null ? null : sourceSupport.IsLevelDescriptorGradeLevelIncluded);


            return isModified;
        }



        public static void MapTo(this ILevelDescriptor source, ILevelDescriptor target, Action<ILevelDescriptor, ILevelDescriptor> onMapped)
        {
            var sourceSynchSupport = source as ILevelDescriptorSynchronizationSourceSupport;
            var targetSynchSupport = target as ILevelDescriptorSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.LevelDescriptorId = source.LevelDescriptorId;

            // Copy inherited non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsEffectiveBeginDateSupported)
                target.EffectiveBeginDate = source.EffectiveBeginDate;
            else
                targetSynchSupport.IsEffectiveBeginDateSupported = false;

            if (sourceSynchSupport.IsEffectiveEndDateSupported)
                target.EffectiveEndDate = source.EffectiveEndDate;
            else
                targetSynchSupport.IsEffectiveEndDateSupported = false;

            if (sourceSynchSupport.IsNamespaceSupported)
                target.Namespace = source.Namespace;
            else
                targetSynchSupport.IsNamespaceSupported = false;

            if (sourceSynchSupport.IsPriorDescriptorIdSupported)
                target.PriorDescriptorId = source.PriorDescriptorId;
            else
                targetSynchSupport.IsPriorDescriptorIdSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Copy non-PK properties

            // Map inherited lists

            // Map lists

            if (sourceSynchSupport.IsLevelDescriptorGradeLevelsSupported)
            {    
                targetSynchSupport.IsLevelDescriptorGradeLevelIncluded = sourceSynchSupport.IsLevelDescriptorGradeLevelIncluded;
                source.LevelDescriptorGradeLevels.MapListTo(target.LevelDescriptorGradeLevels);
            }
            else
            {
                targetSynchSupport.IsLevelDescriptorGradeLevelsSupported = false;
            }

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ILevelDescriptorSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsEffectiveBeginDateSupported { get; set; }
        bool IsEffectiveEndDateSupported { get; set; }
        bool IsLevelDescriptorGradeLevelsSupported { get; set; }
        bool IsNamespaceSupported { get; set; }
        bool IsPriorDescriptorIdSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
        Func<ILevelDescriptorGradeLevel, bool> IsLevelDescriptorGradeLevelIncluded { get; set; }
    }
 
    public static class LevelDescriptorGradeLevelMapper 
    {
        public static bool SynchronizeTo(this ILevelDescriptorGradeLevel source, ILevelDescriptorGradeLevel target)
        {
            bool isModified = false;

            var sourceSupport = source as ILevelDescriptorGradeLevelSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.GradeLevelDescriptor != target.GradeLevelDescriptor)
            {
                source.GradeLevelDescriptor = target.GradeLevelDescriptor;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ILevelDescriptorGradeLevel source, ILevelDescriptorGradeLevel target, Action<ILevelDescriptorGradeLevel, ILevelDescriptorGradeLevel> onMapped)
        {
            var sourceSynchSupport = source as ILevelDescriptorGradeLevelSynchronizationSourceSupport;
            var targetSynchSupport = target as ILevelDescriptorGradeLevelSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.GradeLevelDescriptor = source.GradeLevelDescriptor;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ILevelDescriptorGradeLevelSynchronizationSourceSupport
    {
    }
 
}
// Aggregate: LevelOfEducationDescriptor

namespace EdFi.Ods.Entities.Common //.LevelOfEducationDescriptorAggregate
{ 
    public static class LevelOfEducationDescriptorMapper 
    {
        public static bool SynchronizeTo(this ILevelOfEducationDescriptor source, ILevelOfEducationDescriptor target)
        {
            bool isModified = false;

            var sourceSupport = source as ILevelOfEducationDescriptorSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.LevelOfEducationDescriptorId != target.LevelOfEducationDescriptorId)
            {
                source.LevelOfEducationDescriptorId = target.LevelOfEducationDescriptorId;
            }

            // Copy inherited non-PK properties


            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveBeginDateSupported)
                && target.EffectiveBeginDate != source.EffectiveBeginDate)
            {
                target.EffectiveBeginDate = source.EffectiveBeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveEndDateSupported)
                && target.EffectiveEndDate != source.EffectiveEndDate)
            {
                target.EffectiveEndDate = source.EffectiveEndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNamespaceSupported)
                && target.Namespace != source.Namespace)
            {
                target.Namespace = source.Namespace;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPriorDescriptorIdSupported)
                && target.PriorDescriptorId != source.PriorDescriptorId)
            {
                target.PriorDescriptorId = source.PriorDescriptorId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsLevelOfEducationTypeSupported)
                && target.LevelOfEducationType != source.LevelOfEducationType)
            {
                target.LevelOfEducationType = source.LevelOfEducationType;
                isModified = true;
            }

            // Synch inherited lists


            // Sync lists

            return isModified;
        }



        public static void MapTo(this ILevelOfEducationDescriptor source, ILevelOfEducationDescriptor target, Action<ILevelOfEducationDescriptor, ILevelOfEducationDescriptor> onMapped)
        {
            var sourceSynchSupport = source as ILevelOfEducationDescriptorSynchronizationSourceSupport;
            var targetSynchSupport = target as ILevelOfEducationDescriptorSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.LevelOfEducationDescriptorId = source.LevelOfEducationDescriptorId;

            // Copy inherited non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsEffectiveBeginDateSupported)
                target.EffectiveBeginDate = source.EffectiveBeginDate;
            else
                targetSynchSupport.IsEffectiveBeginDateSupported = false;

            if (sourceSynchSupport.IsEffectiveEndDateSupported)
                target.EffectiveEndDate = source.EffectiveEndDate;
            else
                targetSynchSupport.IsEffectiveEndDateSupported = false;

            if (sourceSynchSupport.IsNamespaceSupported)
                target.Namespace = source.Namespace;
            else
                targetSynchSupport.IsNamespaceSupported = false;

            if (sourceSynchSupport.IsPriorDescriptorIdSupported)
                target.PriorDescriptorId = source.PriorDescriptorId;
            else
                targetSynchSupport.IsPriorDescriptorIdSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Copy non-PK properties

            if (sourceSynchSupport.IsLevelOfEducationTypeSupported)
                target.LevelOfEducationType = source.LevelOfEducationType;
            else
                targetSynchSupport.IsLevelOfEducationTypeSupported = false;

            // Map inherited lists

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ILevelOfEducationDescriptorSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsEffectiveBeginDateSupported { get; set; }
        bool IsEffectiveEndDateSupported { get; set; }
        bool IsLevelOfEducationTypeSupported { get; set; }
        bool IsNamespaceSupported { get; set; }
        bool IsPriorDescriptorIdSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: LevelOfEducationType

namespace EdFi.Ods.Entities.Common //.LevelOfEducationTypeAggregate
{ 
    public static class LevelOfEducationTypeMapper 
    {
        public static bool SynchronizeTo(this ILevelOfEducationType source, ILevelOfEducationType target)
        {
            bool isModified = false;

            var sourceSupport = source as ILevelOfEducationTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.LevelOfEducationTypeId != target.LevelOfEducationTypeId)
            {
                source.LevelOfEducationTypeId = target.LevelOfEducationTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ILevelOfEducationType source, ILevelOfEducationType target, Action<ILevelOfEducationType, ILevelOfEducationType> onMapped)
        {
            var sourceSynchSupport = source as ILevelOfEducationTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as ILevelOfEducationTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.LevelOfEducationTypeId = source.LevelOfEducationTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ILevelOfEducationTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: LimitedEnglishProficiencyDescriptor

namespace EdFi.Ods.Entities.Common //.LimitedEnglishProficiencyDescriptorAggregate
{ 
    public static class LimitedEnglishProficiencyDescriptorMapper 
    {
        public static bool SynchronizeTo(this ILimitedEnglishProficiencyDescriptor source, ILimitedEnglishProficiencyDescriptor target)
        {
            bool isModified = false;

            var sourceSupport = source as ILimitedEnglishProficiencyDescriptorSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.LimitedEnglishProficiencyDescriptorId != target.LimitedEnglishProficiencyDescriptorId)
            {
                source.LimitedEnglishProficiencyDescriptorId = target.LimitedEnglishProficiencyDescriptorId;
            }

            // Copy inherited non-PK properties


            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveBeginDateSupported)
                && target.EffectiveBeginDate != source.EffectiveBeginDate)
            {
                target.EffectiveBeginDate = source.EffectiveBeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveEndDateSupported)
                && target.EffectiveEndDate != source.EffectiveEndDate)
            {
                target.EffectiveEndDate = source.EffectiveEndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNamespaceSupported)
                && target.Namespace != source.Namespace)
            {
                target.Namespace = source.Namespace;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPriorDescriptorIdSupported)
                && target.PriorDescriptorId != source.PriorDescriptorId)
            {
                target.PriorDescriptorId = source.PriorDescriptorId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsLimitedEnglishProficiencyTypeSupported)
                && target.LimitedEnglishProficiencyType != source.LimitedEnglishProficiencyType)
            {
                target.LimitedEnglishProficiencyType = source.LimitedEnglishProficiencyType;
                isModified = true;
            }

            // Synch inherited lists


            // Sync lists

            return isModified;
        }



        public static void MapTo(this ILimitedEnglishProficiencyDescriptor source, ILimitedEnglishProficiencyDescriptor target, Action<ILimitedEnglishProficiencyDescriptor, ILimitedEnglishProficiencyDescriptor> onMapped)
        {
            var sourceSynchSupport = source as ILimitedEnglishProficiencyDescriptorSynchronizationSourceSupport;
            var targetSynchSupport = target as ILimitedEnglishProficiencyDescriptorSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.LimitedEnglishProficiencyDescriptorId = source.LimitedEnglishProficiencyDescriptorId;

            // Copy inherited non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsEffectiveBeginDateSupported)
                target.EffectiveBeginDate = source.EffectiveBeginDate;
            else
                targetSynchSupport.IsEffectiveBeginDateSupported = false;

            if (sourceSynchSupport.IsEffectiveEndDateSupported)
                target.EffectiveEndDate = source.EffectiveEndDate;
            else
                targetSynchSupport.IsEffectiveEndDateSupported = false;

            if (sourceSynchSupport.IsNamespaceSupported)
                target.Namespace = source.Namespace;
            else
                targetSynchSupport.IsNamespaceSupported = false;

            if (sourceSynchSupport.IsPriorDescriptorIdSupported)
                target.PriorDescriptorId = source.PriorDescriptorId;
            else
                targetSynchSupport.IsPriorDescriptorIdSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Copy non-PK properties

            if (sourceSynchSupport.IsLimitedEnglishProficiencyTypeSupported)
                target.LimitedEnglishProficiencyType = source.LimitedEnglishProficiencyType;
            else
                targetSynchSupport.IsLimitedEnglishProficiencyTypeSupported = false;

            // Map inherited lists

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ILimitedEnglishProficiencyDescriptorSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsEffectiveBeginDateSupported { get; set; }
        bool IsEffectiveEndDateSupported { get; set; }
        bool IsLimitedEnglishProficiencyTypeSupported { get; set; }
        bool IsNamespaceSupported { get; set; }
        bool IsPriorDescriptorIdSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: LimitedEnglishProficiencyType

namespace EdFi.Ods.Entities.Common //.LimitedEnglishProficiencyTypeAggregate
{ 
    public static class LimitedEnglishProficiencyTypeMapper 
    {
        public static bool SynchronizeTo(this ILimitedEnglishProficiencyType source, ILimitedEnglishProficiencyType target)
        {
            bool isModified = false;

            var sourceSupport = source as ILimitedEnglishProficiencyTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.LimitedEnglishProficiencyTypeId != target.LimitedEnglishProficiencyTypeId)
            {
                source.LimitedEnglishProficiencyTypeId = target.LimitedEnglishProficiencyTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ILimitedEnglishProficiencyType source, ILimitedEnglishProficiencyType target, Action<ILimitedEnglishProficiencyType, ILimitedEnglishProficiencyType> onMapped)
        {
            var sourceSynchSupport = source as ILimitedEnglishProficiencyTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as ILimitedEnglishProficiencyTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.LimitedEnglishProficiencyTypeId = source.LimitedEnglishProficiencyTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ILimitedEnglishProficiencyTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: LocalEducationAgency

namespace EdFi.Ods.Entities.Common //.LocalEducationAgencyAggregate
{ 
    public static class LocalEducationAgencyMapper 
    {
        public static bool SynchronizeTo(this ILocalEducationAgency source, ILocalEducationAgency target)
        {
            bool isModified = false;

            var sourceSupport = source as ILocalEducationAgencySynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.LocalEducationAgencyId != target.LocalEducationAgencyId)
            {
                source.LocalEducationAgencyId = target.LocalEducationAgencyId;
            }

            // Copy inherited non-PK properties


            if ((sourceSupport == null || sourceSupport.IsNameOfInstitutionSupported)
                && target.NameOfInstitution != source.NameOfInstitution)
            {
                target.NameOfInstitution = source.NameOfInstitution;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsOperationalStatusTypeSupported)
                && target.OperationalStatusType != source.OperationalStatusType)
            {
                target.OperationalStatusType = source.OperationalStatusType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortNameOfInstitutionSupported)
                && target.ShortNameOfInstitution != source.ShortNameOfInstitution)
            {
                target.ShortNameOfInstitution = source.ShortNameOfInstitution;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsStateOrganizationIdSupported)
                && target.StateOrganizationId != source.StateOrganizationId)
            {
                target.StateOrganizationId = source.StateOrganizationId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsWebSiteSupported)
                && target.WebSite != source.WebSite)
            {
                target.WebSite = source.WebSite;
                isModified = true;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCharterStatusTypeSupported)
                && target.CharterStatusType != source.CharterStatusType)
            {
                target.CharterStatusType = source.CharterStatusType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEducationServiceCenterIdSupported)
                && target.EducationServiceCenterId != source.EducationServiceCenterId)
            {
                target.EducationServiceCenterId = source.EducationServiceCenterId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsLocalEducationAgencyCategoryTypeSupported)
                && target.LocalEducationAgencyCategoryType != source.LocalEducationAgencyCategoryType)
            {
                target.LocalEducationAgencyCategoryType = source.LocalEducationAgencyCategoryType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsParentLocalEducationAgencyIdSupported)
                && target.ParentLocalEducationAgencyId != source.ParentLocalEducationAgencyId)
            {
                target.ParentLocalEducationAgencyId = source.ParentLocalEducationAgencyId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsStateEducationAgencyIdSupported)
                && target.StateEducationAgencyId != source.StateEducationAgencyId)
            {
                target.StateEducationAgencyId = source.StateEducationAgencyId;
                isModified = true;
            }

            // Synch inherited lists
            if (sourceSupport == null || sourceSupport.IsEducationOrganizationAddressesSupported)
                isModified |= source.EducationOrganizationAddresses.SynchronizeListTo(target.EducationOrganizationAddresses, child => child.EducationOrganization = target,
                                sourceSupport == null ? null : sourceSupport.IsEducationOrganizationAddressIncluded);

            if (sourceSupport == null || sourceSupport.IsEducationOrganizationCategoriesSupported)
                isModified |= source.EducationOrganizationCategories.SynchronizeListTo(target.EducationOrganizationCategories, child => child.EducationOrganization = target,
                                sourceSupport == null ? null : sourceSupport.IsEducationOrganizationCategoryIncluded);

            if (sourceSupport == null || sourceSupport.IsEducationOrganizationIdentificationCodesSupported)
                isModified |= source.EducationOrganizationIdentificationCodes.SynchronizeListTo(target.EducationOrganizationIdentificationCodes, child => child.EducationOrganization = target,
                                sourceSupport == null ? null : sourceSupport.IsEducationOrganizationIdentificationCodeIncluded);

            if (sourceSupport == null || sourceSupport.IsEducationOrganizationInstitutionTelephonesSupported)
                isModified |= source.EducationOrganizationInstitutionTelephones.SynchronizeListTo(target.EducationOrganizationInstitutionTelephones, child => child.EducationOrganization = target,
                                sourceSupport == null ? null : sourceSupport.IsEducationOrganizationInstitutionTelephoneIncluded);

            if (sourceSupport == null || sourceSupport.IsEducationOrganizationInternationalAddressesSupported)
                isModified |= source.EducationOrganizationInternationalAddresses.SynchronizeListTo(target.EducationOrganizationInternationalAddresses, child => child.EducationOrganization = target,
                                sourceSupport == null ? null : sourceSupport.IsEducationOrganizationInternationalAddressIncluded);



            // Sync lists
            if (sourceSupport == null || sourceSupport.IsLocalEducationAgencyAccountabilitiesSupported)
                isModified |= source.LocalEducationAgencyAccountabilities.SynchronizeListTo(target.LocalEducationAgencyAccountabilities, child => child.LocalEducationAgency = target,
                                sourceSupport == null ? null : sourceSupport.IsLocalEducationAgencyAccountabilityIncluded);


            return isModified;
        }



        public static void MapTo(this ILocalEducationAgency source, ILocalEducationAgency target, Action<ILocalEducationAgency, ILocalEducationAgency> onMapped)
        {
            var sourceSynchSupport = source as ILocalEducationAgencySynchronizationSourceSupport;
            var targetSynchSupport = target as ILocalEducationAgencySynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.LocalEducationAgencyId = source.LocalEducationAgencyId;

            // Copy inherited non-PK properties

            if (sourceSynchSupport.IsNameOfInstitutionSupported)
                target.NameOfInstitution = source.NameOfInstitution;
            else
                targetSynchSupport.IsNameOfInstitutionSupported = false;

            if (sourceSynchSupport.IsOperationalStatusTypeSupported)
                target.OperationalStatusType = source.OperationalStatusType;
            else
                targetSynchSupport.IsOperationalStatusTypeSupported = false;

            if (sourceSynchSupport.IsShortNameOfInstitutionSupported)
                target.ShortNameOfInstitution = source.ShortNameOfInstitution;
            else
                targetSynchSupport.IsShortNameOfInstitutionSupported = false;

            if (sourceSynchSupport.IsStateOrganizationIdSupported)
                target.StateOrganizationId = source.StateOrganizationId;
            else
                targetSynchSupport.IsStateOrganizationIdSupported = false;

            if (sourceSynchSupport.IsWebSiteSupported)
                target.WebSite = source.WebSite;
            else
                targetSynchSupport.IsWebSiteSupported = false;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCharterStatusTypeSupported)
                target.CharterStatusType = source.CharterStatusType;
            else
                targetSynchSupport.IsCharterStatusTypeSupported = false;

            if (sourceSynchSupport.IsEducationServiceCenterIdSupported)
                target.EducationServiceCenterId = source.EducationServiceCenterId;
            else
                targetSynchSupport.IsEducationServiceCenterIdSupported = false;

            if (sourceSynchSupport.IsLocalEducationAgencyCategoryTypeSupported)
                target.LocalEducationAgencyCategoryType = source.LocalEducationAgencyCategoryType;
            else
                targetSynchSupport.IsLocalEducationAgencyCategoryTypeSupported = false;

            if (sourceSynchSupport.IsParentLocalEducationAgencyIdSupported)
                target.ParentLocalEducationAgencyId = source.ParentLocalEducationAgencyId;
            else
                targetSynchSupport.IsParentLocalEducationAgencyIdSupported = false;

            if (sourceSynchSupport.IsStateEducationAgencyIdSupported)
                target.StateEducationAgencyId = source.StateEducationAgencyId;
            else
                targetSynchSupport.IsStateEducationAgencyIdSupported = false;

            // Map inherited lists

            if (sourceSynchSupport.IsEducationOrganizationAddressesSupported)
            {
                targetSynchSupport.IsEducationOrganizationAddressIncluded = sourceSynchSupport.IsEducationOrganizationAddressIncluded;
                source.EducationOrganizationAddresses.MapListTo(target.EducationOrganizationAddresses);
            }
            else
            {
                targetSynchSupport.IsEducationOrganizationAddressesSupported = false;
            }

            if (sourceSynchSupport.IsEducationOrganizationCategoriesSupported)
            {
                targetSynchSupport.IsEducationOrganizationCategoryIncluded = sourceSynchSupport.IsEducationOrganizationCategoryIncluded;
                source.EducationOrganizationCategories.MapListTo(target.EducationOrganizationCategories);
            }
            else
            {
                targetSynchSupport.IsEducationOrganizationCategoriesSupported = false;
            }

            if (sourceSynchSupport.IsEducationOrganizationIdentificationCodesSupported)
            {
                targetSynchSupport.IsEducationOrganizationIdentificationCodeIncluded = sourceSynchSupport.IsEducationOrganizationIdentificationCodeIncluded;
                source.EducationOrganizationIdentificationCodes.MapListTo(target.EducationOrganizationIdentificationCodes);
            }
            else
            {
                targetSynchSupport.IsEducationOrganizationIdentificationCodesSupported = false;
            }

            if (sourceSynchSupport.IsEducationOrganizationInstitutionTelephonesSupported)
            {
                targetSynchSupport.IsEducationOrganizationInstitutionTelephoneIncluded = sourceSynchSupport.IsEducationOrganizationInstitutionTelephoneIncluded;
                source.EducationOrganizationInstitutionTelephones.MapListTo(target.EducationOrganizationInstitutionTelephones);
            }
            else
            {
                targetSynchSupport.IsEducationOrganizationInstitutionTelephonesSupported = false;
            }

            if (sourceSynchSupport.IsEducationOrganizationInternationalAddressesSupported)
            {
                targetSynchSupport.IsEducationOrganizationInternationalAddressIncluded = sourceSynchSupport.IsEducationOrganizationInternationalAddressIncluded;
                source.EducationOrganizationInternationalAddresses.MapListTo(target.EducationOrganizationInternationalAddresses);
            }
            else
            {
                targetSynchSupport.IsEducationOrganizationInternationalAddressesSupported = false;
            }

            // Map lists

            if (sourceSynchSupport.IsLocalEducationAgencyAccountabilitiesSupported)
            {    
                targetSynchSupport.IsLocalEducationAgencyAccountabilityIncluded = sourceSynchSupport.IsLocalEducationAgencyAccountabilityIncluded;
                source.LocalEducationAgencyAccountabilities.MapListTo(target.LocalEducationAgencyAccountabilities);
            }
            else
            {
                targetSynchSupport.IsLocalEducationAgencyAccountabilitiesSupported = false;
            }

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ILocalEducationAgencySynchronizationSourceSupport
    {
        bool IsCharterStatusTypeSupported { get; set; }
        bool IsEducationOrganizationAddressesSupported { get; set; }
        bool IsEducationOrganizationCategoriesSupported { get; set; }
        bool IsEducationOrganizationIdentificationCodesSupported { get; set; }
        bool IsEducationOrganizationInstitutionTelephonesSupported { get; set; }
        bool IsEducationOrganizationInternationalAddressesSupported { get; set; }
        bool IsEducationServiceCenterIdSupported { get; set; }
        bool IsLocalEducationAgencyAccountabilitiesSupported { get; set; }
        bool IsLocalEducationAgencyCategoryTypeSupported { get; set; }
        bool IsNameOfInstitutionSupported { get; set; }
        bool IsOperationalStatusTypeSupported { get; set; }
        bool IsParentLocalEducationAgencyIdSupported { get; set; }
        bool IsShortNameOfInstitutionSupported { get; set; }
        bool IsStateEducationAgencyIdSupported { get; set; }
        bool IsStateOrganizationIdSupported { get; set; }
        bool IsWebSiteSupported { get; set; }
        Func<IEducationOrganizationAddress, bool> IsEducationOrganizationAddressIncluded { get; set; }
        Func<IEducationOrganizationCategory, bool> IsEducationOrganizationCategoryIncluded { get; set; }
        Func<IEducationOrganizationIdentificationCode, bool> IsEducationOrganizationIdentificationCodeIncluded { get; set; }
        Func<IEducationOrganizationInstitutionTelephone, bool> IsEducationOrganizationInstitutionTelephoneIncluded { get; set; }
        Func<IEducationOrganizationInternationalAddress, bool> IsEducationOrganizationInternationalAddressIncluded { get; set; }
        Func<ILocalEducationAgencyAccountability, bool> IsLocalEducationAgencyAccountabilityIncluded { get; set; }
    }
 
    public static class LocalEducationAgencyAccountabilityMapper 
    {
        public static bool SynchronizeTo(this ILocalEducationAgencyAccountability source, ILocalEducationAgencyAccountability target)
        {
            bool isModified = false;

            var sourceSupport = source as ILocalEducationAgencyAccountabilitySynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.SchoolYear != target.SchoolYear)
            {
                source.SchoolYear = target.SchoolYear;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsGunFreeSchoolsActReportingStatusTypeSupported)
                && target.GunFreeSchoolsActReportingStatusType != source.GunFreeSchoolsActReportingStatusType)
            {
                target.GunFreeSchoolsActReportingStatusType = source.GunFreeSchoolsActReportingStatusType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsSchoolChoiceImplementStatusTypeSupported)
                && target.SchoolChoiceImplementStatusType != source.SchoolChoiceImplementStatusType)
            {
                target.SchoolChoiceImplementStatusType = source.SchoolChoiceImplementStatusType;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ILocalEducationAgencyAccountability source, ILocalEducationAgencyAccountability target, Action<ILocalEducationAgencyAccountability, ILocalEducationAgencyAccountability> onMapped)
        {
            var sourceSynchSupport = source as ILocalEducationAgencyAccountabilitySynchronizationSourceSupport;
            var targetSynchSupport = target as ILocalEducationAgencyAccountabilitySynchronizationSourceSupport;

            // Copy contextual primary key values
            target.SchoolYear = source.SchoolYear;

            // Copy non-PK properties

            if (sourceSynchSupport.IsGunFreeSchoolsActReportingStatusTypeSupported)
                target.GunFreeSchoolsActReportingStatusType = source.GunFreeSchoolsActReportingStatusType;
            else
                targetSynchSupport.IsGunFreeSchoolsActReportingStatusTypeSupported = false;

            if (sourceSynchSupport.IsSchoolChoiceImplementStatusTypeSupported)
                target.SchoolChoiceImplementStatusType = source.SchoolChoiceImplementStatusType;
            else
                targetSynchSupport.IsSchoolChoiceImplementStatusTypeSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ILocalEducationAgencyAccountabilitySynchronizationSourceSupport
    {
        bool IsGunFreeSchoolsActReportingStatusTypeSupported { get; set; }
        bool IsSchoolChoiceImplementStatusTypeSupported { get; set; }
    }
 
}
// Aggregate: LocalEducationAgencyCategoryType

namespace EdFi.Ods.Entities.Common //.LocalEducationAgencyCategoryTypeAggregate
{ 
    public static class LocalEducationAgencyCategoryTypeMapper 
    {
        public static bool SynchronizeTo(this ILocalEducationAgencyCategoryType source, ILocalEducationAgencyCategoryType target)
        {
            bool isModified = false;

            var sourceSupport = source as ILocalEducationAgencyCategoryTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.LocalEducationAgencyCategoryTypeId != target.LocalEducationAgencyCategoryTypeId)
            {
                source.LocalEducationAgencyCategoryTypeId = target.LocalEducationAgencyCategoryTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ILocalEducationAgencyCategoryType source, ILocalEducationAgencyCategoryType target, Action<ILocalEducationAgencyCategoryType, ILocalEducationAgencyCategoryType> onMapped)
        {
            var sourceSynchSupport = source as ILocalEducationAgencyCategoryTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as ILocalEducationAgencyCategoryTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.LocalEducationAgencyCategoryTypeId = source.LocalEducationAgencyCategoryTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ILocalEducationAgencyCategoryTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: Location

namespace EdFi.Ods.Entities.Common //.LocationAggregate
{ 
    public static class LocationMapper 
    {
        public static bool SynchronizeTo(this ILocation source, ILocation target)
        {
            bool isModified = false;

            var sourceSupport = source as ILocationSynchronizationSourceSupport;

            // Allow PK column updates on Location
            if (
                 (target.ClassroomIdentificationCode != source.ClassroomIdentificationCode)
                || (target.SchoolId != source.SchoolId))
            {            
                isModified = true;

                var sourceWithPrimaryKeyValues = (source as IHasPrimaryKeyValues);

                if (sourceWithPrimaryKeyValues != null)
                {
                    var targetWithNewKeyValues = target as IHasCascadableKeyValues;

                    if (targetWithNewKeyValues != null)
                        targetWithNewKeyValues.NewKeyValues = sourceWithPrimaryKeyValues.GetPrimaryKeyValues();
                }
            }

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.ClassroomIdentificationCode != target.ClassroomIdentificationCode)
            {
                source.ClassroomIdentificationCode = target.ClassroomIdentificationCode;
            }
            if (source.SchoolId != target.SchoolId)
            {
                source.SchoolId = target.SchoolId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsMaximumNumberOfSeatsSupported)
                && target.MaximumNumberOfSeats != source.MaximumNumberOfSeats)
            {
                target.MaximumNumberOfSeats = source.MaximumNumberOfSeats;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsOptimalNumberOfSeatsSupported)
                && target.OptimalNumberOfSeats != source.OptimalNumberOfSeats)
            {
                target.OptimalNumberOfSeats = source.OptimalNumberOfSeats;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ILocation source, ILocation target, Action<ILocation, ILocation> onMapped)
        {
            var sourceSynchSupport = source as ILocationSynchronizationSourceSupport;
            var targetSynchSupport = target as ILocationSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.ClassroomIdentificationCode = source.ClassroomIdentificationCode;
            target.SchoolId = source.SchoolId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsMaximumNumberOfSeatsSupported)
                target.MaximumNumberOfSeats = source.MaximumNumberOfSeats;
            else
                targetSynchSupport.IsMaximumNumberOfSeatsSupported = false;

            if (sourceSynchSupport.IsOptimalNumberOfSeatsSupported)
                target.OptimalNumberOfSeats = source.OptimalNumberOfSeats;
            else
                targetSynchSupport.IsOptimalNumberOfSeatsSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ILocationSynchronizationSourceSupport
    {
        bool IsMaximumNumberOfSeatsSupported { get; set; }
        bool IsOptimalNumberOfSeatsSupported { get; set; }
    }
 
}
// Aggregate: MagnetSpecialProgramEmphasisSchoolType

namespace EdFi.Ods.Entities.Common //.MagnetSpecialProgramEmphasisSchoolTypeAggregate
{ 
    public static class MagnetSpecialProgramEmphasisSchoolTypeMapper 
    {
        public static bool SynchronizeTo(this IMagnetSpecialProgramEmphasisSchoolType source, IMagnetSpecialProgramEmphasisSchoolType target)
        {
            bool isModified = false;

            var sourceSupport = source as IMagnetSpecialProgramEmphasisSchoolTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.MagnetSpecialProgramEmphasisSchoolTypeId != target.MagnetSpecialProgramEmphasisSchoolTypeId)
            {
                source.MagnetSpecialProgramEmphasisSchoolTypeId = target.MagnetSpecialProgramEmphasisSchoolTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IMagnetSpecialProgramEmphasisSchoolType source, IMagnetSpecialProgramEmphasisSchoolType target, Action<IMagnetSpecialProgramEmphasisSchoolType, IMagnetSpecialProgramEmphasisSchoolType> onMapped)
        {
            var sourceSynchSupport = source as IMagnetSpecialProgramEmphasisSchoolTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IMagnetSpecialProgramEmphasisSchoolTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.MagnetSpecialProgramEmphasisSchoolTypeId = source.MagnetSpecialProgramEmphasisSchoolTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IMagnetSpecialProgramEmphasisSchoolTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: MediumOfInstructionType

namespace EdFi.Ods.Entities.Common //.MediumOfInstructionTypeAggregate
{ 
    public static class MediumOfInstructionTypeMapper 
    {
        public static bool SynchronizeTo(this IMediumOfInstructionType source, IMediumOfInstructionType target)
        {
            bool isModified = false;

            var sourceSupport = source as IMediumOfInstructionTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.MediumOfInstructionTypeId != target.MediumOfInstructionTypeId)
            {
                source.MediumOfInstructionTypeId = target.MediumOfInstructionTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IMediumOfInstructionType source, IMediumOfInstructionType target, Action<IMediumOfInstructionType, IMediumOfInstructionType> onMapped)
        {
            var sourceSynchSupport = source as IMediumOfInstructionTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IMediumOfInstructionTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.MediumOfInstructionTypeId = source.MediumOfInstructionTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IMediumOfInstructionTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: MeetingDayType

namespace EdFi.Ods.Entities.Common //.MeetingDayTypeAggregate
{ 
    public static class MeetingDayTypeMapper 
    {
        public static bool SynchronizeTo(this IMeetingDayType source, IMeetingDayType target)
        {
            bool isModified = false;

            var sourceSupport = source as IMeetingDayTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.MeetingDayTypeId != target.MeetingDayTypeId)
            {
                source.MeetingDayTypeId = target.MeetingDayTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IMeetingDayType source, IMeetingDayType target, Action<IMeetingDayType, IMeetingDayType> onMapped)
        {
            var sourceSynchSupport = source as IMeetingDayTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IMeetingDayTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.MeetingDayTypeId = source.MeetingDayTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IMeetingDayTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: MethodCreditEarnedType

namespace EdFi.Ods.Entities.Common //.MethodCreditEarnedTypeAggregate
{ 
    public static class MethodCreditEarnedTypeMapper 
    {
        public static bool SynchronizeTo(this IMethodCreditEarnedType source, IMethodCreditEarnedType target)
        {
            bool isModified = false;

            var sourceSupport = source as IMethodCreditEarnedTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.MethodCreditEarnedTypeId != target.MethodCreditEarnedTypeId)
            {
                source.MethodCreditEarnedTypeId = target.MethodCreditEarnedTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IMethodCreditEarnedType source, IMethodCreditEarnedType target, Action<IMethodCreditEarnedType, IMethodCreditEarnedType> onMapped)
        {
            var sourceSynchSupport = source as IMethodCreditEarnedTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IMethodCreditEarnedTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.MethodCreditEarnedTypeId = source.MethodCreditEarnedTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IMethodCreditEarnedTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: NetworkPurposeType

namespace EdFi.Ods.Entities.Common //.NetworkPurposeTypeAggregate
{ 
    public static class NetworkPurposeTypeMapper 
    {
        public static bool SynchronizeTo(this INetworkPurposeType source, INetworkPurposeType target)
        {
            bool isModified = false;

            var sourceSupport = source as INetworkPurposeTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.NetworkPurposeTypeId != target.NetworkPurposeTypeId)
            {
                source.NetworkPurposeTypeId = target.NetworkPurposeTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this INetworkPurposeType source, INetworkPurposeType target, Action<INetworkPurposeType, INetworkPurposeType> onMapped)
        {
            var sourceSynchSupport = source as INetworkPurposeTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as INetworkPurposeTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.NetworkPurposeTypeId = source.NetworkPurposeTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface INetworkPurposeTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: ObjectiveAssessment

namespace EdFi.Ods.Entities.Common //.ObjectiveAssessmentAggregate
{ 
    public static class ObjectiveAssessmentMapper 
    {
        public static bool SynchronizeTo(this IObjectiveAssessment source, IObjectiveAssessment target)
        {
            bool isModified = false;

            var sourceSupport = source as IObjectiveAssessmentSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AssessmentIdentifier != target.AssessmentIdentifier)
            {
                source.AssessmentIdentifier = target.AssessmentIdentifier;
            }
            if (source.IdentificationCode != target.IdentificationCode)
            {
                source.IdentificationCode = target.IdentificationCode;
            }
            if (source.Namespace != target.Namespace)
            {
                source.Namespace = target.Namespace;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsMaxRawScoreSupported)
                && target.MaxRawScore != source.MaxRawScore)
            {
                target.MaxRawScore = source.MaxRawScore;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNomenclatureSupported)
                && target.Nomenclature != source.Nomenclature)
            {
                target.Nomenclature = source.Nomenclature;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsParentIdentificationCodeSupported)
                && target.ParentIdentificationCode != source.ParentIdentificationCode)
            {
                target.ParentIdentificationCode = source.ParentIdentificationCode;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPercentOfAssessmentSupported)
                && target.PercentOfAssessment != source.PercentOfAssessment)
            {
                target.PercentOfAssessment = source.PercentOfAssessment;
                isModified = true;
            }



            // Sync lists
            if (sourceSupport == null || sourceSupport.IsObjectiveAssessmentAssessmentItemsSupported)
                isModified |= source.ObjectiveAssessmentAssessmentItems.SynchronizeListTo(target.ObjectiveAssessmentAssessmentItems, child => child.ObjectiveAssessment = target,
                                sourceSupport == null ? null : sourceSupport.IsObjectiveAssessmentAssessmentItemIncluded);

            if (sourceSupport == null || sourceSupport.IsObjectiveAssessmentLearningObjectivesSupported)
                isModified |= source.ObjectiveAssessmentLearningObjectives.SynchronizeListTo(target.ObjectiveAssessmentLearningObjectives, child => child.ObjectiveAssessment = target,
                                sourceSupport == null ? null : sourceSupport.IsObjectiveAssessmentLearningObjectiveIncluded);

            if (sourceSupport == null || sourceSupport.IsObjectiveAssessmentLearningStandardsSupported)
                isModified |= source.ObjectiveAssessmentLearningStandards.SynchronizeListTo(target.ObjectiveAssessmentLearningStandards, child => child.ObjectiveAssessment = target,
                                sourceSupport == null ? null : sourceSupport.IsObjectiveAssessmentLearningStandardIncluded);

            if (sourceSupport == null || sourceSupport.IsObjectiveAssessmentPerformanceLevelsSupported)
                isModified |= source.ObjectiveAssessmentPerformanceLevels.SynchronizeListTo(target.ObjectiveAssessmentPerformanceLevels, child => child.ObjectiveAssessment = target,
                                sourceSupport == null ? null : sourceSupport.IsObjectiveAssessmentPerformanceLevelIncluded);

            if (sourceSupport == null || sourceSupport.IsObjectiveAssessmentScoresSupported)
                isModified |= source.ObjectiveAssessmentScores.SynchronizeListTo(target.ObjectiveAssessmentScores, child => child.ObjectiveAssessment = target,
                                sourceSupport == null ? null : sourceSupport.IsObjectiveAssessmentScoreIncluded);


            return isModified;
        }



        public static void MapTo(this IObjectiveAssessment source, IObjectiveAssessment target, Action<IObjectiveAssessment, IObjectiveAssessment> onMapped)
        {
            var sourceSynchSupport = source as IObjectiveAssessmentSynchronizationSourceSupport;
            var targetSynchSupport = target as IObjectiveAssessmentSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.AssessmentIdentifier = source.AssessmentIdentifier;
            target.IdentificationCode = source.IdentificationCode;
            target.Namespace = source.Namespace;

            // Copy non-PK properties

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsMaxRawScoreSupported)
                target.MaxRawScore = source.MaxRawScore;
            else
                targetSynchSupport.IsMaxRawScoreSupported = false;

            if (sourceSynchSupport.IsNomenclatureSupported)
                target.Nomenclature = source.Nomenclature;
            else
                targetSynchSupport.IsNomenclatureSupported = false;

            if (sourceSynchSupport.IsParentIdentificationCodeSupported)
                target.ParentIdentificationCode = source.ParentIdentificationCode;
            else
                targetSynchSupport.IsParentIdentificationCodeSupported = false;

            if (sourceSynchSupport.IsPercentOfAssessmentSupported)
                target.PercentOfAssessment = source.PercentOfAssessment;
            else
                targetSynchSupport.IsPercentOfAssessmentSupported = false;

            // Map lists

            if (sourceSynchSupport.IsObjectiveAssessmentAssessmentItemsSupported)
            {    
                targetSynchSupport.IsObjectiveAssessmentAssessmentItemIncluded = sourceSynchSupport.IsObjectiveAssessmentAssessmentItemIncluded;
                source.ObjectiveAssessmentAssessmentItems.MapListTo(target.ObjectiveAssessmentAssessmentItems);
            }
            else
            {
                targetSynchSupport.IsObjectiveAssessmentAssessmentItemsSupported = false;
            }

            if (sourceSynchSupport.IsObjectiveAssessmentLearningObjectivesSupported)
            {    
                targetSynchSupport.IsObjectiveAssessmentLearningObjectiveIncluded = sourceSynchSupport.IsObjectiveAssessmentLearningObjectiveIncluded;
                source.ObjectiveAssessmentLearningObjectives.MapListTo(target.ObjectiveAssessmentLearningObjectives);
            }
            else
            {
                targetSynchSupport.IsObjectiveAssessmentLearningObjectivesSupported = false;
            }

            if (sourceSynchSupport.IsObjectiveAssessmentLearningStandardsSupported)
            {    
                targetSynchSupport.IsObjectiveAssessmentLearningStandardIncluded = sourceSynchSupport.IsObjectiveAssessmentLearningStandardIncluded;
                source.ObjectiveAssessmentLearningStandards.MapListTo(target.ObjectiveAssessmentLearningStandards);
            }
            else
            {
                targetSynchSupport.IsObjectiveAssessmentLearningStandardsSupported = false;
            }

            if (sourceSynchSupport.IsObjectiveAssessmentPerformanceLevelsSupported)
            {    
                targetSynchSupport.IsObjectiveAssessmentPerformanceLevelIncluded = sourceSynchSupport.IsObjectiveAssessmentPerformanceLevelIncluded;
                source.ObjectiveAssessmentPerformanceLevels.MapListTo(target.ObjectiveAssessmentPerformanceLevels);
            }
            else
            {
                targetSynchSupport.IsObjectiveAssessmentPerformanceLevelsSupported = false;
            }

            if (sourceSynchSupport.IsObjectiveAssessmentScoresSupported)
            {    
                targetSynchSupport.IsObjectiveAssessmentScoreIncluded = sourceSynchSupport.IsObjectiveAssessmentScoreIncluded;
                source.ObjectiveAssessmentScores.MapListTo(target.ObjectiveAssessmentScores);
            }
            else
            {
                targetSynchSupport.IsObjectiveAssessmentScoresSupported = false;
            }

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IObjectiveAssessmentSynchronizationSourceSupport
    {
        bool IsDescriptionSupported { get; set; }
        bool IsMaxRawScoreSupported { get; set; }
        bool IsNomenclatureSupported { get; set; }
        bool IsObjectiveAssessmentAssessmentItemsSupported { get; set; }
        bool IsObjectiveAssessmentLearningObjectivesSupported { get; set; }
        bool IsObjectiveAssessmentLearningStandardsSupported { get; set; }
        bool IsObjectiveAssessmentPerformanceLevelsSupported { get; set; }
        bool IsObjectiveAssessmentScoresSupported { get; set; }
        bool IsParentIdentificationCodeSupported { get; set; }
        bool IsPercentOfAssessmentSupported { get; set; }
        Func<IObjectiveAssessmentAssessmentItem, bool> IsObjectiveAssessmentAssessmentItemIncluded { get; set; }
        Func<IObjectiveAssessmentLearningObjective, bool> IsObjectiveAssessmentLearningObjectiveIncluded { get; set; }
        Func<IObjectiveAssessmentLearningStandard, bool> IsObjectiveAssessmentLearningStandardIncluded { get; set; }
        Func<IObjectiveAssessmentPerformanceLevel, bool> IsObjectiveAssessmentPerformanceLevelIncluded { get; set; }
        Func<IObjectiveAssessmentScore, bool> IsObjectiveAssessmentScoreIncluded { get; set; }
    }
 
    public static class ObjectiveAssessmentAssessmentItemMapper 
    {
        public static bool SynchronizeTo(this IObjectiveAssessmentAssessmentItem source, IObjectiveAssessmentAssessmentItem target)
        {
            bool isModified = false;

            var sourceSupport = source as IObjectiveAssessmentAssessmentItemSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AssessmentItemIdentificationCode != target.AssessmentItemIdentificationCode)
            {
                source.AssessmentItemIdentificationCode = target.AssessmentItemIdentificationCode;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IObjectiveAssessmentAssessmentItem source, IObjectiveAssessmentAssessmentItem target, Action<IObjectiveAssessmentAssessmentItem, IObjectiveAssessmentAssessmentItem> onMapped)
        {
            var sourceSynchSupport = source as IObjectiveAssessmentAssessmentItemSynchronizationSourceSupport;
            var targetSynchSupport = target as IObjectiveAssessmentAssessmentItemSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.AssessmentItemIdentificationCode = source.AssessmentItemIdentificationCode;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IObjectiveAssessmentAssessmentItemSynchronizationSourceSupport
    {
    }
 
    public static class ObjectiveAssessmentLearningObjectiveMapper 
    {
        public static bool SynchronizeTo(this IObjectiveAssessmentLearningObjective source, IObjectiveAssessmentLearningObjective target)
        {
            bool isModified = false;

            var sourceSupport = source as IObjectiveAssessmentLearningObjectiveSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.LearningObjectiveId != target.LearningObjectiveId)
            {
                source.LearningObjectiveId = target.LearningObjectiveId;
            }
            if (source.LearningObjectiveNamespace != target.LearningObjectiveNamespace)
            {
                source.LearningObjectiveNamespace = target.LearningObjectiveNamespace;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IObjectiveAssessmentLearningObjective source, IObjectiveAssessmentLearningObjective target, Action<IObjectiveAssessmentLearningObjective, IObjectiveAssessmentLearningObjective> onMapped)
        {
            var sourceSynchSupport = source as IObjectiveAssessmentLearningObjectiveSynchronizationSourceSupport;
            var targetSynchSupport = target as IObjectiveAssessmentLearningObjectiveSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.LearningObjectiveId = source.LearningObjectiveId;
            target.LearningObjectiveNamespace = source.LearningObjectiveNamespace;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IObjectiveAssessmentLearningObjectiveSynchronizationSourceSupport
    {
    }
 
    public static class ObjectiveAssessmentLearningStandardMapper 
    {
        public static bool SynchronizeTo(this IObjectiveAssessmentLearningStandard source, IObjectiveAssessmentLearningStandard target)
        {
            bool isModified = false;

            var sourceSupport = source as IObjectiveAssessmentLearningStandardSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.LearningStandardId != target.LearningStandardId)
            {
                source.LearningStandardId = target.LearningStandardId;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IObjectiveAssessmentLearningStandard source, IObjectiveAssessmentLearningStandard target, Action<IObjectiveAssessmentLearningStandard, IObjectiveAssessmentLearningStandard> onMapped)
        {
            var sourceSynchSupport = source as IObjectiveAssessmentLearningStandardSynchronizationSourceSupport;
            var targetSynchSupport = target as IObjectiveAssessmentLearningStandardSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.LearningStandardId = source.LearningStandardId;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IObjectiveAssessmentLearningStandardSynchronizationSourceSupport
    {
    }
 
    public static class ObjectiveAssessmentPerformanceLevelMapper 
    {
        public static bool SynchronizeTo(this IObjectiveAssessmentPerformanceLevel source, IObjectiveAssessmentPerformanceLevel target)
        {
            bool isModified = false;

            var sourceSupport = source as IObjectiveAssessmentPerformanceLevelSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AssessmentReportingMethodType != target.AssessmentReportingMethodType)
            {
                source.AssessmentReportingMethodType = target.AssessmentReportingMethodType;
            }
            if (source.PerformanceLevelDescriptor != target.PerformanceLevelDescriptor)
            {
                source.PerformanceLevelDescriptor = target.PerformanceLevelDescriptor;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsMaximumScoreSupported)
                && target.MaximumScore != source.MaximumScore)
            {
                target.MaximumScore = source.MaximumScore;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsMinimumScoreSupported)
                && target.MinimumScore != source.MinimumScore)
            {
                target.MinimumScore = source.MinimumScore;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsResultDatatypeTypeSupported)
                && target.ResultDatatypeType != source.ResultDatatypeType)
            {
                target.ResultDatatypeType = source.ResultDatatypeType;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IObjectiveAssessmentPerformanceLevel source, IObjectiveAssessmentPerformanceLevel target, Action<IObjectiveAssessmentPerformanceLevel, IObjectiveAssessmentPerformanceLevel> onMapped)
        {
            var sourceSynchSupport = source as IObjectiveAssessmentPerformanceLevelSynchronizationSourceSupport;
            var targetSynchSupport = target as IObjectiveAssessmentPerformanceLevelSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.AssessmentReportingMethodType = source.AssessmentReportingMethodType;
            target.PerformanceLevelDescriptor = source.PerformanceLevelDescriptor;

            // Copy non-PK properties

            if (sourceSynchSupport.IsMaximumScoreSupported)
                target.MaximumScore = source.MaximumScore;
            else
                targetSynchSupport.IsMaximumScoreSupported = false;

            if (sourceSynchSupport.IsMinimumScoreSupported)
                target.MinimumScore = source.MinimumScore;
            else
                targetSynchSupport.IsMinimumScoreSupported = false;

            if (sourceSynchSupport.IsResultDatatypeTypeSupported)
                target.ResultDatatypeType = source.ResultDatatypeType;
            else
                targetSynchSupport.IsResultDatatypeTypeSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IObjectiveAssessmentPerformanceLevelSynchronizationSourceSupport
    {
        bool IsMaximumScoreSupported { get; set; }
        bool IsMinimumScoreSupported { get; set; }
        bool IsResultDatatypeTypeSupported { get; set; }
    }
 
    public static class ObjectiveAssessmentScoreMapper 
    {
        public static bool SynchronizeTo(this IObjectiveAssessmentScore source, IObjectiveAssessmentScore target)
        {
            bool isModified = false;

            var sourceSupport = source as IObjectiveAssessmentScoreSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AssessmentReportingMethodType != target.AssessmentReportingMethodType)
            {
                source.AssessmentReportingMethodType = target.AssessmentReportingMethodType;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsMaximumScoreSupported)
                && target.MaximumScore != source.MaximumScore)
            {
                target.MaximumScore = source.MaximumScore;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsMinimumScoreSupported)
                && target.MinimumScore != source.MinimumScore)
            {
                target.MinimumScore = source.MinimumScore;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsResultDatatypeTypeSupported)
                && target.ResultDatatypeType != source.ResultDatatypeType)
            {
                target.ResultDatatypeType = source.ResultDatatypeType;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IObjectiveAssessmentScore source, IObjectiveAssessmentScore target, Action<IObjectiveAssessmentScore, IObjectiveAssessmentScore> onMapped)
        {
            var sourceSynchSupport = source as IObjectiveAssessmentScoreSynchronizationSourceSupport;
            var targetSynchSupport = target as IObjectiveAssessmentScoreSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.AssessmentReportingMethodType = source.AssessmentReportingMethodType;

            // Copy non-PK properties

            if (sourceSynchSupport.IsMaximumScoreSupported)
                target.MaximumScore = source.MaximumScore;
            else
                targetSynchSupport.IsMaximumScoreSupported = false;

            if (sourceSynchSupport.IsMinimumScoreSupported)
                target.MinimumScore = source.MinimumScore;
            else
                targetSynchSupport.IsMinimumScoreSupported = false;

            if (sourceSynchSupport.IsResultDatatypeTypeSupported)
                target.ResultDatatypeType = source.ResultDatatypeType;
            else
                targetSynchSupport.IsResultDatatypeTypeSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IObjectiveAssessmentScoreSynchronizationSourceSupport
    {
        bool IsMaximumScoreSupported { get; set; }
        bool IsMinimumScoreSupported { get; set; }
        bool IsResultDatatypeTypeSupported { get; set; }
    }
 
}
// Aggregate: OldEthnicityType

namespace EdFi.Ods.Entities.Common //.OldEthnicityTypeAggregate
{ 
    public static class OldEthnicityTypeMapper 
    {
        public static bool SynchronizeTo(this IOldEthnicityType source, IOldEthnicityType target)
        {
            bool isModified = false;

            var sourceSupport = source as IOldEthnicityTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.OldEthnicityTypeId != target.OldEthnicityTypeId)
            {
                source.OldEthnicityTypeId = target.OldEthnicityTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IOldEthnicityType source, IOldEthnicityType target, Action<IOldEthnicityType, IOldEthnicityType> onMapped)
        {
            var sourceSynchSupport = source as IOldEthnicityTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IOldEthnicityTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.OldEthnicityTypeId = source.OldEthnicityTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IOldEthnicityTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: OpenStaffPosition

namespace EdFi.Ods.Entities.Common //.OpenStaffPositionAggregate
{ 
    public static class OpenStaffPositionMapper 
    {
        public static bool SynchronizeTo(this IOpenStaffPosition source, IOpenStaffPosition target)
        {
            bool isModified = false;

            var sourceSupport = source as IOpenStaffPositionSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.DatePosted != target.DatePosted)
            {
                source.DatePosted = target.DatePosted;
            }
            if (source.EducationOrganizationId != target.EducationOrganizationId)
            {
                source.EducationOrganizationId = target.EducationOrganizationId;
            }
            if (source.EmploymentStatusDescriptor != target.EmploymentStatusDescriptor)
            {
                source.EmploymentStatusDescriptor = target.EmploymentStatusDescriptor;
            }
            if (source.RequisitionNumber != target.RequisitionNumber)
            {
                source.RequisitionNumber = target.RequisitionNumber;
            }
            if (source.StaffClassificationDescriptor != target.StaffClassificationDescriptor)
            {
                source.StaffClassificationDescriptor = target.StaffClassificationDescriptor;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsDatePostingRemovedSupported)
                && target.DatePostingRemoved != source.DatePostingRemoved)
            {
                target.DatePostingRemoved = source.DatePostingRemoved;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPositionTitleSupported)
                && target.PositionTitle != source.PositionTitle)
            {
                target.PositionTitle = source.PositionTitle;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPostingResultTypeSupported)
                && target.PostingResultType != source.PostingResultType)
            {
                target.PostingResultType = source.PostingResultType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsProgramAssignmentDescriptorSupported)
                && target.ProgramAssignmentDescriptor != source.ProgramAssignmentDescriptor)
            {
                target.ProgramAssignmentDescriptor = source.ProgramAssignmentDescriptor;
                isModified = true;
            }



            // Sync lists
            if (sourceSupport == null || sourceSupport.IsOpenStaffPositionAcademicSubjectsSupported)
                isModified |= source.OpenStaffPositionAcademicSubjects.SynchronizeListTo(target.OpenStaffPositionAcademicSubjects, child => child.OpenStaffPosition = target,
                                sourceSupport == null ? null : sourceSupport.IsOpenStaffPositionAcademicSubjectIncluded);

            if (sourceSupport == null || sourceSupport.IsOpenStaffPositionInstructionalGradeLevelsSupported)
                isModified |= source.OpenStaffPositionInstructionalGradeLevels.SynchronizeListTo(target.OpenStaffPositionInstructionalGradeLevels, child => child.OpenStaffPosition = target,
                                sourceSupport == null ? null : sourceSupport.IsOpenStaffPositionInstructionalGradeLevelIncluded);


            return isModified;
        }



        public static void MapTo(this IOpenStaffPosition source, IOpenStaffPosition target, Action<IOpenStaffPosition, IOpenStaffPosition> onMapped)
        {
            var sourceSynchSupport = source as IOpenStaffPositionSynchronizationSourceSupport;
            var targetSynchSupport = target as IOpenStaffPositionSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.DatePosted = source.DatePosted;
            target.EducationOrganizationId = source.EducationOrganizationId;
            target.EmploymentStatusDescriptor = source.EmploymentStatusDescriptor;
            target.RequisitionNumber = source.RequisitionNumber;
            target.StaffClassificationDescriptor = source.StaffClassificationDescriptor;

            // Copy non-PK properties

            if (sourceSynchSupport.IsDatePostingRemovedSupported)
                target.DatePostingRemoved = source.DatePostingRemoved;
            else
                targetSynchSupport.IsDatePostingRemovedSupported = false;

            if (sourceSynchSupport.IsPositionTitleSupported)
                target.PositionTitle = source.PositionTitle;
            else
                targetSynchSupport.IsPositionTitleSupported = false;

            if (sourceSynchSupport.IsPostingResultTypeSupported)
                target.PostingResultType = source.PostingResultType;
            else
                targetSynchSupport.IsPostingResultTypeSupported = false;

            if (sourceSynchSupport.IsProgramAssignmentDescriptorSupported)
                target.ProgramAssignmentDescriptor = source.ProgramAssignmentDescriptor;
            else
                targetSynchSupport.IsProgramAssignmentDescriptorSupported = false;

            // Map lists

            if (sourceSynchSupport.IsOpenStaffPositionAcademicSubjectsSupported)
            {    
                targetSynchSupport.IsOpenStaffPositionAcademicSubjectIncluded = sourceSynchSupport.IsOpenStaffPositionAcademicSubjectIncluded;
                source.OpenStaffPositionAcademicSubjects.MapListTo(target.OpenStaffPositionAcademicSubjects);
            }
            else
            {
                targetSynchSupport.IsOpenStaffPositionAcademicSubjectsSupported = false;
            }

            if (sourceSynchSupport.IsOpenStaffPositionInstructionalGradeLevelsSupported)
            {    
                targetSynchSupport.IsOpenStaffPositionInstructionalGradeLevelIncluded = sourceSynchSupport.IsOpenStaffPositionInstructionalGradeLevelIncluded;
                source.OpenStaffPositionInstructionalGradeLevels.MapListTo(target.OpenStaffPositionInstructionalGradeLevels);
            }
            else
            {
                targetSynchSupport.IsOpenStaffPositionInstructionalGradeLevelsSupported = false;
            }

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IOpenStaffPositionSynchronizationSourceSupport
    {
        bool IsDatePostingRemovedSupported { get; set; }
        bool IsOpenStaffPositionAcademicSubjectsSupported { get; set; }
        bool IsOpenStaffPositionInstructionalGradeLevelsSupported { get; set; }
        bool IsPositionTitleSupported { get; set; }
        bool IsPostingResultTypeSupported { get; set; }
        bool IsProgramAssignmentDescriptorSupported { get; set; }
        Func<IOpenStaffPositionAcademicSubject, bool> IsOpenStaffPositionAcademicSubjectIncluded { get; set; }
        Func<IOpenStaffPositionInstructionalGradeLevel, bool> IsOpenStaffPositionInstructionalGradeLevelIncluded { get; set; }
    }
 
    public static class OpenStaffPositionAcademicSubjectMapper 
    {
        public static bool SynchronizeTo(this IOpenStaffPositionAcademicSubject source, IOpenStaffPositionAcademicSubject target)
        {
            bool isModified = false;

            var sourceSupport = source as IOpenStaffPositionAcademicSubjectSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AcademicSubjectDescriptor != target.AcademicSubjectDescriptor)
            {
                source.AcademicSubjectDescriptor = target.AcademicSubjectDescriptor;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IOpenStaffPositionAcademicSubject source, IOpenStaffPositionAcademicSubject target, Action<IOpenStaffPositionAcademicSubject, IOpenStaffPositionAcademicSubject> onMapped)
        {
            var sourceSynchSupport = source as IOpenStaffPositionAcademicSubjectSynchronizationSourceSupport;
            var targetSynchSupport = target as IOpenStaffPositionAcademicSubjectSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.AcademicSubjectDescriptor = source.AcademicSubjectDescriptor;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IOpenStaffPositionAcademicSubjectSynchronizationSourceSupport
    {
    }
 
    public static class OpenStaffPositionInstructionalGradeLevelMapper 
    {
        public static bool SynchronizeTo(this IOpenStaffPositionInstructionalGradeLevel source, IOpenStaffPositionInstructionalGradeLevel target)
        {
            bool isModified = false;

            var sourceSupport = source as IOpenStaffPositionInstructionalGradeLevelSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.GradeLevelDescriptor != target.GradeLevelDescriptor)
            {
                source.GradeLevelDescriptor = target.GradeLevelDescriptor;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IOpenStaffPositionInstructionalGradeLevel source, IOpenStaffPositionInstructionalGradeLevel target, Action<IOpenStaffPositionInstructionalGradeLevel, IOpenStaffPositionInstructionalGradeLevel> onMapped)
        {
            var sourceSynchSupport = source as IOpenStaffPositionInstructionalGradeLevelSynchronizationSourceSupport;
            var targetSynchSupport = target as IOpenStaffPositionInstructionalGradeLevelSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.GradeLevelDescriptor = source.GradeLevelDescriptor;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IOpenStaffPositionInstructionalGradeLevelSynchronizationSourceSupport
    {
    }
 
}
// Aggregate: OperationalStatusType

namespace EdFi.Ods.Entities.Common //.OperationalStatusTypeAggregate
{ 
    public static class OperationalStatusTypeMapper 
    {
        public static bool SynchronizeTo(this IOperationalStatusType source, IOperationalStatusType target)
        {
            bool isModified = false;

            var sourceSupport = source as IOperationalStatusTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.OperationalStatusTypeId != target.OperationalStatusTypeId)
            {
                source.OperationalStatusTypeId = target.OperationalStatusTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IOperationalStatusType source, IOperationalStatusType target, Action<IOperationalStatusType, IOperationalStatusType> onMapped)
        {
            var sourceSynchSupport = source as IOperationalStatusTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IOperationalStatusTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.OperationalStatusTypeId = source.OperationalStatusTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IOperationalStatusTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: OtherNameType

namespace EdFi.Ods.Entities.Common //.OtherNameTypeAggregate
{ 
    public static class OtherNameTypeMapper 
    {
        public static bool SynchronizeTo(this IOtherNameType source, IOtherNameType target)
        {
            bool isModified = false;

            var sourceSupport = source as IOtherNameTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.OtherNameTypeId != target.OtherNameTypeId)
            {
                source.OtherNameTypeId = target.OtherNameTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IOtherNameType source, IOtherNameType target, Action<IOtherNameType, IOtherNameType> onMapped)
        {
            var sourceSynchSupport = source as IOtherNameTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IOtherNameTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.OtherNameTypeId = source.OtherNameTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IOtherNameTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: Parent

namespace EdFi.Ods.Entities.Common //.ParentAggregate
{ 
    public static class ParentMapper 
    {
        public static bool SynchronizeTo(this IParent source, IParent target)
        {
            bool isModified = false;

            var sourceSupport = source as IParentSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsFirstNameSupported)
                && target.FirstName != source.FirstName)
            {
                target.FirstName = source.FirstName;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsGenerationCodeSuffixSupported)
                && target.GenerationCodeSuffix != source.GenerationCodeSuffix)
            {
                target.GenerationCodeSuffix = source.GenerationCodeSuffix;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsLastSurnameSupported)
                && target.LastSurname != source.LastSurname)
            {
                target.LastSurname = source.LastSurname;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsLoginIdSupported)
                && target.LoginId != source.LoginId)
            {
                target.LoginId = source.LoginId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsMaidenNameSupported)
                && target.MaidenName != source.MaidenName)
            {
                target.MaidenName = source.MaidenName;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsMiddleNameSupported)
                && target.MiddleName != source.MiddleName)
            {
                target.MiddleName = source.MiddleName;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsParentUniqueIdSupported)
                && target.ParentUniqueId != source.ParentUniqueId)
            {
                target.ParentUniqueId = source.ParentUniqueId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPersonalTitlePrefixSupported)
                && target.PersonalTitlePrefix != source.PersonalTitlePrefix)
            {
                target.PersonalTitlePrefix = source.PersonalTitlePrefix;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsSexTypeSupported)
                && target.SexType != source.SexType)
            {
                target.SexType = source.SexType;
                isModified = true;
            }



            // Sync lists
            if (sourceSupport == null || sourceSupport.IsParentAddressesSupported)
                isModified |= source.ParentAddresses.SynchronizeListTo(target.ParentAddresses, child => child.Parent = target,
                                sourceSupport == null ? null : sourceSupport.IsParentAddressIncluded);

            if (sourceSupport == null || sourceSupport.IsParentElectronicMailsSupported)
                isModified |= source.ParentElectronicMails.SynchronizeListTo(target.ParentElectronicMails, child => child.Parent = target,
                                sourceSupport == null ? null : sourceSupport.IsParentElectronicMailIncluded);

            if (sourceSupport == null || sourceSupport.IsParentIdentificationDocumentsSupported)
                isModified |= source.ParentIdentificationDocuments.SynchronizeListTo(target.ParentIdentificationDocuments, child => child.Parent = target,
                                sourceSupport == null ? null : sourceSupport.IsParentIdentificationDocumentIncluded);

            if (sourceSupport == null || sourceSupport.IsParentInternationalAddressesSupported)
                isModified |= source.ParentInternationalAddresses.SynchronizeListTo(target.ParentInternationalAddresses, child => child.Parent = target,
                                sourceSupport == null ? null : sourceSupport.IsParentInternationalAddressIncluded);

            if (sourceSupport == null || sourceSupport.IsParentOtherNamesSupported)
                isModified |= source.ParentOtherNames.SynchronizeListTo(target.ParentOtherNames, child => child.Parent = target,
                                sourceSupport == null ? null : sourceSupport.IsParentOtherNameIncluded);

            if (sourceSupport == null || sourceSupport.IsParentTelephonesSupported)
                isModified |= source.ParentTelephones.SynchronizeListTo(target.ParentTelephones, child => child.Parent = target,
                                sourceSupport == null ? null : sourceSupport.IsParentTelephoneIncluded);


            return isModified;
        }



        public static void MapTo(this IParent source, IParent target, Action<IParent, IParent> onMapped)
        {
            var sourceSynchSupport = source as IParentSynchronizationSourceSupport;
            var targetSynchSupport = target as IParentSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.ParentUniqueId = source.ParentUniqueId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsFirstNameSupported)
                target.FirstName = source.FirstName;
            else
                targetSynchSupport.IsFirstNameSupported = false;

            if (sourceSynchSupport.IsGenerationCodeSuffixSupported)
                target.GenerationCodeSuffix = source.GenerationCodeSuffix;
            else
                targetSynchSupport.IsGenerationCodeSuffixSupported = false;

            if (sourceSynchSupport.IsLastSurnameSupported)
                target.LastSurname = source.LastSurname;
            else
                targetSynchSupport.IsLastSurnameSupported = false;

            if (sourceSynchSupport.IsLoginIdSupported)
                target.LoginId = source.LoginId;
            else
                targetSynchSupport.IsLoginIdSupported = false;

            if (sourceSynchSupport.IsMaidenNameSupported)
                target.MaidenName = source.MaidenName;
            else
                targetSynchSupport.IsMaidenNameSupported = false;

            if (sourceSynchSupport.IsMiddleNameSupported)
                target.MiddleName = source.MiddleName;
            else
                targetSynchSupport.IsMiddleNameSupported = false;

            if (sourceSynchSupport.IsParentUniqueIdSupported)
                target.ParentUniqueId = source.ParentUniqueId;
            else
                targetSynchSupport.IsParentUniqueIdSupported = false;

            if (sourceSynchSupport.IsPersonalTitlePrefixSupported)
                target.PersonalTitlePrefix = source.PersonalTitlePrefix;
            else
                targetSynchSupport.IsPersonalTitlePrefixSupported = false;

            if (sourceSynchSupport.IsSexTypeSupported)
                target.SexType = source.SexType;
            else
                targetSynchSupport.IsSexTypeSupported = false;

            // Map lists

            if (sourceSynchSupport.IsParentAddressesSupported)
            {    
                targetSynchSupport.IsParentAddressIncluded = sourceSynchSupport.IsParentAddressIncluded;
                source.ParentAddresses.MapListTo(target.ParentAddresses);
            }
            else
            {
                targetSynchSupport.IsParentAddressesSupported = false;
            }

            if (sourceSynchSupport.IsParentElectronicMailsSupported)
            {    
                targetSynchSupport.IsParentElectronicMailIncluded = sourceSynchSupport.IsParentElectronicMailIncluded;
                source.ParentElectronicMails.MapListTo(target.ParentElectronicMails);
            }
            else
            {
                targetSynchSupport.IsParentElectronicMailsSupported = false;
            }

            if (sourceSynchSupport.IsParentIdentificationDocumentsSupported)
            {    
                targetSynchSupport.IsParentIdentificationDocumentIncluded = sourceSynchSupport.IsParentIdentificationDocumentIncluded;
                source.ParentIdentificationDocuments.MapListTo(target.ParentIdentificationDocuments);
            }
            else
            {
                targetSynchSupport.IsParentIdentificationDocumentsSupported = false;
            }

            if (sourceSynchSupport.IsParentInternationalAddressesSupported)
            {    
                targetSynchSupport.IsParentInternationalAddressIncluded = sourceSynchSupport.IsParentInternationalAddressIncluded;
                source.ParentInternationalAddresses.MapListTo(target.ParentInternationalAddresses);
            }
            else
            {
                targetSynchSupport.IsParentInternationalAddressesSupported = false;
            }

            if (sourceSynchSupport.IsParentOtherNamesSupported)
            {    
                targetSynchSupport.IsParentOtherNameIncluded = sourceSynchSupport.IsParentOtherNameIncluded;
                source.ParentOtherNames.MapListTo(target.ParentOtherNames);
            }
            else
            {
                targetSynchSupport.IsParentOtherNamesSupported = false;
            }

            if (sourceSynchSupport.IsParentTelephonesSupported)
            {    
                targetSynchSupport.IsParentTelephoneIncluded = sourceSynchSupport.IsParentTelephoneIncluded;
                source.ParentTelephones.MapListTo(target.ParentTelephones);
            }
            else
            {
                targetSynchSupport.IsParentTelephonesSupported = false;
            }

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IParentSynchronizationSourceSupport
    {
        bool IsFirstNameSupported { get; set; }
        bool IsGenerationCodeSuffixSupported { get; set; }
        bool IsLastSurnameSupported { get; set; }
        bool IsLoginIdSupported { get; set; }
        bool IsMaidenNameSupported { get; set; }
        bool IsMiddleNameSupported { get; set; }
        bool IsParentAddressesSupported { get; set; }
        bool IsParentElectronicMailsSupported { get; set; }
        bool IsParentIdentificationDocumentsSupported { get; set; }
        bool IsParentInternationalAddressesSupported { get; set; }
        bool IsParentOtherNamesSupported { get; set; }
        bool IsParentTelephonesSupported { get; set; }
        bool IsParentUniqueIdSupported { get; set; }
        bool IsPersonalTitlePrefixSupported { get; set; }
        bool IsSexTypeSupported { get; set; }
        Func<IParentAddress, bool> IsParentAddressIncluded { get; set; }
        Func<IParentElectronicMail, bool> IsParentElectronicMailIncluded { get; set; }
        Func<IParentIdentificationDocument, bool> IsParentIdentificationDocumentIncluded { get; set; }
        Func<IParentInternationalAddress, bool> IsParentInternationalAddressIncluded { get; set; }
        Func<IParentOtherName, bool> IsParentOtherNameIncluded { get; set; }
        Func<IParentTelephone, bool> IsParentTelephoneIncluded { get; set; }
    }
 
    public static class ParentAddressMapper 
    {
        public static bool SynchronizeTo(this IParentAddress source, IParentAddress target)
        {
            bool isModified = false;

            var sourceSupport = source as IParentAddressSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AddressType != target.AddressType)
            {
                source.AddressType = target.AddressType;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsApartmentRoomSuiteNumberSupported)
                && target.ApartmentRoomSuiteNumber != source.ApartmentRoomSuiteNumber)
            {
                target.ApartmentRoomSuiteNumber = source.ApartmentRoomSuiteNumber;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsBeginDateSupported)
                && target.BeginDate != source.BeginDate)
            {
                target.BeginDate = source.BeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsBuildingSiteNumberSupported)
                && target.BuildingSiteNumber != source.BuildingSiteNumber)
            {
                target.BuildingSiteNumber = source.BuildingSiteNumber;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsCitySupported)
                && target.City != source.City)
            {
                target.City = source.City;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsCountyFIPSCodeSupported)
                && target.CountyFIPSCode != source.CountyFIPSCode)
            {
                target.CountyFIPSCode = source.CountyFIPSCode;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEndDateSupported)
                && target.EndDate != source.EndDate)
            {
                target.EndDate = source.EndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsLatitudeSupported)
                && target.Latitude != source.Latitude)
            {
                target.Latitude = source.Latitude;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsLongitudeSupported)
                && target.Longitude != source.Longitude)
            {
                target.Longitude = source.Longitude;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNameOfCountySupported)
                && target.NameOfCounty != source.NameOfCounty)
            {
                target.NameOfCounty = source.NameOfCounty;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPostalCodeSupported)
                && target.PostalCode != source.PostalCode)
            {
                target.PostalCode = source.PostalCode;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsStateAbbreviationTypeSupported)
                && target.StateAbbreviationType != source.StateAbbreviationType)
            {
                target.StateAbbreviationType = source.StateAbbreviationType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsStreetNumberNameSupported)
                && target.StreetNumberName != source.StreetNumberName)
            {
                target.StreetNumberName = source.StreetNumberName;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IParentAddress source, IParentAddress target, Action<IParentAddress, IParentAddress> onMapped)
        {
            var sourceSynchSupport = source as IParentAddressSynchronizationSourceSupport;
            var targetSynchSupport = target as IParentAddressSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.AddressType = source.AddressType;

            // Copy non-PK properties

            if (sourceSynchSupport.IsApartmentRoomSuiteNumberSupported)
                target.ApartmentRoomSuiteNumber = source.ApartmentRoomSuiteNumber;
            else
                targetSynchSupport.IsApartmentRoomSuiteNumberSupported = false;

            if (sourceSynchSupport.IsBeginDateSupported)
                target.BeginDate = source.BeginDate;
            else
                targetSynchSupport.IsBeginDateSupported = false;

            if (sourceSynchSupport.IsBuildingSiteNumberSupported)
                target.BuildingSiteNumber = source.BuildingSiteNumber;
            else
                targetSynchSupport.IsBuildingSiteNumberSupported = false;

            if (sourceSynchSupport.IsCitySupported)
                target.City = source.City;
            else
                targetSynchSupport.IsCitySupported = false;

            if (sourceSynchSupport.IsCountyFIPSCodeSupported)
                target.CountyFIPSCode = source.CountyFIPSCode;
            else
                targetSynchSupport.IsCountyFIPSCodeSupported = false;

            if (sourceSynchSupport.IsEndDateSupported)
                target.EndDate = source.EndDate;
            else
                targetSynchSupport.IsEndDateSupported = false;

            if (sourceSynchSupport.IsLatitudeSupported)
                target.Latitude = source.Latitude;
            else
                targetSynchSupport.IsLatitudeSupported = false;

            if (sourceSynchSupport.IsLongitudeSupported)
                target.Longitude = source.Longitude;
            else
                targetSynchSupport.IsLongitudeSupported = false;

            if (sourceSynchSupport.IsNameOfCountySupported)
                target.NameOfCounty = source.NameOfCounty;
            else
                targetSynchSupport.IsNameOfCountySupported = false;

            if (sourceSynchSupport.IsPostalCodeSupported)
                target.PostalCode = source.PostalCode;
            else
                targetSynchSupport.IsPostalCodeSupported = false;

            if (sourceSynchSupport.IsStateAbbreviationTypeSupported)
                target.StateAbbreviationType = source.StateAbbreviationType;
            else
                targetSynchSupport.IsStateAbbreviationTypeSupported = false;

            if (sourceSynchSupport.IsStreetNumberNameSupported)
                target.StreetNumberName = source.StreetNumberName;
            else
                targetSynchSupport.IsStreetNumberNameSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IParentAddressSynchronizationSourceSupport
    {
        bool IsApartmentRoomSuiteNumberSupported { get; set; }
        bool IsBeginDateSupported { get; set; }
        bool IsBuildingSiteNumberSupported { get; set; }
        bool IsCitySupported { get; set; }
        bool IsCountyFIPSCodeSupported { get; set; }
        bool IsEndDateSupported { get; set; }
        bool IsLatitudeSupported { get; set; }
        bool IsLongitudeSupported { get; set; }
        bool IsNameOfCountySupported { get; set; }
        bool IsPostalCodeSupported { get; set; }
        bool IsStateAbbreviationTypeSupported { get; set; }
        bool IsStreetNumberNameSupported { get; set; }
    }
 
    public static class ParentElectronicMailMapper 
    {
        public static bool SynchronizeTo(this IParentElectronicMail source, IParentElectronicMail target)
        {
            bool isModified = false;

            var sourceSupport = source as IParentElectronicMailSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.ElectronicMailType != target.ElectronicMailType)
            {
                source.ElectronicMailType = target.ElectronicMailType;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsElectronicMailAddressSupported)
                && target.ElectronicMailAddress != source.ElectronicMailAddress)
            {
                target.ElectronicMailAddress = source.ElectronicMailAddress;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPrimaryEmailAddressIndicatorSupported)
                && target.PrimaryEmailAddressIndicator != source.PrimaryEmailAddressIndicator)
            {
                target.PrimaryEmailAddressIndicator = source.PrimaryEmailAddressIndicator;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IParentElectronicMail source, IParentElectronicMail target, Action<IParentElectronicMail, IParentElectronicMail> onMapped)
        {
            var sourceSynchSupport = source as IParentElectronicMailSynchronizationSourceSupport;
            var targetSynchSupport = target as IParentElectronicMailSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.ElectronicMailType = source.ElectronicMailType;

            // Copy non-PK properties

            if (sourceSynchSupport.IsElectronicMailAddressSupported)
                target.ElectronicMailAddress = source.ElectronicMailAddress;
            else
                targetSynchSupport.IsElectronicMailAddressSupported = false;

            if (sourceSynchSupport.IsPrimaryEmailAddressIndicatorSupported)
                target.PrimaryEmailAddressIndicator = source.PrimaryEmailAddressIndicator;
            else
                targetSynchSupport.IsPrimaryEmailAddressIndicatorSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IParentElectronicMailSynchronizationSourceSupport
    {
        bool IsElectronicMailAddressSupported { get; set; }
        bool IsPrimaryEmailAddressIndicatorSupported { get; set; }
    }
 
    public static class ParentIdentificationDocumentMapper 
    {
        public static bool SynchronizeTo(this IParentIdentificationDocument source, IParentIdentificationDocument target)
        {
            bool isModified = false;

            var sourceSupport = source as IParentIdentificationDocumentSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.IdentificationDocumentUseType != target.IdentificationDocumentUseType)
            {
                source.IdentificationDocumentUseType = target.IdentificationDocumentUseType;
            }
            if (source.PersonalInformationVerificationType != target.PersonalInformationVerificationType)
            {
                source.PersonalInformationVerificationType = target.PersonalInformationVerificationType;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsDocumentExpirationDateSupported)
                && target.DocumentExpirationDate != source.DocumentExpirationDate)
            {
                target.DocumentExpirationDate = source.DocumentExpirationDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDocumentTitleSupported)
                && target.DocumentTitle != source.DocumentTitle)
            {
                target.DocumentTitle = source.DocumentTitle;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsIssuerCountryDescriptorSupported)
                && target.IssuerCountryDescriptor != source.IssuerCountryDescriptor)
            {
                target.IssuerCountryDescriptor = source.IssuerCountryDescriptor;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsIssuerDocumentIdentificationCodeSupported)
                && target.IssuerDocumentIdentificationCode != source.IssuerDocumentIdentificationCode)
            {
                target.IssuerDocumentIdentificationCode = source.IssuerDocumentIdentificationCode;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsIssuerNameSupported)
                && target.IssuerName != source.IssuerName)
            {
                target.IssuerName = source.IssuerName;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IParentIdentificationDocument source, IParentIdentificationDocument target, Action<IParentIdentificationDocument, IParentIdentificationDocument> onMapped)
        {
            var sourceSynchSupport = source as IParentIdentificationDocumentSynchronizationSourceSupport;
            var targetSynchSupport = target as IParentIdentificationDocumentSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.IdentificationDocumentUseType = source.IdentificationDocumentUseType;
            target.PersonalInformationVerificationType = source.PersonalInformationVerificationType;

            // Copy non-PK properties

            if (sourceSynchSupport.IsDocumentExpirationDateSupported)
                target.DocumentExpirationDate = source.DocumentExpirationDate;
            else
                targetSynchSupport.IsDocumentExpirationDateSupported = false;

            if (sourceSynchSupport.IsDocumentTitleSupported)
                target.DocumentTitle = source.DocumentTitle;
            else
                targetSynchSupport.IsDocumentTitleSupported = false;

            if (sourceSynchSupport.IsIssuerCountryDescriptorSupported)
                target.IssuerCountryDescriptor = source.IssuerCountryDescriptor;
            else
                targetSynchSupport.IsIssuerCountryDescriptorSupported = false;

            if (sourceSynchSupport.IsIssuerDocumentIdentificationCodeSupported)
                target.IssuerDocumentIdentificationCode = source.IssuerDocumentIdentificationCode;
            else
                targetSynchSupport.IsIssuerDocumentIdentificationCodeSupported = false;

            if (sourceSynchSupport.IsIssuerNameSupported)
                target.IssuerName = source.IssuerName;
            else
                targetSynchSupport.IsIssuerNameSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IParentIdentificationDocumentSynchronizationSourceSupport
    {
        bool IsDocumentExpirationDateSupported { get; set; }
        bool IsDocumentTitleSupported { get; set; }
        bool IsIssuerCountryDescriptorSupported { get; set; }
        bool IsIssuerDocumentIdentificationCodeSupported { get; set; }
        bool IsIssuerNameSupported { get; set; }
    }
 
    public static class ParentInternationalAddressMapper 
    {
        public static bool SynchronizeTo(this IParentInternationalAddress source, IParentInternationalAddress target)
        {
            bool isModified = false;

            var sourceSupport = source as IParentInternationalAddressSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AddressType != target.AddressType)
            {
                source.AddressType = target.AddressType;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsAddressLine1Supported)
                && target.AddressLine1 != source.AddressLine1)
            {
                target.AddressLine1 = source.AddressLine1;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsAddressLine2Supported)
                && target.AddressLine2 != source.AddressLine2)
            {
                target.AddressLine2 = source.AddressLine2;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsAddressLine3Supported)
                && target.AddressLine3 != source.AddressLine3)
            {
                target.AddressLine3 = source.AddressLine3;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsAddressLine4Supported)
                && target.AddressLine4 != source.AddressLine4)
            {
                target.AddressLine4 = source.AddressLine4;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsBeginDateSupported)
                && target.BeginDate != source.BeginDate)
            {
                target.BeginDate = source.BeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsCountryDescriptorSupported)
                && target.CountryDescriptor != source.CountryDescriptor)
            {
                target.CountryDescriptor = source.CountryDescriptor;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEndDateSupported)
                && target.EndDate != source.EndDate)
            {
                target.EndDate = source.EndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsLatitudeSupported)
                && target.Latitude != source.Latitude)
            {
                target.Latitude = source.Latitude;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsLongitudeSupported)
                && target.Longitude != source.Longitude)
            {
                target.Longitude = source.Longitude;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IParentInternationalAddress source, IParentInternationalAddress target, Action<IParentInternationalAddress, IParentInternationalAddress> onMapped)
        {
            var sourceSynchSupport = source as IParentInternationalAddressSynchronizationSourceSupport;
            var targetSynchSupport = target as IParentInternationalAddressSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.AddressType = source.AddressType;

            // Copy non-PK properties

            if (sourceSynchSupport.IsAddressLine1Supported)
                target.AddressLine1 = source.AddressLine1;
            else
                targetSynchSupport.IsAddressLine1Supported = false;

            if (sourceSynchSupport.IsAddressLine2Supported)
                target.AddressLine2 = source.AddressLine2;
            else
                targetSynchSupport.IsAddressLine2Supported = false;

            if (sourceSynchSupport.IsAddressLine3Supported)
                target.AddressLine3 = source.AddressLine3;
            else
                targetSynchSupport.IsAddressLine3Supported = false;

            if (sourceSynchSupport.IsAddressLine4Supported)
                target.AddressLine4 = source.AddressLine4;
            else
                targetSynchSupport.IsAddressLine4Supported = false;

            if (sourceSynchSupport.IsBeginDateSupported)
                target.BeginDate = source.BeginDate;
            else
                targetSynchSupport.IsBeginDateSupported = false;

            if (sourceSynchSupport.IsCountryDescriptorSupported)
                target.CountryDescriptor = source.CountryDescriptor;
            else
                targetSynchSupport.IsCountryDescriptorSupported = false;

            if (sourceSynchSupport.IsEndDateSupported)
                target.EndDate = source.EndDate;
            else
                targetSynchSupport.IsEndDateSupported = false;

            if (sourceSynchSupport.IsLatitudeSupported)
                target.Latitude = source.Latitude;
            else
                targetSynchSupport.IsLatitudeSupported = false;

            if (sourceSynchSupport.IsLongitudeSupported)
                target.Longitude = source.Longitude;
            else
                targetSynchSupport.IsLongitudeSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IParentInternationalAddressSynchronizationSourceSupport
    {
        bool IsAddressLine1Supported { get; set; }
        bool IsAddressLine2Supported { get; set; }
        bool IsAddressLine3Supported { get; set; }
        bool IsAddressLine4Supported { get; set; }
        bool IsBeginDateSupported { get; set; }
        bool IsCountryDescriptorSupported { get; set; }
        bool IsEndDateSupported { get; set; }
        bool IsLatitudeSupported { get; set; }
        bool IsLongitudeSupported { get; set; }
    }
 
    public static class ParentOtherNameMapper 
    {
        public static bool SynchronizeTo(this IParentOtherName source, IParentOtherName target)
        {
            bool isModified = false;

            var sourceSupport = source as IParentOtherNameSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.OtherNameType != target.OtherNameType)
            {
                source.OtherNameType = target.OtherNameType;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsFirstNameSupported)
                && target.FirstName != source.FirstName)
            {
                target.FirstName = source.FirstName;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsGenerationCodeSuffixSupported)
                && target.GenerationCodeSuffix != source.GenerationCodeSuffix)
            {
                target.GenerationCodeSuffix = source.GenerationCodeSuffix;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsLastSurnameSupported)
                && target.LastSurname != source.LastSurname)
            {
                target.LastSurname = source.LastSurname;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsMiddleNameSupported)
                && target.MiddleName != source.MiddleName)
            {
                target.MiddleName = source.MiddleName;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPersonalTitlePrefixSupported)
                && target.PersonalTitlePrefix != source.PersonalTitlePrefix)
            {
                target.PersonalTitlePrefix = source.PersonalTitlePrefix;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IParentOtherName source, IParentOtherName target, Action<IParentOtherName, IParentOtherName> onMapped)
        {
            var sourceSynchSupport = source as IParentOtherNameSynchronizationSourceSupport;
            var targetSynchSupport = target as IParentOtherNameSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.OtherNameType = source.OtherNameType;

            // Copy non-PK properties

            if (sourceSynchSupport.IsFirstNameSupported)
                target.FirstName = source.FirstName;
            else
                targetSynchSupport.IsFirstNameSupported = false;

            if (sourceSynchSupport.IsGenerationCodeSuffixSupported)
                target.GenerationCodeSuffix = source.GenerationCodeSuffix;
            else
                targetSynchSupport.IsGenerationCodeSuffixSupported = false;

            if (sourceSynchSupport.IsLastSurnameSupported)
                target.LastSurname = source.LastSurname;
            else
                targetSynchSupport.IsLastSurnameSupported = false;

            if (sourceSynchSupport.IsMiddleNameSupported)
                target.MiddleName = source.MiddleName;
            else
                targetSynchSupport.IsMiddleNameSupported = false;

            if (sourceSynchSupport.IsPersonalTitlePrefixSupported)
                target.PersonalTitlePrefix = source.PersonalTitlePrefix;
            else
                targetSynchSupport.IsPersonalTitlePrefixSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IParentOtherNameSynchronizationSourceSupport
    {
        bool IsFirstNameSupported { get; set; }
        bool IsGenerationCodeSuffixSupported { get; set; }
        bool IsLastSurnameSupported { get; set; }
        bool IsMiddleNameSupported { get; set; }
        bool IsPersonalTitlePrefixSupported { get; set; }
    }
 
    public static class ParentTelephoneMapper 
    {
        public static bool SynchronizeTo(this IParentTelephone source, IParentTelephone target)
        {
            bool isModified = false;

            var sourceSupport = source as IParentTelephoneSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.TelephoneNumberType != target.TelephoneNumberType)
            {
                source.TelephoneNumberType = target.TelephoneNumberType;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsOrderOfPrioritySupported)
                && target.OrderOfPriority != source.OrderOfPriority)
            {
                target.OrderOfPriority = source.OrderOfPriority;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsTelephoneNumberSupported)
                && target.TelephoneNumber != source.TelephoneNumber)
            {
                target.TelephoneNumber = source.TelephoneNumber;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsTextMessageCapabilityIndicatorSupported)
                && target.TextMessageCapabilityIndicator != source.TextMessageCapabilityIndicator)
            {
                target.TextMessageCapabilityIndicator = source.TextMessageCapabilityIndicator;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IParentTelephone source, IParentTelephone target, Action<IParentTelephone, IParentTelephone> onMapped)
        {
            var sourceSynchSupport = source as IParentTelephoneSynchronizationSourceSupport;
            var targetSynchSupport = target as IParentTelephoneSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.TelephoneNumberType = source.TelephoneNumberType;

            // Copy non-PK properties

            if (sourceSynchSupport.IsOrderOfPrioritySupported)
                target.OrderOfPriority = source.OrderOfPriority;
            else
                targetSynchSupport.IsOrderOfPrioritySupported = false;

            if (sourceSynchSupport.IsTelephoneNumberSupported)
                target.TelephoneNumber = source.TelephoneNumber;
            else
                targetSynchSupport.IsTelephoneNumberSupported = false;

            if (sourceSynchSupport.IsTextMessageCapabilityIndicatorSupported)
                target.TextMessageCapabilityIndicator = source.TextMessageCapabilityIndicator;
            else
                targetSynchSupport.IsTextMessageCapabilityIndicatorSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IParentTelephoneSynchronizationSourceSupport
    {
        bool IsOrderOfPrioritySupported { get; set; }
        bool IsTelephoneNumberSupported { get; set; }
        bool IsTextMessageCapabilityIndicatorSupported { get; set; }
    }
 
}
// Aggregate: Payroll

namespace EdFi.Ods.Entities.Common //.PayrollAggregate
{ 
    public static class PayrollMapper 
    {
        public static bool SynchronizeTo(this IPayroll source, IPayroll target)
        {
            bool isModified = false;

            var sourceSupport = source as IPayrollSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AccountNumber != target.AccountNumber)
            {
                source.AccountNumber = target.AccountNumber;
            }
            if (source.AsOfDate != target.AsOfDate)
            {
                source.AsOfDate = target.AsOfDate;
            }
            if (source.EducationOrganizationId != target.EducationOrganizationId)
            {
                source.EducationOrganizationId = target.EducationOrganizationId;
            }
            if (source.FiscalYear != target.FiscalYear)
            {
                source.FiscalYear = target.FiscalYear;
            }
            if (source.StaffUniqueId != target.StaffUniqueId)
            {
                source.StaffUniqueId = target.StaffUniqueId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsAmountToDateSupported)
                && target.AmountToDate != source.AmountToDate)
            {
                target.AmountToDate = source.AmountToDate;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IPayroll source, IPayroll target, Action<IPayroll, IPayroll> onMapped)
        {
            var sourceSynchSupport = source as IPayrollSynchronizationSourceSupport;
            var targetSynchSupport = target as IPayrollSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.AccountNumber = source.AccountNumber;
            target.AsOfDate = source.AsOfDate;
            target.EducationOrganizationId = source.EducationOrganizationId;
            target.FiscalYear = source.FiscalYear;
            target.StaffUniqueId = source.StaffUniqueId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsAmountToDateSupported)
                target.AmountToDate = source.AmountToDate;
            else
                targetSynchSupport.IsAmountToDateSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IPayrollSynchronizationSourceSupport
    {
        bool IsAmountToDateSupported { get; set; }
    }
 
}
// Aggregate: PerformanceBaseConversionType

namespace EdFi.Ods.Entities.Common //.PerformanceBaseConversionTypeAggregate
{ 
    public static class PerformanceBaseConversionTypeMapper 
    {
        public static bool SynchronizeTo(this IPerformanceBaseConversionType source, IPerformanceBaseConversionType target)
        {
            bool isModified = false;

            var sourceSupport = source as IPerformanceBaseConversionTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.PerformanceBaseConversionTypeId != target.PerformanceBaseConversionTypeId)
            {
                source.PerformanceBaseConversionTypeId = target.PerformanceBaseConversionTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IPerformanceBaseConversionType source, IPerformanceBaseConversionType target, Action<IPerformanceBaseConversionType, IPerformanceBaseConversionType> onMapped)
        {
            var sourceSynchSupport = source as IPerformanceBaseConversionTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IPerformanceBaseConversionTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.PerformanceBaseConversionTypeId = source.PerformanceBaseConversionTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IPerformanceBaseConversionTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: PerformanceLevelDescriptor

namespace EdFi.Ods.Entities.Common //.PerformanceLevelDescriptorAggregate
{ 
    public static class PerformanceLevelDescriptorMapper 
    {
        public static bool SynchronizeTo(this IPerformanceLevelDescriptor source, IPerformanceLevelDescriptor target)
        {
            bool isModified = false;

            var sourceSupport = source as IPerformanceLevelDescriptorSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.PerformanceLevelDescriptorId != target.PerformanceLevelDescriptorId)
            {
                source.PerformanceLevelDescriptorId = target.PerformanceLevelDescriptorId;
            }

            // Copy inherited non-PK properties


            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveBeginDateSupported)
                && target.EffectiveBeginDate != source.EffectiveBeginDate)
            {
                target.EffectiveBeginDate = source.EffectiveBeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveEndDateSupported)
                && target.EffectiveEndDate != source.EffectiveEndDate)
            {
                target.EffectiveEndDate = source.EffectiveEndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNamespaceSupported)
                && target.Namespace != source.Namespace)
            {
                target.Namespace = source.Namespace;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPriorDescriptorIdSupported)
                && target.PriorDescriptorId != source.PriorDescriptorId)
            {
                target.PriorDescriptorId = source.PriorDescriptorId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsPerformanceBaseConversionTypeSupported)
                && target.PerformanceBaseConversionType != source.PerformanceBaseConversionType)
            {
                target.PerformanceBaseConversionType = source.PerformanceBaseConversionType;
                isModified = true;
            }

            // Synch inherited lists


            // Sync lists

            return isModified;
        }



        public static void MapTo(this IPerformanceLevelDescriptor source, IPerformanceLevelDescriptor target, Action<IPerformanceLevelDescriptor, IPerformanceLevelDescriptor> onMapped)
        {
            var sourceSynchSupport = source as IPerformanceLevelDescriptorSynchronizationSourceSupport;
            var targetSynchSupport = target as IPerformanceLevelDescriptorSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.PerformanceLevelDescriptorId = source.PerformanceLevelDescriptorId;

            // Copy inherited non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsEffectiveBeginDateSupported)
                target.EffectiveBeginDate = source.EffectiveBeginDate;
            else
                targetSynchSupport.IsEffectiveBeginDateSupported = false;

            if (sourceSynchSupport.IsEffectiveEndDateSupported)
                target.EffectiveEndDate = source.EffectiveEndDate;
            else
                targetSynchSupport.IsEffectiveEndDateSupported = false;

            if (sourceSynchSupport.IsNamespaceSupported)
                target.Namespace = source.Namespace;
            else
                targetSynchSupport.IsNamespaceSupported = false;

            if (sourceSynchSupport.IsPriorDescriptorIdSupported)
                target.PriorDescriptorId = source.PriorDescriptorId;
            else
                targetSynchSupport.IsPriorDescriptorIdSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Copy non-PK properties

            if (sourceSynchSupport.IsPerformanceBaseConversionTypeSupported)
                target.PerformanceBaseConversionType = source.PerformanceBaseConversionType;
            else
                targetSynchSupport.IsPerformanceBaseConversionTypeSupported = false;

            // Map inherited lists

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IPerformanceLevelDescriptorSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsEffectiveBeginDateSupported { get; set; }
        bool IsEffectiveEndDateSupported { get; set; }
        bool IsNamespaceSupported { get; set; }
        bool IsPerformanceBaseConversionTypeSupported { get; set; }
        bool IsPriorDescriptorIdSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: PersonalInformationVerificationType

namespace EdFi.Ods.Entities.Common //.PersonalInformationVerificationTypeAggregate
{ 
    public static class PersonalInformationVerificationTypeMapper 
    {
        public static bool SynchronizeTo(this IPersonalInformationVerificationType source, IPersonalInformationVerificationType target)
        {
            bool isModified = false;

            var sourceSupport = source as IPersonalInformationVerificationTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.PersonalInformationVerificationTypeId != target.PersonalInformationVerificationTypeId)
            {
                source.PersonalInformationVerificationTypeId = target.PersonalInformationVerificationTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IPersonalInformationVerificationType source, IPersonalInformationVerificationType target, Action<IPersonalInformationVerificationType, IPersonalInformationVerificationType> onMapped)
        {
            var sourceSynchSupport = source as IPersonalInformationVerificationTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IPersonalInformationVerificationTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.PersonalInformationVerificationTypeId = source.PersonalInformationVerificationTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IPersonalInformationVerificationTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: PopulationServedType

namespace EdFi.Ods.Entities.Common //.PopulationServedTypeAggregate
{ 
    public static class PopulationServedTypeMapper 
    {
        public static bool SynchronizeTo(this IPopulationServedType source, IPopulationServedType target)
        {
            bool isModified = false;

            var sourceSupport = source as IPopulationServedTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.PopulationServedTypeId != target.PopulationServedTypeId)
            {
                source.PopulationServedTypeId = target.PopulationServedTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IPopulationServedType source, IPopulationServedType target, Action<IPopulationServedType, IPopulationServedType> onMapped)
        {
            var sourceSynchSupport = source as IPopulationServedTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IPopulationServedTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.PopulationServedTypeId = source.PopulationServedTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IPopulationServedTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: PostingResultType

namespace EdFi.Ods.Entities.Common //.PostingResultTypeAggregate
{ 
    public static class PostingResultTypeMapper 
    {
        public static bool SynchronizeTo(this IPostingResultType source, IPostingResultType target)
        {
            bool isModified = false;

            var sourceSupport = source as IPostingResultTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.PostingResultTypeId != target.PostingResultTypeId)
            {
                source.PostingResultTypeId = target.PostingResultTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IPostingResultType source, IPostingResultType target, Action<IPostingResultType, IPostingResultType> onMapped)
        {
            var sourceSynchSupport = source as IPostingResultTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IPostingResultTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.PostingResultTypeId = source.PostingResultTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IPostingResultTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: PostSecondaryEvent

namespace EdFi.Ods.Entities.Common //.PostSecondaryEventAggregate
{ 
    public static class PostSecondaryEventMapper 
    {
        public static bool SynchronizeTo(this IPostSecondaryEvent source, IPostSecondaryEvent target)
        {
            bool isModified = false;

            var sourceSupport = source as IPostSecondaryEventSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.EventDate != target.EventDate)
            {
                source.EventDate = target.EventDate;
            }
            if (source.PostSecondaryEventCategoryType != target.PostSecondaryEventCategoryType)
            {
                source.PostSecondaryEventCategoryType = target.PostSecondaryEventCategoryType;
            }
            if (source.StudentUniqueId != target.StudentUniqueId)
            {
                source.StudentUniqueId = target.StudentUniqueId;
            }

            // Copy non-PK properties

            // ----------------------------------            
            //   Synch One-to-one relationships
            // ----------------------------------            
            // PostSecondaryEventPostSecondaryInstitution
            if (sourceSupport == null || sourceSupport.IsPostSecondaryEventPostSecondaryInstitutionSupported)
            {
                if (source.PostSecondaryEventPostSecondaryInstitution == null)
                {
                    if (target.PostSecondaryEventPostSecondaryInstitution != null)
                    {
                        target.PostSecondaryEventPostSecondaryInstitution = null;
                        isModified = true;
                    }
                }
                else
                {
                    if (target.PostSecondaryEventPostSecondaryInstitution == null)
                    {
                        var itemType = target.GetType().GetProperty("PostSecondaryEventPostSecondaryInstitution").PropertyType;
                        var newItem = Activator.CreateInstance(itemType);
                        target.PostSecondaryEventPostSecondaryInstitution = (IPostSecondaryEventPostSecondaryInstitution) newItem;
                    }

                    isModified |= source.PostSecondaryEventPostSecondaryInstitution.Synchronize(target.PostSecondaryEventPostSecondaryInstitution);
                }
            }
            
            // -------------------------------------------------------------



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IPostSecondaryEvent source, IPostSecondaryEvent target, Action<IPostSecondaryEvent, IPostSecondaryEvent> onMapped)
        {
            var sourceSynchSupport = source as IPostSecondaryEventSynchronizationSourceSupport;
            var targetSynchSupport = target as IPostSecondaryEventSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.EventDate = source.EventDate;
            target.PostSecondaryEventCategoryType = source.PostSecondaryEventCategoryType;
            target.StudentUniqueId = source.StudentUniqueId;

            // Copy non-PK properties

            // ----------------------------------
            //   Map One-to-one relationships
            // ----------------------------------
            // PostSecondaryEventPostSecondaryInstitution (Source)
            if (sourceSynchSupport.IsPostSecondaryEventPostSecondaryInstitutionSupported)
            {
                var itemProperty = target.GetType().GetProperty("PostSecondaryEventPostSecondaryInstitution");
                
                if (itemProperty != null)
                {                    
                    if (source.PostSecondaryEventPostSecondaryInstitution == null)
                    {
                        target.PostSecondaryEventPostSecondaryInstitution = null;
                    }
                    else
                    {
                        var itemType = itemProperty.PropertyType;
                        object targetPostSecondaryEventPostSecondaryInstitution = Activator.CreateInstance(itemType);

                        source.PostSecondaryEventPostSecondaryInstitution.Map(targetPostSecondaryEventPostSecondaryInstitution);
                        
                        // Update the target reference appropriately
                        target.PostSecondaryEventPostSecondaryInstitution = (IPostSecondaryEventPostSecondaryInstitution) targetPostSecondaryEventPostSecondaryInstitution;
                    }
                }
            }
            else
            {
                targetSynchSupport.IsPostSecondaryEventPostSecondaryInstitutionSupported = false; 
            }
            // -------------------------------------------------------------

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IPostSecondaryEventSynchronizationSourceSupport
    {
        bool IsPostSecondaryEventPostSecondaryInstitutionSupported { get; set; }
    }
 
    public static class PostSecondaryEventPostSecondaryInstitutionMapper 
    {
        public static bool SynchronizeTo(this IPostSecondaryEventPostSecondaryInstitution source, IPostSecondaryEventPostSecondaryInstitution target)
        {
            bool isModified = false;

            var sourceSupport = source as IPostSecondaryEventPostSecondaryInstitutionSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsAdministrativeFundingControlDescriptorSupported)
                && target.AdministrativeFundingControlDescriptor != source.AdministrativeFundingControlDescriptor)
            {
                target.AdministrativeFundingControlDescriptor = source.AdministrativeFundingControlDescriptor;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNameOfInstitutionSupported)
                && target.NameOfInstitution != source.NameOfInstitution)
            {
                target.NameOfInstitution = source.NameOfInstitution;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPostSecondaryInstitutionIdSupported)
                && target.PostSecondaryInstitutionId != source.PostSecondaryInstitutionId)
            {
                target.PostSecondaryInstitutionId = source.PostSecondaryInstitutionId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPostSecondaryInstitutionLevelTypeSupported)
                && target.PostSecondaryInstitutionLevelType != source.PostSecondaryInstitutionLevelType)
            {
                target.PostSecondaryInstitutionLevelType = source.PostSecondaryInstitutionLevelType;
                isModified = true;
            }



            // Sync lists
            if (sourceSupport == null || sourceSupport.IsPostSecondaryEventPostSecondaryInstitutionIdentificationCodesSupported)
                isModified |= source.PostSecondaryEventPostSecondaryInstitutionIdentificationCodes.SynchronizeListTo(target.PostSecondaryEventPostSecondaryInstitutionIdentificationCodes, child => child.PostSecondaryEventPostSecondaryInstitution = target,
                                sourceSupport == null ? null : sourceSupport.IsPostSecondaryEventPostSecondaryInstitutionIdentificationCodeIncluded);

            if (sourceSupport == null || sourceSupport.IsPostSecondaryEventPostSecondaryInstitutionMediumOfInstructionsSupported)
                isModified |= source.PostSecondaryEventPostSecondaryInstitutionMediumOfInstructions.SynchronizeListTo(target.PostSecondaryEventPostSecondaryInstitutionMediumOfInstructions, child => child.PostSecondaryEventPostSecondaryInstitution = target,
                                sourceSupport == null ? null : sourceSupport.IsPostSecondaryEventPostSecondaryInstitutionMediumOfInstructionIncluded);


            return isModified;
        }



        public static void MapTo(this IPostSecondaryEventPostSecondaryInstitution source, IPostSecondaryEventPostSecondaryInstitution target, Action<IPostSecondaryEventPostSecondaryInstitution, IPostSecondaryEventPostSecondaryInstitution> onMapped)
        {
            var sourceSynchSupport = source as IPostSecondaryEventPostSecondaryInstitutionSynchronizationSourceSupport;
            var targetSynchSupport = target as IPostSecondaryEventPostSecondaryInstitutionSynchronizationSourceSupport;

            // Copy contextual primary key values

            // Copy non-PK properties

            if (sourceSynchSupport.IsAdministrativeFundingControlDescriptorSupported)
                target.AdministrativeFundingControlDescriptor = source.AdministrativeFundingControlDescriptor;
            else
                targetSynchSupport.IsAdministrativeFundingControlDescriptorSupported = false;

            if (sourceSynchSupport.IsNameOfInstitutionSupported)
                target.NameOfInstitution = source.NameOfInstitution;
            else
                targetSynchSupport.IsNameOfInstitutionSupported = false;

            if (sourceSynchSupport.IsPostSecondaryInstitutionIdSupported)
                target.PostSecondaryInstitutionId = source.PostSecondaryInstitutionId;
            else
                targetSynchSupport.IsPostSecondaryInstitutionIdSupported = false;

            if (sourceSynchSupport.IsPostSecondaryInstitutionLevelTypeSupported)
                target.PostSecondaryInstitutionLevelType = source.PostSecondaryInstitutionLevelType;
            else
                targetSynchSupport.IsPostSecondaryInstitutionLevelTypeSupported = false;

            // Map lists

            if (sourceSynchSupport.IsPostSecondaryEventPostSecondaryInstitutionIdentificationCodesSupported)
            {    
                targetSynchSupport.IsPostSecondaryEventPostSecondaryInstitutionIdentificationCodeIncluded = sourceSynchSupport.IsPostSecondaryEventPostSecondaryInstitutionIdentificationCodeIncluded;
                source.PostSecondaryEventPostSecondaryInstitutionIdentificationCodes.MapListTo(target.PostSecondaryEventPostSecondaryInstitutionIdentificationCodes);
            }
            else
            {
                targetSynchSupport.IsPostSecondaryEventPostSecondaryInstitutionIdentificationCodesSupported = false;
            }

            if (sourceSynchSupport.IsPostSecondaryEventPostSecondaryInstitutionMediumOfInstructionsSupported)
            {    
                targetSynchSupport.IsPostSecondaryEventPostSecondaryInstitutionMediumOfInstructionIncluded = sourceSynchSupport.IsPostSecondaryEventPostSecondaryInstitutionMediumOfInstructionIncluded;
                source.PostSecondaryEventPostSecondaryInstitutionMediumOfInstructions.MapListTo(target.PostSecondaryEventPostSecondaryInstitutionMediumOfInstructions);
            }
            else
            {
                targetSynchSupport.IsPostSecondaryEventPostSecondaryInstitutionMediumOfInstructionsSupported = false;
            }

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IPostSecondaryEventPostSecondaryInstitutionSynchronizationSourceSupport
    {
        bool IsAdministrativeFundingControlDescriptorSupported { get; set; }
        bool IsNameOfInstitutionSupported { get; set; }
        bool IsPostSecondaryEventPostSecondaryInstitutionIdentificationCodesSupported { get; set; }
        bool IsPostSecondaryEventPostSecondaryInstitutionMediumOfInstructionsSupported { get; set; }
        bool IsPostSecondaryInstitutionIdSupported { get; set; }
        bool IsPostSecondaryInstitutionLevelTypeSupported { get; set; }
        Func<IPostSecondaryEventPostSecondaryInstitutionIdentificationCode, bool> IsPostSecondaryEventPostSecondaryInstitutionIdentificationCodeIncluded { get; set; }
        Func<IPostSecondaryEventPostSecondaryInstitutionMediumOfInstruction, bool> IsPostSecondaryEventPostSecondaryInstitutionMediumOfInstructionIncluded { get; set; }
    }
 
    public static class PostSecondaryEventPostSecondaryInstitutionIdentificationCodeMapper 
    {
        public static bool SynchronizeTo(this IPostSecondaryEventPostSecondaryInstitutionIdentificationCode source, IPostSecondaryEventPostSecondaryInstitutionIdentificationCode target)
        {
            bool isModified = false;

            var sourceSupport = source as IPostSecondaryEventPostSecondaryInstitutionIdentificationCodeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.EducationOrganizationIdentificationSystemDescriptor != target.EducationOrganizationIdentificationSystemDescriptor)
            {
                source.EducationOrganizationIdentificationSystemDescriptor = target.EducationOrganizationIdentificationSystemDescriptor;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsIdentificationCodeSupported)
                && target.IdentificationCode != source.IdentificationCode)
            {
                target.IdentificationCode = source.IdentificationCode;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IPostSecondaryEventPostSecondaryInstitutionIdentificationCode source, IPostSecondaryEventPostSecondaryInstitutionIdentificationCode target, Action<IPostSecondaryEventPostSecondaryInstitutionIdentificationCode, IPostSecondaryEventPostSecondaryInstitutionIdentificationCode> onMapped)
        {
            var sourceSynchSupport = source as IPostSecondaryEventPostSecondaryInstitutionIdentificationCodeSynchronizationSourceSupport;
            var targetSynchSupport = target as IPostSecondaryEventPostSecondaryInstitutionIdentificationCodeSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.EducationOrganizationIdentificationSystemDescriptor = source.EducationOrganizationIdentificationSystemDescriptor;

            // Copy non-PK properties

            if (sourceSynchSupport.IsIdentificationCodeSupported)
                target.IdentificationCode = source.IdentificationCode;
            else
                targetSynchSupport.IsIdentificationCodeSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IPostSecondaryEventPostSecondaryInstitutionIdentificationCodeSynchronizationSourceSupport
    {
        bool IsIdentificationCodeSupported { get; set; }
    }
 
    public static class PostSecondaryEventPostSecondaryInstitutionMediumOfInstructionMapper 
    {
        public static bool SynchronizeTo(this IPostSecondaryEventPostSecondaryInstitutionMediumOfInstruction source, IPostSecondaryEventPostSecondaryInstitutionMediumOfInstruction target)
        {
            bool isModified = false;

            var sourceSupport = source as IPostSecondaryEventPostSecondaryInstitutionMediumOfInstructionSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.MediumOfInstructionType != target.MediumOfInstructionType)
            {
                source.MediumOfInstructionType = target.MediumOfInstructionType;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IPostSecondaryEventPostSecondaryInstitutionMediumOfInstruction source, IPostSecondaryEventPostSecondaryInstitutionMediumOfInstruction target, Action<IPostSecondaryEventPostSecondaryInstitutionMediumOfInstruction, IPostSecondaryEventPostSecondaryInstitutionMediumOfInstruction> onMapped)
        {
            var sourceSynchSupport = source as IPostSecondaryEventPostSecondaryInstitutionMediumOfInstructionSynchronizationSourceSupport;
            var targetSynchSupport = target as IPostSecondaryEventPostSecondaryInstitutionMediumOfInstructionSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.MediumOfInstructionType = source.MediumOfInstructionType;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IPostSecondaryEventPostSecondaryInstitutionMediumOfInstructionSynchronizationSourceSupport
    {
    }
 
}
// Aggregate: PostSecondaryEventCategoryType

namespace EdFi.Ods.Entities.Common //.PostSecondaryEventCategoryTypeAggregate
{ 
    public static class PostSecondaryEventCategoryTypeMapper 
    {
        public static bool SynchronizeTo(this IPostSecondaryEventCategoryType source, IPostSecondaryEventCategoryType target)
        {
            bool isModified = false;

            var sourceSupport = source as IPostSecondaryEventCategoryTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.PostSecondaryEventCategoryTypeId != target.PostSecondaryEventCategoryTypeId)
            {
                source.PostSecondaryEventCategoryTypeId = target.PostSecondaryEventCategoryTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IPostSecondaryEventCategoryType source, IPostSecondaryEventCategoryType target, Action<IPostSecondaryEventCategoryType, IPostSecondaryEventCategoryType> onMapped)
        {
            var sourceSynchSupport = source as IPostSecondaryEventCategoryTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IPostSecondaryEventCategoryTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.PostSecondaryEventCategoryTypeId = source.PostSecondaryEventCategoryTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IPostSecondaryEventCategoryTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: PostSecondaryInstitutionLevelType

namespace EdFi.Ods.Entities.Common //.PostSecondaryInstitutionLevelTypeAggregate
{ 
    public static class PostSecondaryInstitutionLevelTypeMapper 
    {
        public static bool SynchronizeTo(this IPostSecondaryInstitutionLevelType source, IPostSecondaryInstitutionLevelType target)
        {
            bool isModified = false;

            var sourceSupport = source as IPostSecondaryInstitutionLevelTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.PostSecondaryInstitutionLevelTypeId != target.PostSecondaryInstitutionLevelTypeId)
            {
                source.PostSecondaryInstitutionLevelTypeId = target.PostSecondaryInstitutionLevelTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IPostSecondaryInstitutionLevelType source, IPostSecondaryInstitutionLevelType target, Action<IPostSecondaryInstitutionLevelType, IPostSecondaryInstitutionLevelType> onMapped)
        {
            var sourceSynchSupport = source as IPostSecondaryInstitutionLevelTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IPostSecondaryInstitutionLevelTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.PostSecondaryInstitutionLevelTypeId = source.PostSecondaryInstitutionLevelTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IPostSecondaryInstitutionLevelTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: Program

namespace EdFi.Ods.Entities.Common //.ProgramAggregate
{ 
    public static class ProgramMapper 
    {
        public static bool SynchronizeTo(this IProgram source, IProgram target)
        {
            bool isModified = false;

            var sourceSupport = source as IProgramSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.EducationOrganizationId != target.EducationOrganizationId)
            {
                source.EducationOrganizationId = target.EducationOrganizationId;
            }
            if (source.ProgramName != target.ProgramName)
            {
                source.ProgramName = target.ProgramName;
            }
            if (source.ProgramType != target.ProgramType)
            {
                source.ProgramType = target.ProgramType;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsProgramIdSupported)
                && target.ProgramId != source.ProgramId)
            {
                target.ProgramId = source.ProgramId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsProgramSponsorTypeSupported)
                && target.ProgramSponsorType != source.ProgramSponsorType)
            {
                target.ProgramSponsorType = source.ProgramSponsorType;
                isModified = true;
            }



            // Sync lists
            if (sourceSupport == null || sourceSupport.IsProgramCharacteristicsSupported)
                isModified |= source.ProgramCharacteristics.SynchronizeListTo(target.ProgramCharacteristics, child => child.Program = target,
                                sourceSupport == null ? null : sourceSupport.IsProgramCharacteristicIncluded);

            if (sourceSupport == null || sourceSupport.IsProgramLearningObjectivesSupported)
                isModified |= source.ProgramLearningObjectives.SynchronizeListTo(target.ProgramLearningObjectives, child => child.Program = target,
                                sourceSupport == null ? null : sourceSupport.IsProgramLearningObjectiveIncluded);

            if (sourceSupport == null || sourceSupport.IsProgramLearningStandardsSupported)
                isModified |= source.ProgramLearningStandards.SynchronizeListTo(target.ProgramLearningStandards, child => child.Program = target,
                                sourceSupport == null ? null : sourceSupport.IsProgramLearningStandardIncluded);

            if (sourceSupport == null || sourceSupport.IsProgramServicesSupported)
                isModified |= source.ProgramServices.SynchronizeListTo(target.ProgramServices, child => child.Program = target,
                                sourceSupport == null ? null : sourceSupport.IsProgramServiceIncluded);


            return isModified;
        }



        public static void MapTo(this IProgram source, IProgram target, Action<IProgram, IProgram> onMapped)
        {
            var sourceSynchSupport = source as IProgramSynchronizationSourceSupport;
            var targetSynchSupport = target as IProgramSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.EducationOrganizationId = source.EducationOrganizationId;
            target.ProgramName = source.ProgramName;
            target.ProgramType = source.ProgramType;

            // Copy non-PK properties

            if (sourceSynchSupport.IsProgramIdSupported)
                target.ProgramId = source.ProgramId;
            else
                targetSynchSupport.IsProgramIdSupported = false;

            if (sourceSynchSupport.IsProgramSponsorTypeSupported)
                target.ProgramSponsorType = source.ProgramSponsorType;
            else
                targetSynchSupport.IsProgramSponsorTypeSupported = false;

            // Map lists

            if (sourceSynchSupport.IsProgramCharacteristicsSupported)
            {    
                targetSynchSupport.IsProgramCharacteristicIncluded = sourceSynchSupport.IsProgramCharacteristicIncluded;
                source.ProgramCharacteristics.MapListTo(target.ProgramCharacteristics);
            }
            else
            {
                targetSynchSupport.IsProgramCharacteristicsSupported = false;
            }

            if (sourceSynchSupport.IsProgramLearningObjectivesSupported)
            {    
                targetSynchSupport.IsProgramLearningObjectiveIncluded = sourceSynchSupport.IsProgramLearningObjectiveIncluded;
                source.ProgramLearningObjectives.MapListTo(target.ProgramLearningObjectives);
            }
            else
            {
                targetSynchSupport.IsProgramLearningObjectivesSupported = false;
            }

            if (sourceSynchSupport.IsProgramLearningStandardsSupported)
            {    
                targetSynchSupport.IsProgramLearningStandardIncluded = sourceSynchSupport.IsProgramLearningStandardIncluded;
                source.ProgramLearningStandards.MapListTo(target.ProgramLearningStandards);
            }
            else
            {
                targetSynchSupport.IsProgramLearningStandardsSupported = false;
            }

            if (sourceSynchSupport.IsProgramServicesSupported)
            {    
                targetSynchSupport.IsProgramServiceIncluded = sourceSynchSupport.IsProgramServiceIncluded;
                source.ProgramServices.MapListTo(target.ProgramServices);
            }
            else
            {
                targetSynchSupport.IsProgramServicesSupported = false;
            }

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IProgramSynchronizationSourceSupport
    {
        bool IsProgramCharacteristicsSupported { get; set; }
        bool IsProgramIdSupported { get; set; }
        bool IsProgramLearningObjectivesSupported { get; set; }
        bool IsProgramLearningStandardsSupported { get; set; }
        bool IsProgramServicesSupported { get; set; }
        bool IsProgramSponsorTypeSupported { get; set; }
        Func<IProgramCharacteristic, bool> IsProgramCharacteristicIncluded { get; set; }
        Func<IProgramLearningObjective, bool> IsProgramLearningObjectiveIncluded { get; set; }
        Func<IProgramLearningStandard, bool> IsProgramLearningStandardIncluded { get; set; }
        Func<IProgramService, bool> IsProgramServiceIncluded { get; set; }
    }
 
    public static class ProgramCharacteristicMapper 
    {
        public static bool SynchronizeTo(this IProgramCharacteristic source, IProgramCharacteristic target)
        {
            bool isModified = false;

            var sourceSupport = source as IProgramCharacteristicSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.ProgramCharacteristicDescriptor != target.ProgramCharacteristicDescriptor)
            {
                source.ProgramCharacteristicDescriptor = target.ProgramCharacteristicDescriptor;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IProgramCharacteristic source, IProgramCharacteristic target, Action<IProgramCharacteristic, IProgramCharacteristic> onMapped)
        {
            var sourceSynchSupport = source as IProgramCharacteristicSynchronizationSourceSupport;
            var targetSynchSupport = target as IProgramCharacteristicSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.ProgramCharacteristicDescriptor = source.ProgramCharacteristicDescriptor;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IProgramCharacteristicSynchronizationSourceSupport
    {
    }
 
    public static class ProgramLearningObjectiveMapper 
    {
        public static bool SynchronizeTo(this IProgramLearningObjective source, IProgramLearningObjective target)
        {
            bool isModified = false;

            var sourceSupport = source as IProgramLearningObjectiveSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.LearningObjectiveId != target.LearningObjectiveId)
            {
                source.LearningObjectiveId = target.LearningObjectiveId;
            }
            if (source.Namespace != target.Namespace)
            {
                source.Namespace = target.Namespace;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IProgramLearningObjective source, IProgramLearningObjective target, Action<IProgramLearningObjective, IProgramLearningObjective> onMapped)
        {
            var sourceSynchSupport = source as IProgramLearningObjectiveSynchronizationSourceSupport;
            var targetSynchSupport = target as IProgramLearningObjectiveSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.LearningObjectiveId = source.LearningObjectiveId;
            target.Namespace = source.Namespace;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IProgramLearningObjectiveSynchronizationSourceSupport
    {
    }
 
    public static class ProgramLearningStandardMapper 
    {
        public static bool SynchronizeTo(this IProgramLearningStandard source, IProgramLearningStandard target)
        {
            bool isModified = false;

            var sourceSupport = source as IProgramLearningStandardSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.LearningStandardId != target.LearningStandardId)
            {
                source.LearningStandardId = target.LearningStandardId;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IProgramLearningStandard source, IProgramLearningStandard target, Action<IProgramLearningStandard, IProgramLearningStandard> onMapped)
        {
            var sourceSynchSupport = source as IProgramLearningStandardSynchronizationSourceSupport;
            var targetSynchSupport = target as IProgramLearningStandardSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.LearningStandardId = source.LearningStandardId;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IProgramLearningStandardSynchronizationSourceSupport
    {
    }
 
    public static class ProgramServiceMapper 
    {
        public static bool SynchronizeTo(this IProgramService source, IProgramService target)
        {
            bool isModified = false;

            var sourceSupport = source as IProgramServiceSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.ServiceDescriptor != target.ServiceDescriptor)
            {
                source.ServiceDescriptor = target.ServiceDescriptor;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IProgramService source, IProgramService target, Action<IProgramService, IProgramService> onMapped)
        {
            var sourceSynchSupport = source as IProgramServiceSynchronizationSourceSupport;
            var targetSynchSupport = target as IProgramServiceSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.ServiceDescriptor = source.ServiceDescriptor;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IProgramServiceSynchronizationSourceSupport
    {
    }
 
}
// Aggregate: ProgramAssignmentDescriptor

namespace EdFi.Ods.Entities.Common //.ProgramAssignmentDescriptorAggregate
{ 
    public static class ProgramAssignmentDescriptorMapper 
    {
        public static bool SynchronizeTo(this IProgramAssignmentDescriptor source, IProgramAssignmentDescriptor target)
        {
            bool isModified = false;

            var sourceSupport = source as IProgramAssignmentDescriptorSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.ProgramAssignmentDescriptorId != target.ProgramAssignmentDescriptorId)
            {
                source.ProgramAssignmentDescriptorId = target.ProgramAssignmentDescriptorId;
            }

            // Copy inherited non-PK properties


            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveBeginDateSupported)
                && target.EffectiveBeginDate != source.EffectiveBeginDate)
            {
                target.EffectiveBeginDate = source.EffectiveBeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveEndDateSupported)
                && target.EffectiveEndDate != source.EffectiveEndDate)
            {
                target.EffectiveEndDate = source.EffectiveEndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNamespaceSupported)
                && target.Namespace != source.Namespace)
            {
                target.Namespace = source.Namespace;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPriorDescriptorIdSupported)
                && target.PriorDescriptorId != source.PriorDescriptorId)
            {
                target.PriorDescriptorId = source.PriorDescriptorId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsProgramAssignmentTypeSupported)
                && target.ProgramAssignmentType != source.ProgramAssignmentType)
            {
                target.ProgramAssignmentType = source.ProgramAssignmentType;
                isModified = true;
            }

            // Synch inherited lists


            // Sync lists

            return isModified;
        }



        public static void MapTo(this IProgramAssignmentDescriptor source, IProgramAssignmentDescriptor target, Action<IProgramAssignmentDescriptor, IProgramAssignmentDescriptor> onMapped)
        {
            var sourceSynchSupport = source as IProgramAssignmentDescriptorSynchronizationSourceSupport;
            var targetSynchSupport = target as IProgramAssignmentDescriptorSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.ProgramAssignmentDescriptorId = source.ProgramAssignmentDescriptorId;

            // Copy inherited non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsEffectiveBeginDateSupported)
                target.EffectiveBeginDate = source.EffectiveBeginDate;
            else
                targetSynchSupport.IsEffectiveBeginDateSupported = false;

            if (sourceSynchSupport.IsEffectiveEndDateSupported)
                target.EffectiveEndDate = source.EffectiveEndDate;
            else
                targetSynchSupport.IsEffectiveEndDateSupported = false;

            if (sourceSynchSupport.IsNamespaceSupported)
                target.Namespace = source.Namespace;
            else
                targetSynchSupport.IsNamespaceSupported = false;

            if (sourceSynchSupport.IsPriorDescriptorIdSupported)
                target.PriorDescriptorId = source.PriorDescriptorId;
            else
                targetSynchSupport.IsPriorDescriptorIdSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Copy non-PK properties

            if (sourceSynchSupport.IsProgramAssignmentTypeSupported)
                target.ProgramAssignmentType = source.ProgramAssignmentType;
            else
                targetSynchSupport.IsProgramAssignmentTypeSupported = false;

            // Map inherited lists

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IProgramAssignmentDescriptorSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsEffectiveBeginDateSupported { get; set; }
        bool IsEffectiveEndDateSupported { get; set; }
        bool IsNamespaceSupported { get; set; }
        bool IsPriorDescriptorIdSupported { get; set; }
        bool IsProgramAssignmentTypeSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: ProgramAssignmentType

namespace EdFi.Ods.Entities.Common //.ProgramAssignmentTypeAggregate
{ 
    public static class ProgramAssignmentTypeMapper 
    {
        public static bool SynchronizeTo(this IProgramAssignmentType source, IProgramAssignmentType target)
        {
            bool isModified = false;

            var sourceSupport = source as IProgramAssignmentTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.ProgramAssignmentTypeId != target.ProgramAssignmentTypeId)
            {
                source.ProgramAssignmentTypeId = target.ProgramAssignmentTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IProgramAssignmentType source, IProgramAssignmentType target, Action<IProgramAssignmentType, IProgramAssignmentType> onMapped)
        {
            var sourceSynchSupport = source as IProgramAssignmentTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IProgramAssignmentTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.ProgramAssignmentTypeId = source.ProgramAssignmentTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IProgramAssignmentTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: ProgramCharacteristicDescriptor

namespace EdFi.Ods.Entities.Common //.ProgramCharacteristicDescriptorAggregate
{ 
    public static class ProgramCharacteristicDescriptorMapper 
    {
        public static bool SynchronizeTo(this IProgramCharacteristicDescriptor source, IProgramCharacteristicDescriptor target)
        {
            bool isModified = false;

            var sourceSupport = source as IProgramCharacteristicDescriptorSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.ProgramCharacteristicDescriptorId != target.ProgramCharacteristicDescriptorId)
            {
                source.ProgramCharacteristicDescriptorId = target.ProgramCharacteristicDescriptorId;
            }

            // Copy inherited non-PK properties


            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveBeginDateSupported)
                && target.EffectiveBeginDate != source.EffectiveBeginDate)
            {
                target.EffectiveBeginDate = source.EffectiveBeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveEndDateSupported)
                && target.EffectiveEndDate != source.EffectiveEndDate)
            {
                target.EffectiveEndDate = source.EffectiveEndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNamespaceSupported)
                && target.Namespace != source.Namespace)
            {
                target.Namespace = source.Namespace;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPriorDescriptorIdSupported)
                && target.PriorDescriptorId != source.PriorDescriptorId)
            {
                target.PriorDescriptorId = source.PriorDescriptorId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsProgramCharacteristicTypeSupported)
                && target.ProgramCharacteristicType != source.ProgramCharacteristicType)
            {
                target.ProgramCharacteristicType = source.ProgramCharacteristicType;
                isModified = true;
            }

            // Synch inherited lists


            // Sync lists

            return isModified;
        }



        public static void MapTo(this IProgramCharacteristicDescriptor source, IProgramCharacteristicDescriptor target, Action<IProgramCharacteristicDescriptor, IProgramCharacteristicDescriptor> onMapped)
        {
            var sourceSynchSupport = source as IProgramCharacteristicDescriptorSynchronizationSourceSupport;
            var targetSynchSupport = target as IProgramCharacteristicDescriptorSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.ProgramCharacteristicDescriptorId = source.ProgramCharacteristicDescriptorId;

            // Copy inherited non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsEffectiveBeginDateSupported)
                target.EffectiveBeginDate = source.EffectiveBeginDate;
            else
                targetSynchSupport.IsEffectiveBeginDateSupported = false;

            if (sourceSynchSupport.IsEffectiveEndDateSupported)
                target.EffectiveEndDate = source.EffectiveEndDate;
            else
                targetSynchSupport.IsEffectiveEndDateSupported = false;

            if (sourceSynchSupport.IsNamespaceSupported)
                target.Namespace = source.Namespace;
            else
                targetSynchSupport.IsNamespaceSupported = false;

            if (sourceSynchSupport.IsPriorDescriptorIdSupported)
                target.PriorDescriptorId = source.PriorDescriptorId;
            else
                targetSynchSupport.IsPriorDescriptorIdSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Copy non-PK properties

            if (sourceSynchSupport.IsProgramCharacteristicTypeSupported)
                target.ProgramCharacteristicType = source.ProgramCharacteristicType;
            else
                targetSynchSupport.IsProgramCharacteristicTypeSupported = false;

            // Map inherited lists

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IProgramCharacteristicDescriptorSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsEffectiveBeginDateSupported { get; set; }
        bool IsEffectiveEndDateSupported { get; set; }
        bool IsNamespaceSupported { get; set; }
        bool IsPriorDescriptorIdSupported { get; set; }
        bool IsProgramCharacteristicTypeSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: ProgramCharacteristicType

namespace EdFi.Ods.Entities.Common //.ProgramCharacteristicTypeAggregate
{ 
    public static class ProgramCharacteristicTypeMapper 
    {
        public static bool SynchronizeTo(this IProgramCharacteristicType source, IProgramCharacteristicType target)
        {
            bool isModified = false;

            var sourceSupport = source as IProgramCharacteristicTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.ProgramCharacteristicTypeId != target.ProgramCharacteristicTypeId)
            {
                source.ProgramCharacteristicTypeId = target.ProgramCharacteristicTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IProgramCharacteristicType source, IProgramCharacteristicType target, Action<IProgramCharacteristicType, IProgramCharacteristicType> onMapped)
        {
            var sourceSynchSupport = source as IProgramCharacteristicTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IProgramCharacteristicTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.ProgramCharacteristicTypeId = source.ProgramCharacteristicTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IProgramCharacteristicTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: ProgramSponsorType

namespace EdFi.Ods.Entities.Common //.ProgramSponsorTypeAggregate
{ 
    public static class ProgramSponsorTypeMapper 
    {
        public static bool SynchronizeTo(this IProgramSponsorType source, IProgramSponsorType target)
        {
            bool isModified = false;

            var sourceSupport = source as IProgramSponsorTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.ProgramSponsorTypeId != target.ProgramSponsorTypeId)
            {
                source.ProgramSponsorTypeId = target.ProgramSponsorTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IProgramSponsorType source, IProgramSponsorType target, Action<IProgramSponsorType, IProgramSponsorType> onMapped)
        {
            var sourceSynchSupport = source as IProgramSponsorTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IProgramSponsorTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.ProgramSponsorTypeId = source.ProgramSponsorTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IProgramSponsorTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: ProgramType

namespace EdFi.Ods.Entities.Common //.ProgramTypeAggregate
{ 
    public static class ProgramTypeMapper 
    {
        public static bool SynchronizeTo(this IProgramType source, IProgramType target)
        {
            bool isModified = false;

            var sourceSupport = source as IProgramTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.ProgramTypeId != target.ProgramTypeId)
            {
                source.ProgramTypeId = target.ProgramTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IProgramType source, IProgramType target, Action<IProgramType, IProgramType> onMapped)
        {
            var sourceSynchSupport = source as IProgramTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IProgramTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.ProgramTypeId = source.ProgramTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IProgramTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: PublicationStatusType

namespace EdFi.Ods.Entities.Common //.PublicationStatusTypeAggregate
{ 
    public static class PublicationStatusTypeMapper 
    {
        public static bool SynchronizeTo(this IPublicationStatusType source, IPublicationStatusType target)
        {
            bool isModified = false;

            var sourceSupport = source as IPublicationStatusTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.PublicationStatusTypeId != target.PublicationStatusTypeId)
            {
                source.PublicationStatusTypeId = target.PublicationStatusTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IPublicationStatusType source, IPublicationStatusType target, Action<IPublicationStatusType, IPublicationStatusType> onMapped)
        {
            var sourceSynchSupport = source as IPublicationStatusTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IPublicationStatusTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.PublicationStatusTypeId = source.PublicationStatusTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IPublicationStatusTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: RaceType

namespace EdFi.Ods.Entities.Common //.RaceTypeAggregate
{ 
    public static class RaceTypeMapper 
    {
        public static bool SynchronizeTo(this IRaceType source, IRaceType target)
        {
            bool isModified = false;

            var sourceSupport = source as IRaceTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.RaceTypeId != target.RaceTypeId)
            {
                source.RaceTypeId = target.RaceTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IRaceType source, IRaceType target, Action<IRaceType, IRaceType> onMapped)
        {
            var sourceSynchSupport = source as IRaceTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IRaceTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.RaceTypeId = source.RaceTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IRaceTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: ReasonExitedDescriptor

namespace EdFi.Ods.Entities.Common //.ReasonExitedDescriptorAggregate
{ 
    public static class ReasonExitedDescriptorMapper 
    {
        public static bool SynchronizeTo(this IReasonExitedDescriptor source, IReasonExitedDescriptor target)
        {
            bool isModified = false;

            var sourceSupport = source as IReasonExitedDescriptorSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.ReasonExitedDescriptorId != target.ReasonExitedDescriptorId)
            {
                source.ReasonExitedDescriptorId = target.ReasonExitedDescriptorId;
            }

            // Copy inherited non-PK properties


            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveBeginDateSupported)
                && target.EffectiveBeginDate != source.EffectiveBeginDate)
            {
                target.EffectiveBeginDate = source.EffectiveBeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveEndDateSupported)
                && target.EffectiveEndDate != source.EffectiveEndDate)
            {
                target.EffectiveEndDate = source.EffectiveEndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNamespaceSupported)
                && target.Namespace != source.Namespace)
            {
                target.Namespace = source.Namespace;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPriorDescriptorIdSupported)
                && target.PriorDescriptorId != source.PriorDescriptorId)
            {
                target.PriorDescriptorId = source.PriorDescriptorId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsReasonExitedTypeSupported)
                && target.ReasonExitedType != source.ReasonExitedType)
            {
                target.ReasonExitedType = source.ReasonExitedType;
                isModified = true;
            }

            // Synch inherited lists


            // Sync lists

            return isModified;
        }



        public static void MapTo(this IReasonExitedDescriptor source, IReasonExitedDescriptor target, Action<IReasonExitedDescriptor, IReasonExitedDescriptor> onMapped)
        {
            var sourceSynchSupport = source as IReasonExitedDescriptorSynchronizationSourceSupport;
            var targetSynchSupport = target as IReasonExitedDescriptorSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.ReasonExitedDescriptorId = source.ReasonExitedDescriptorId;

            // Copy inherited non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsEffectiveBeginDateSupported)
                target.EffectiveBeginDate = source.EffectiveBeginDate;
            else
                targetSynchSupport.IsEffectiveBeginDateSupported = false;

            if (sourceSynchSupport.IsEffectiveEndDateSupported)
                target.EffectiveEndDate = source.EffectiveEndDate;
            else
                targetSynchSupport.IsEffectiveEndDateSupported = false;

            if (sourceSynchSupport.IsNamespaceSupported)
                target.Namespace = source.Namespace;
            else
                targetSynchSupport.IsNamespaceSupported = false;

            if (sourceSynchSupport.IsPriorDescriptorIdSupported)
                target.PriorDescriptorId = source.PriorDescriptorId;
            else
                targetSynchSupport.IsPriorDescriptorIdSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Copy non-PK properties

            if (sourceSynchSupport.IsReasonExitedTypeSupported)
                target.ReasonExitedType = source.ReasonExitedType;
            else
                targetSynchSupport.IsReasonExitedTypeSupported = false;

            // Map inherited lists

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IReasonExitedDescriptorSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsEffectiveBeginDateSupported { get; set; }
        bool IsEffectiveEndDateSupported { get; set; }
        bool IsNamespaceSupported { get; set; }
        bool IsPriorDescriptorIdSupported { get; set; }
        bool IsReasonExitedTypeSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: ReasonExitedType

namespace EdFi.Ods.Entities.Common //.ReasonExitedTypeAggregate
{ 
    public static class ReasonExitedTypeMapper 
    {
        public static bool SynchronizeTo(this IReasonExitedType source, IReasonExitedType target)
        {
            bool isModified = false;

            var sourceSupport = source as IReasonExitedTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.ReasonExitedTypeId != target.ReasonExitedTypeId)
            {
                source.ReasonExitedTypeId = target.ReasonExitedTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IReasonExitedType source, IReasonExitedType target, Action<IReasonExitedType, IReasonExitedType> onMapped)
        {
            var sourceSynchSupport = source as IReasonExitedTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IReasonExitedTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.ReasonExitedTypeId = source.ReasonExitedTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IReasonExitedTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: ReasonNotTestedType

namespace EdFi.Ods.Entities.Common //.ReasonNotTestedTypeAggregate
{ 
    public static class ReasonNotTestedTypeMapper 
    {
        public static bool SynchronizeTo(this IReasonNotTestedType source, IReasonNotTestedType target)
        {
            bool isModified = false;

            var sourceSupport = source as IReasonNotTestedTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.ReasonNotTestedTypeId != target.ReasonNotTestedTypeId)
            {
                source.ReasonNotTestedTypeId = target.ReasonNotTestedTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IReasonNotTestedType source, IReasonNotTestedType target, Action<IReasonNotTestedType, IReasonNotTestedType> onMapped)
        {
            var sourceSynchSupport = source as IReasonNotTestedTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IReasonNotTestedTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.ReasonNotTestedTypeId = source.ReasonNotTestedTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IReasonNotTestedTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: RecognitionType

namespace EdFi.Ods.Entities.Common //.RecognitionTypeAggregate
{ 
    public static class RecognitionTypeMapper 
    {
        public static bool SynchronizeTo(this IRecognitionType source, IRecognitionType target)
        {
            bool isModified = false;

            var sourceSupport = source as IRecognitionTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.RecognitionTypeId != target.RecognitionTypeId)
            {
                source.RecognitionTypeId = target.RecognitionTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IRecognitionType source, IRecognitionType target, Action<IRecognitionType, IRecognitionType> onMapped)
        {
            var sourceSynchSupport = source as IRecognitionTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IRecognitionTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.RecognitionTypeId = source.RecognitionTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IRecognitionTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: RelationType

namespace EdFi.Ods.Entities.Common //.RelationTypeAggregate
{ 
    public static class RelationTypeMapper 
    {
        public static bool SynchronizeTo(this IRelationType source, IRelationType target)
        {
            bool isModified = false;

            var sourceSupport = source as IRelationTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.RelationTypeId != target.RelationTypeId)
            {
                source.RelationTypeId = target.RelationTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IRelationType source, IRelationType target, Action<IRelationType, IRelationType> onMapped)
        {
            var sourceSynchSupport = source as IRelationTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IRelationTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.RelationTypeId = source.RelationTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IRelationTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: RepeatIdentifierType

namespace EdFi.Ods.Entities.Common //.RepeatIdentifierTypeAggregate
{ 
    public static class RepeatIdentifierTypeMapper 
    {
        public static bool SynchronizeTo(this IRepeatIdentifierType source, IRepeatIdentifierType target)
        {
            bool isModified = false;

            var sourceSupport = source as IRepeatIdentifierTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.RepeatIdentifierTypeId != target.RepeatIdentifierTypeId)
            {
                source.RepeatIdentifierTypeId = target.RepeatIdentifierTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IRepeatIdentifierType source, IRepeatIdentifierType target, Action<IRepeatIdentifierType, IRepeatIdentifierType> onMapped)
        {
            var sourceSynchSupport = source as IRepeatIdentifierTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IRepeatIdentifierTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.RepeatIdentifierTypeId = source.RepeatIdentifierTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IRepeatIdentifierTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: ReportCard

namespace EdFi.Ods.Entities.Common //.ReportCardAggregate
{ 
    public static class ReportCardMapper 
    {
        public static bool SynchronizeTo(this IReportCard source, IReportCard target)
        {
            bool isModified = false;

            var sourceSupport = source as IReportCardSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.EducationOrganizationId != target.EducationOrganizationId)
            {
                source.EducationOrganizationId = target.EducationOrganizationId;
            }
            if (source.GradingPeriodBeginDate != target.GradingPeriodBeginDate)
            {
                source.GradingPeriodBeginDate = target.GradingPeriodBeginDate;
            }
            if (source.GradingPeriodDescriptor != target.GradingPeriodDescriptor)
            {
                source.GradingPeriodDescriptor = target.GradingPeriodDescriptor;
            }
            if (source.SchoolId != target.SchoolId)
            {
                source.SchoolId = target.SchoolId;
            }
            if (source.StudentUniqueId != target.StudentUniqueId)
            {
                source.StudentUniqueId = target.StudentUniqueId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsGPACumulativeSupported)
                && target.GPACumulative != source.GPACumulative)
            {
                target.GPACumulative = source.GPACumulative;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsGPAGivenGradingPeriodSupported)
                && target.GPAGivenGradingPeriod != source.GPAGivenGradingPeriod)
            {
                target.GPAGivenGradingPeriod = source.GPAGivenGradingPeriod;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNumberOfDaysAbsentSupported)
                && target.NumberOfDaysAbsent != source.NumberOfDaysAbsent)
            {
                target.NumberOfDaysAbsent = source.NumberOfDaysAbsent;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNumberOfDaysInAttendanceSupported)
                && target.NumberOfDaysInAttendance != source.NumberOfDaysInAttendance)
            {
                target.NumberOfDaysInAttendance = source.NumberOfDaysInAttendance;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNumberOfDaysTardySupported)
                && target.NumberOfDaysTardy != source.NumberOfDaysTardy)
            {
                target.NumberOfDaysTardy = source.NumberOfDaysTardy;
                isModified = true;
            }



            // Sync lists
            if (sourceSupport == null || sourceSupport.IsReportCardGradesSupported)
                isModified |= source.ReportCardGrades.SynchronizeListTo(target.ReportCardGrades, child => child.ReportCard = target,
                                sourceSupport == null ? null : sourceSupport.IsReportCardGradeIncluded);

            if (sourceSupport == null || sourceSupport.IsReportCardStudentCompetencyObjectivesSupported)
                isModified |= source.ReportCardStudentCompetencyObjectives.SynchronizeListTo(target.ReportCardStudentCompetencyObjectives, child => child.ReportCard = target,
                                sourceSupport == null ? null : sourceSupport.IsReportCardStudentCompetencyObjectiveIncluded);

            if (sourceSupport == null || sourceSupport.IsReportCardStudentLearningObjectivesSupported)
                isModified |= source.ReportCardStudentLearningObjectives.SynchronizeListTo(target.ReportCardStudentLearningObjectives, child => child.ReportCard = target,
                                sourceSupport == null ? null : sourceSupport.IsReportCardStudentLearningObjectiveIncluded);


            return isModified;
        }



        public static void MapTo(this IReportCard source, IReportCard target, Action<IReportCard, IReportCard> onMapped)
        {
            var sourceSynchSupport = source as IReportCardSynchronizationSourceSupport;
            var targetSynchSupport = target as IReportCardSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.EducationOrganizationId = source.EducationOrganizationId;
            target.GradingPeriodBeginDate = source.GradingPeriodBeginDate;
            target.GradingPeriodDescriptor = source.GradingPeriodDescriptor;
            target.SchoolId = source.SchoolId;
            target.StudentUniqueId = source.StudentUniqueId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsGPACumulativeSupported)
                target.GPACumulative = source.GPACumulative;
            else
                targetSynchSupport.IsGPACumulativeSupported = false;

            if (sourceSynchSupport.IsGPAGivenGradingPeriodSupported)
                target.GPAGivenGradingPeriod = source.GPAGivenGradingPeriod;
            else
                targetSynchSupport.IsGPAGivenGradingPeriodSupported = false;

            if (sourceSynchSupport.IsNumberOfDaysAbsentSupported)
                target.NumberOfDaysAbsent = source.NumberOfDaysAbsent;
            else
                targetSynchSupport.IsNumberOfDaysAbsentSupported = false;

            if (sourceSynchSupport.IsNumberOfDaysInAttendanceSupported)
                target.NumberOfDaysInAttendance = source.NumberOfDaysInAttendance;
            else
                targetSynchSupport.IsNumberOfDaysInAttendanceSupported = false;

            if (sourceSynchSupport.IsNumberOfDaysTardySupported)
                target.NumberOfDaysTardy = source.NumberOfDaysTardy;
            else
                targetSynchSupport.IsNumberOfDaysTardySupported = false;

            // Map lists

            if (sourceSynchSupport.IsReportCardGradesSupported)
            {    
                targetSynchSupport.IsReportCardGradeIncluded = sourceSynchSupport.IsReportCardGradeIncluded;
                source.ReportCardGrades.MapListTo(target.ReportCardGrades);
            }
            else
            {
                targetSynchSupport.IsReportCardGradesSupported = false;
            }

            if (sourceSynchSupport.IsReportCardStudentCompetencyObjectivesSupported)
            {    
                targetSynchSupport.IsReportCardStudentCompetencyObjectiveIncluded = sourceSynchSupport.IsReportCardStudentCompetencyObjectiveIncluded;
                source.ReportCardStudentCompetencyObjectives.MapListTo(target.ReportCardStudentCompetencyObjectives);
            }
            else
            {
                targetSynchSupport.IsReportCardStudentCompetencyObjectivesSupported = false;
            }

            if (sourceSynchSupport.IsReportCardStudentLearningObjectivesSupported)
            {    
                targetSynchSupport.IsReportCardStudentLearningObjectiveIncluded = sourceSynchSupport.IsReportCardStudentLearningObjectiveIncluded;
                source.ReportCardStudentLearningObjectives.MapListTo(target.ReportCardStudentLearningObjectives);
            }
            else
            {
                targetSynchSupport.IsReportCardStudentLearningObjectivesSupported = false;
            }

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IReportCardSynchronizationSourceSupport
    {
        bool IsGPACumulativeSupported { get; set; }
        bool IsGPAGivenGradingPeriodSupported { get; set; }
        bool IsNumberOfDaysAbsentSupported { get; set; }
        bool IsNumberOfDaysInAttendanceSupported { get; set; }
        bool IsNumberOfDaysTardySupported { get; set; }
        bool IsReportCardGradesSupported { get; set; }
        bool IsReportCardStudentCompetencyObjectivesSupported { get; set; }
        bool IsReportCardStudentLearningObjectivesSupported { get; set; }
        Func<IReportCardGrade, bool> IsReportCardGradeIncluded { get; set; }
        Func<IReportCardStudentCompetencyObjective, bool> IsReportCardStudentCompetencyObjectiveIncluded { get; set; }
        Func<IReportCardStudentLearningObjective, bool> IsReportCardStudentLearningObjectiveIncluded { get; set; }
    }
 
    public static class ReportCardGradeMapper 
    {
        public static bool SynchronizeTo(this IReportCardGrade source, IReportCardGrade target)
        {
            bool isModified = false;

            var sourceSupport = source as IReportCardGradeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.BeginDate != target.BeginDate)
            {
                source.BeginDate = target.BeginDate;
            }
            if (source.ClassPeriodName != target.ClassPeriodName)
            {
                source.ClassPeriodName = target.ClassPeriodName;
            }
            if (source.ClassroomIdentificationCode != target.ClassroomIdentificationCode)
            {
                source.ClassroomIdentificationCode = target.ClassroomIdentificationCode;
            }
            if (source.GradeType != target.GradeType)
            {
                source.GradeType = target.GradeType;
            }
            if (source.LocalCourseCode != target.LocalCourseCode)
            {
                source.LocalCourseCode = target.LocalCourseCode;
            }
            if (source.SchoolYear != target.SchoolYear)
            {
                source.SchoolYear = target.SchoolYear;
            }
            if (source.SequenceOfCourse != target.SequenceOfCourse)
            {
                source.SequenceOfCourse = target.SequenceOfCourse;
            }
            if (source.TermDescriptor != target.TermDescriptor)
            {
                source.TermDescriptor = target.TermDescriptor;
            }
            if (source.UniqueSectionCode != target.UniqueSectionCode)
            {
                source.UniqueSectionCode = target.UniqueSectionCode;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IReportCardGrade source, IReportCardGrade target, Action<IReportCardGrade, IReportCardGrade> onMapped)
        {
            var sourceSynchSupport = source as IReportCardGradeSynchronizationSourceSupport;
            var targetSynchSupport = target as IReportCardGradeSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.BeginDate = source.BeginDate;
            target.ClassPeriodName = source.ClassPeriodName;
            target.ClassroomIdentificationCode = source.ClassroomIdentificationCode;
            target.GradeType = source.GradeType;
            target.LocalCourseCode = source.LocalCourseCode;
            target.SchoolYear = source.SchoolYear;
            target.SequenceOfCourse = source.SequenceOfCourse;
            target.TermDescriptor = source.TermDescriptor;
            target.UniqueSectionCode = source.UniqueSectionCode;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IReportCardGradeSynchronizationSourceSupport
    {
    }
 
    public static class ReportCardStudentCompetencyObjectiveMapper 
    {
        public static bool SynchronizeTo(this IReportCardStudentCompetencyObjective source, IReportCardStudentCompetencyObjective target)
        {
            bool isModified = false;

            var sourceSupport = source as IReportCardStudentCompetencyObjectiveSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.Objective != target.Objective)
            {
                source.Objective = target.Objective;
            }
            if (source.ObjectiveEducationOrganizationId != target.ObjectiveEducationOrganizationId)
            {
                source.ObjectiveEducationOrganizationId = target.ObjectiveEducationOrganizationId;
            }
            if (source.ObjectiveGradeLevelDescriptor != target.ObjectiveGradeLevelDescriptor)
            {
                source.ObjectiveGradeLevelDescriptor = target.ObjectiveGradeLevelDescriptor;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IReportCardStudentCompetencyObjective source, IReportCardStudentCompetencyObjective target, Action<IReportCardStudentCompetencyObjective, IReportCardStudentCompetencyObjective> onMapped)
        {
            var sourceSynchSupport = source as IReportCardStudentCompetencyObjectiveSynchronizationSourceSupport;
            var targetSynchSupport = target as IReportCardStudentCompetencyObjectiveSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.Objective = source.Objective;
            target.ObjectiveEducationOrganizationId = source.ObjectiveEducationOrganizationId;
            target.ObjectiveGradeLevelDescriptor = source.ObjectiveGradeLevelDescriptor;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IReportCardStudentCompetencyObjectiveSynchronizationSourceSupport
    {
    }
 
    public static class ReportCardStudentLearningObjectiveMapper 
    {
        public static bool SynchronizeTo(this IReportCardStudentLearningObjective source, IReportCardStudentLearningObjective target)
        {
            bool isModified = false;

            var sourceSupport = source as IReportCardStudentLearningObjectiveSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.LearningObjectiveId != target.LearningObjectiveId)
            {
                source.LearningObjectiveId = target.LearningObjectiveId;
            }
            if (source.Namespace != target.Namespace)
            {
                source.Namespace = target.Namespace;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IReportCardStudentLearningObjective source, IReportCardStudentLearningObjective target, Action<IReportCardStudentLearningObjective, IReportCardStudentLearningObjective> onMapped)
        {
            var sourceSynchSupport = source as IReportCardStudentLearningObjectiveSynchronizationSourceSupport;
            var targetSynchSupport = target as IReportCardStudentLearningObjectiveSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.LearningObjectiveId = source.LearningObjectiveId;
            target.Namespace = source.Namespace;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IReportCardStudentLearningObjectiveSynchronizationSourceSupport
    {
    }
 
}
// Aggregate: ReporterDescriptionDescriptor

namespace EdFi.Ods.Entities.Common //.ReporterDescriptionDescriptorAggregate
{ 
    public static class ReporterDescriptionDescriptorMapper 
    {
        public static bool SynchronizeTo(this IReporterDescriptionDescriptor source, IReporterDescriptionDescriptor target)
        {
            bool isModified = false;

            var sourceSupport = source as IReporterDescriptionDescriptorSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.ReporterDescriptionDescriptorId != target.ReporterDescriptionDescriptorId)
            {
                source.ReporterDescriptionDescriptorId = target.ReporterDescriptionDescriptorId;
            }

            // Copy inherited non-PK properties


            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveBeginDateSupported)
                && target.EffectiveBeginDate != source.EffectiveBeginDate)
            {
                target.EffectiveBeginDate = source.EffectiveBeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveEndDateSupported)
                && target.EffectiveEndDate != source.EffectiveEndDate)
            {
                target.EffectiveEndDate = source.EffectiveEndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNamespaceSupported)
                && target.Namespace != source.Namespace)
            {
                target.Namespace = source.Namespace;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPriorDescriptorIdSupported)
                && target.PriorDescriptorId != source.PriorDescriptorId)
            {
                target.PriorDescriptorId = source.PriorDescriptorId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsReporterDescriptionTypeSupported)
                && target.ReporterDescriptionType != source.ReporterDescriptionType)
            {
                target.ReporterDescriptionType = source.ReporterDescriptionType;
                isModified = true;
            }

            // Synch inherited lists


            // Sync lists

            return isModified;
        }



        public static void MapTo(this IReporterDescriptionDescriptor source, IReporterDescriptionDescriptor target, Action<IReporterDescriptionDescriptor, IReporterDescriptionDescriptor> onMapped)
        {
            var sourceSynchSupport = source as IReporterDescriptionDescriptorSynchronizationSourceSupport;
            var targetSynchSupport = target as IReporterDescriptionDescriptorSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.ReporterDescriptionDescriptorId = source.ReporterDescriptionDescriptorId;

            // Copy inherited non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsEffectiveBeginDateSupported)
                target.EffectiveBeginDate = source.EffectiveBeginDate;
            else
                targetSynchSupport.IsEffectiveBeginDateSupported = false;

            if (sourceSynchSupport.IsEffectiveEndDateSupported)
                target.EffectiveEndDate = source.EffectiveEndDate;
            else
                targetSynchSupport.IsEffectiveEndDateSupported = false;

            if (sourceSynchSupport.IsNamespaceSupported)
                target.Namespace = source.Namespace;
            else
                targetSynchSupport.IsNamespaceSupported = false;

            if (sourceSynchSupport.IsPriorDescriptorIdSupported)
                target.PriorDescriptorId = source.PriorDescriptorId;
            else
                targetSynchSupport.IsPriorDescriptorIdSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Copy non-PK properties

            if (sourceSynchSupport.IsReporterDescriptionTypeSupported)
                target.ReporterDescriptionType = source.ReporterDescriptionType;
            else
                targetSynchSupport.IsReporterDescriptionTypeSupported = false;

            // Map inherited lists

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IReporterDescriptionDescriptorSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsEffectiveBeginDateSupported { get; set; }
        bool IsEffectiveEndDateSupported { get; set; }
        bool IsNamespaceSupported { get; set; }
        bool IsPriorDescriptorIdSupported { get; set; }
        bool IsReporterDescriptionTypeSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: ReporterDescriptionType

namespace EdFi.Ods.Entities.Common //.ReporterDescriptionTypeAggregate
{ 
    public static class ReporterDescriptionTypeMapper 
    {
        public static bool SynchronizeTo(this IReporterDescriptionType source, IReporterDescriptionType target)
        {
            bool isModified = false;

            var sourceSupport = source as IReporterDescriptionTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.ReporterDescriptionTypeId != target.ReporterDescriptionTypeId)
            {
                source.ReporterDescriptionTypeId = target.ReporterDescriptionTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IReporterDescriptionType source, IReporterDescriptionType target, Action<IReporterDescriptionType, IReporterDescriptionType> onMapped)
        {
            var sourceSynchSupport = source as IReporterDescriptionTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IReporterDescriptionTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.ReporterDescriptionTypeId = source.ReporterDescriptionTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IReporterDescriptionTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: ResidencyStatusDescriptor

namespace EdFi.Ods.Entities.Common //.ResidencyStatusDescriptorAggregate
{ 
    public static class ResidencyStatusDescriptorMapper 
    {
        public static bool SynchronizeTo(this IResidencyStatusDescriptor source, IResidencyStatusDescriptor target)
        {
            bool isModified = false;

            var sourceSupport = source as IResidencyStatusDescriptorSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.ResidencyStatusDescriptorId != target.ResidencyStatusDescriptorId)
            {
                source.ResidencyStatusDescriptorId = target.ResidencyStatusDescriptorId;
            }

            // Copy inherited non-PK properties


            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveBeginDateSupported)
                && target.EffectiveBeginDate != source.EffectiveBeginDate)
            {
                target.EffectiveBeginDate = source.EffectiveBeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveEndDateSupported)
                && target.EffectiveEndDate != source.EffectiveEndDate)
            {
                target.EffectiveEndDate = source.EffectiveEndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNamespaceSupported)
                && target.Namespace != source.Namespace)
            {
                target.Namespace = source.Namespace;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPriorDescriptorIdSupported)
                && target.PriorDescriptorId != source.PriorDescriptorId)
            {
                target.PriorDescriptorId = source.PriorDescriptorId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsResidencyStatusTypeSupported)
                && target.ResidencyStatusType != source.ResidencyStatusType)
            {
                target.ResidencyStatusType = source.ResidencyStatusType;
                isModified = true;
            }

            // Synch inherited lists


            // Sync lists

            return isModified;
        }



        public static void MapTo(this IResidencyStatusDescriptor source, IResidencyStatusDescriptor target, Action<IResidencyStatusDescriptor, IResidencyStatusDescriptor> onMapped)
        {
            var sourceSynchSupport = source as IResidencyStatusDescriptorSynchronizationSourceSupport;
            var targetSynchSupport = target as IResidencyStatusDescriptorSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.ResidencyStatusDescriptorId = source.ResidencyStatusDescriptorId;

            // Copy inherited non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsEffectiveBeginDateSupported)
                target.EffectiveBeginDate = source.EffectiveBeginDate;
            else
                targetSynchSupport.IsEffectiveBeginDateSupported = false;

            if (sourceSynchSupport.IsEffectiveEndDateSupported)
                target.EffectiveEndDate = source.EffectiveEndDate;
            else
                targetSynchSupport.IsEffectiveEndDateSupported = false;

            if (sourceSynchSupport.IsNamespaceSupported)
                target.Namespace = source.Namespace;
            else
                targetSynchSupport.IsNamespaceSupported = false;

            if (sourceSynchSupport.IsPriorDescriptorIdSupported)
                target.PriorDescriptorId = source.PriorDescriptorId;
            else
                targetSynchSupport.IsPriorDescriptorIdSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Copy non-PK properties

            if (sourceSynchSupport.IsResidencyStatusTypeSupported)
                target.ResidencyStatusType = source.ResidencyStatusType;
            else
                targetSynchSupport.IsResidencyStatusTypeSupported = false;

            // Map inherited lists

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IResidencyStatusDescriptorSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsEffectiveBeginDateSupported { get; set; }
        bool IsEffectiveEndDateSupported { get; set; }
        bool IsNamespaceSupported { get; set; }
        bool IsPriorDescriptorIdSupported { get; set; }
        bool IsResidencyStatusTypeSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: ResidencyStatusType

namespace EdFi.Ods.Entities.Common //.ResidencyStatusTypeAggregate
{ 
    public static class ResidencyStatusTypeMapper 
    {
        public static bool SynchronizeTo(this IResidencyStatusType source, IResidencyStatusType target)
        {
            bool isModified = false;

            var sourceSupport = source as IResidencyStatusTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.ResidencyStatusTypeId != target.ResidencyStatusTypeId)
            {
                source.ResidencyStatusTypeId = target.ResidencyStatusTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IResidencyStatusType source, IResidencyStatusType target, Action<IResidencyStatusType, IResidencyStatusType> onMapped)
        {
            var sourceSynchSupport = source as IResidencyStatusTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IResidencyStatusTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.ResidencyStatusTypeId = source.ResidencyStatusTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IResidencyStatusTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: ResponseIndicatorType

namespace EdFi.Ods.Entities.Common //.ResponseIndicatorTypeAggregate
{ 
    public static class ResponseIndicatorTypeMapper 
    {
        public static bool SynchronizeTo(this IResponseIndicatorType source, IResponseIndicatorType target)
        {
            bool isModified = false;

            var sourceSupport = source as IResponseIndicatorTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.ResponseIndicatorTypeId != target.ResponseIndicatorTypeId)
            {
                source.ResponseIndicatorTypeId = target.ResponseIndicatorTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IResponseIndicatorType source, IResponseIndicatorType target, Action<IResponseIndicatorType, IResponseIndicatorType> onMapped)
        {
            var sourceSynchSupport = source as IResponseIndicatorTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IResponseIndicatorTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.ResponseIndicatorTypeId = source.ResponseIndicatorTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IResponseIndicatorTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: ResponsibilityDescriptor

namespace EdFi.Ods.Entities.Common //.ResponsibilityDescriptorAggregate
{ 
    public static class ResponsibilityDescriptorMapper 
    {
        public static bool SynchronizeTo(this IResponsibilityDescriptor source, IResponsibilityDescriptor target)
        {
            bool isModified = false;

            var sourceSupport = source as IResponsibilityDescriptorSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.ResponsibilityDescriptorId != target.ResponsibilityDescriptorId)
            {
                source.ResponsibilityDescriptorId = target.ResponsibilityDescriptorId;
            }

            // Copy inherited non-PK properties


            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveBeginDateSupported)
                && target.EffectiveBeginDate != source.EffectiveBeginDate)
            {
                target.EffectiveBeginDate = source.EffectiveBeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveEndDateSupported)
                && target.EffectiveEndDate != source.EffectiveEndDate)
            {
                target.EffectiveEndDate = source.EffectiveEndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNamespaceSupported)
                && target.Namespace != source.Namespace)
            {
                target.Namespace = source.Namespace;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPriorDescriptorIdSupported)
                && target.PriorDescriptorId != source.PriorDescriptorId)
            {
                target.PriorDescriptorId = source.PriorDescriptorId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsResponsibilityTypeSupported)
                && target.ResponsibilityType != source.ResponsibilityType)
            {
                target.ResponsibilityType = source.ResponsibilityType;
                isModified = true;
            }

            // Synch inherited lists


            // Sync lists

            return isModified;
        }



        public static void MapTo(this IResponsibilityDescriptor source, IResponsibilityDescriptor target, Action<IResponsibilityDescriptor, IResponsibilityDescriptor> onMapped)
        {
            var sourceSynchSupport = source as IResponsibilityDescriptorSynchronizationSourceSupport;
            var targetSynchSupport = target as IResponsibilityDescriptorSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.ResponsibilityDescriptorId = source.ResponsibilityDescriptorId;

            // Copy inherited non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsEffectiveBeginDateSupported)
                target.EffectiveBeginDate = source.EffectiveBeginDate;
            else
                targetSynchSupport.IsEffectiveBeginDateSupported = false;

            if (sourceSynchSupport.IsEffectiveEndDateSupported)
                target.EffectiveEndDate = source.EffectiveEndDate;
            else
                targetSynchSupport.IsEffectiveEndDateSupported = false;

            if (sourceSynchSupport.IsNamespaceSupported)
                target.Namespace = source.Namespace;
            else
                targetSynchSupport.IsNamespaceSupported = false;

            if (sourceSynchSupport.IsPriorDescriptorIdSupported)
                target.PriorDescriptorId = source.PriorDescriptorId;
            else
                targetSynchSupport.IsPriorDescriptorIdSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Copy non-PK properties

            if (sourceSynchSupport.IsResponsibilityTypeSupported)
                target.ResponsibilityType = source.ResponsibilityType;
            else
                targetSynchSupport.IsResponsibilityTypeSupported = false;

            // Map inherited lists

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IResponsibilityDescriptorSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsEffectiveBeginDateSupported { get; set; }
        bool IsEffectiveEndDateSupported { get; set; }
        bool IsNamespaceSupported { get; set; }
        bool IsPriorDescriptorIdSupported { get; set; }
        bool IsResponsibilityTypeSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: ResponsibilityType

namespace EdFi.Ods.Entities.Common //.ResponsibilityTypeAggregate
{ 
    public static class ResponsibilityTypeMapper 
    {
        public static bool SynchronizeTo(this IResponsibilityType source, IResponsibilityType target)
        {
            bool isModified = false;

            var sourceSupport = source as IResponsibilityTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.ResponsibilityTypeId != target.ResponsibilityTypeId)
            {
                source.ResponsibilityTypeId = target.ResponsibilityTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IResponsibilityType source, IResponsibilityType target, Action<IResponsibilityType, IResponsibilityType> onMapped)
        {
            var sourceSynchSupport = source as IResponsibilityTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IResponsibilityTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.ResponsibilityTypeId = source.ResponsibilityTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IResponsibilityTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: RestraintEvent

namespace EdFi.Ods.Entities.Common //.RestraintEventAggregate
{ 
    public static class RestraintEventMapper 
    {
        public static bool SynchronizeTo(this IRestraintEvent source, IRestraintEvent target)
        {
            bool isModified = false;

            var sourceSupport = source as IRestraintEventSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.EventDate != target.EventDate)
            {
                source.EventDate = target.EventDate;
            }
            if (source.RestraintEventIdentifier != target.RestraintEventIdentifier)
            {
                source.RestraintEventIdentifier = target.RestraintEventIdentifier;
            }
            if (source.SchoolId != target.SchoolId)
            {
                source.SchoolId = target.SchoolId;
            }
            if (source.StudentUniqueId != target.StudentUniqueId)
            {
                source.StudentUniqueId = target.StudentUniqueId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsEducationalEnvironmentTypeSupported)
                && target.EducationalEnvironmentType != source.EducationalEnvironmentType)
            {
                target.EducationalEnvironmentType = source.EducationalEnvironmentType;
                isModified = true;
            }



            // Sync lists
            if (sourceSupport == null || sourceSupport.IsRestraintEventProgramsSupported)
                isModified |= source.RestraintEventPrograms.SynchronizeListTo(target.RestraintEventPrograms, child => child.RestraintEvent = target,
                                sourceSupport == null ? null : sourceSupport.IsRestraintEventProgramIncluded);

            if (sourceSupport == null || sourceSupport.IsRestraintEventReasonsSupported)
                isModified |= source.RestraintEventReasons.SynchronizeListTo(target.RestraintEventReasons, child => child.RestraintEvent = target,
                                sourceSupport == null ? null : sourceSupport.IsRestraintEventReasonIncluded);


            return isModified;
        }



        public static void MapTo(this IRestraintEvent source, IRestraintEvent target, Action<IRestraintEvent, IRestraintEvent> onMapped)
        {
            var sourceSynchSupport = source as IRestraintEventSynchronizationSourceSupport;
            var targetSynchSupport = target as IRestraintEventSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.EventDate = source.EventDate;
            target.RestraintEventIdentifier = source.RestraintEventIdentifier;
            target.SchoolId = source.SchoolId;
            target.StudentUniqueId = source.StudentUniqueId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsEducationalEnvironmentTypeSupported)
                target.EducationalEnvironmentType = source.EducationalEnvironmentType;
            else
                targetSynchSupport.IsEducationalEnvironmentTypeSupported = false;

            // Map lists

            if (sourceSynchSupport.IsRestraintEventProgramsSupported)
            {    
                targetSynchSupport.IsRestraintEventProgramIncluded = sourceSynchSupport.IsRestraintEventProgramIncluded;
                source.RestraintEventPrograms.MapListTo(target.RestraintEventPrograms);
            }
            else
            {
                targetSynchSupport.IsRestraintEventProgramsSupported = false;
            }

            if (sourceSynchSupport.IsRestraintEventReasonsSupported)
            {    
                targetSynchSupport.IsRestraintEventReasonIncluded = sourceSynchSupport.IsRestraintEventReasonIncluded;
                source.RestraintEventReasons.MapListTo(target.RestraintEventReasons);
            }
            else
            {
                targetSynchSupport.IsRestraintEventReasonsSupported = false;
            }

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IRestraintEventSynchronizationSourceSupport
    {
        bool IsEducationalEnvironmentTypeSupported { get; set; }
        bool IsRestraintEventProgramsSupported { get; set; }
        bool IsRestraintEventReasonsSupported { get; set; }
        Func<IRestraintEventProgram, bool> IsRestraintEventProgramIncluded { get; set; }
        Func<IRestraintEventReason, bool> IsRestraintEventReasonIncluded { get; set; }
    }
 
    public static class RestraintEventProgramMapper 
    {
        public static bool SynchronizeTo(this IRestraintEventProgram source, IRestraintEventProgram target)
        {
            bool isModified = false;

            var sourceSupport = source as IRestraintEventProgramSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.EducationOrganizationId != target.EducationOrganizationId)
            {
                source.EducationOrganizationId = target.EducationOrganizationId;
            }
            if (source.ProgramName != target.ProgramName)
            {
                source.ProgramName = target.ProgramName;
            }
            if (source.ProgramType != target.ProgramType)
            {
                source.ProgramType = target.ProgramType;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IRestraintEventProgram source, IRestraintEventProgram target, Action<IRestraintEventProgram, IRestraintEventProgram> onMapped)
        {
            var sourceSynchSupport = source as IRestraintEventProgramSynchronizationSourceSupport;
            var targetSynchSupport = target as IRestraintEventProgramSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.EducationOrganizationId = source.EducationOrganizationId;
            target.ProgramName = source.ProgramName;
            target.ProgramType = source.ProgramType;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IRestraintEventProgramSynchronizationSourceSupport
    {
    }
 
    public static class RestraintEventReasonMapper 
    {
        public static bool SynchronizeTo(this IRestraintEventReason source, IRestraintEventReason target)
        {
            bool isModified = false;

            var sourceSupport = source as IRestraintEventReasonSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.RestraintEventReasonType != target.RestraintEventReasonType)
            {
                source.RestraintEventReasonType = target.RestraintEventReasonType;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IRestraintEventReason source, IRestraintEventReason target, Action<IRestraintEventReason, IRestraintEventReason> onMapped)
        {
            var sourceSynchSupport = source as IRestraintEventReasonSynchronizationSourceSupport;
            var targetSynchSupport = target as IRestraintEventReasonSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.RestraintEventReasonType = source.RestraintEventReasonType;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IRestraintEventReasonSynchronizationSourceSupport
    {
    }
 
}
// Aggregate: RestraintEventReasonType

namespace EdFi.Ods.Entities.Common //.RestraintEventReasonTypeAggregate
{ 
    public static class RestraintEventReasonTypeMapper 
    {
        public static bool SynchronizeTo(this IRestraintEventReasonType source, IRestraintEventReasonType target)
        {
            bool isModified = false;

            var sourceSupport = source as IRestraintEventReasonTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.RestraintEventReasonTypeId != target.RestraintEventReasonTypeId)
            {
                source.RestraintEventReasonTypeId = target.RestraintEventReasonTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IRestraintEventReasonType source, IRestraintEventReasonType target, Action<IRestraintEventReasonType, IRestraintEventReasonType> onMapped)
        {
            var sourceSynchSupport = source as IRestraintEventReasonTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IRestraintEventReasonTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.RestraintEventReasonTypeId = source.RestraintEventReasonTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IRestraintEventReasonTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: ResultDatatypeType

namespace EdFi.Ods.Entities.Common //.ResultDatatypeTypeAggregate
{ 
    public static class ResultDatatypeTypeMapper 
    {
        public static bool SynchronizeTo(this IResultDatatypeType source, IResultDatatypeType target)
        {
            bool isModified = false;

            var sourceSupport = source as IResultDatatypeTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.ResultDatatypeTypeId != target.ResultDatatypeTypeId)
            {
                source.ResultDatatypeTypeId = target.ResultDatatypeTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IResultDatatypeType source, IResultDatatypeType target, Action<IResultDatatypeType, IResultDatatypeType> onMapped)
        {
            var sourceSynchSupport = source as IResultDatatypeTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IResultDatatypeTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.ResultDatatypeTypeId = source.ResultDatatypeTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IResultDatatypeTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: RetestIndicatorType

namespace EdFi.Ods.Entities.Common //.RetestIndicatorTypeAggregate
{ 
    public static class RetestIndicatorTypeMapper 
    {
        public static bool SynchronizeTo(this IRetestIndicatorType source, IRetestIndicatorType target)
        {
            bool isModified = false;

            var sourceSupport = source as IRetestIndicatorTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.RetestIndicatorTypeId != target.RetestIndicatorTypeId)
            {
                source.RetestIndicatorTypeId = target.RetestIndicatorTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IRetestIndicatorType source, IRetestIndicatorType target, Action<IRetestIndicatorType, IRetestIndicatorType> onMapped)
        {
            var sourceSynchSupport = source as IRetestIndicatorTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IRetestIndicatorTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.RetestIndicatorTypeId = source.RetestIndicatorTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IRetestIndicatorTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: School

namespace EdFi.Ods.Entities.Common //.SchoolAggregate
{ 
    public static class SchoolMapper 
    {
        public static bool SynchronizeTo(this ISchool source, ISchool target)
        {
            bool isModified = false;

            var sourceSupport = source as ISchoolSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.SchoolId != target.SchoolId)
            {
                source.SchoolId = target.SchoolId;
            }

            // Copy inherited non-PK properties


            if ((sourceSupport == null || sourceSupport.IsNameOfInstitutionSupported)
                && target.NameOfInstitution != source.NameOfInstitution)
            {
                target.NameOfInstitution = source.NameOfInstitution;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsOperationalStatusTypeSupported)
                && target.OperationalStatusType != source.OperationalStatusType)
            {
                target.OperationalStatusType = source.OperationalStatusType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortNameOfInstitutionSupported)
                && target.ShortNameOfInstitution != source.ShortNameOfInstitution)
            {
                target.ShortNameOfInstitution = source.ShortNameOfInstitution;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsStateOrganizationIdSupported)
                && target.StateOrganizationId != source.StateOrganizationId)
            {
                target.StateOrganizationId = source.StateOrganizationId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsWebSiteSupported)
                && target.WebSite != source.WebSite)
            {
                target.WebSite = source.WebSite;
                isModified = true;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsAdministrativeFundingControlDescriptorSupported)
                && target.AdministrativeFundingControlDescriptor != source.AdministrativeFundingControlDescriptor)
            {
                target.AdministrativeFundingControlDescriptor = source.AdministrativeFundingControlDescriptor;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsCharterApprovalAgencyTypeSupported)
                && target.CharterApprovalAgencyType != source.CharterApprovalAgencyType)
            {
                target.CharterApprovalAgencyType = source.CharterApprovalAgencyType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsCharterApprovalSchoolYearSupported)
                && target.CharterApprovalSchoolYear != source.CharterApprovalSchoolYear)
            {
                target.CharterApprovalSchoolYear = source.CharterApprovalSchoolYear;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsCharterStatusTypeSupported)
                && target.CharterStatusType != source.CharterStatusType)
            {
                target.CharterStatusType = source.CharterStatusType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsInternetAccessTypeSupported)
                && target.InternetAccessType != source.InternetAccessType)
            {
                target.InternetAccessType = source.InternetAccessType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsLocalEducationAgencyIdSupported)
                && target.LocalEducationAgencyId != source.LocalEducationAgencyId)
            {
                target.LocalEducationAgencyId = source.LocalEducationAgencyId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsMagnetSpecialProgramEmphasisSchoolTypeSupported)
                && target.MagnetSpecialProgramEmphasisSchoolType != source.MagnetSpecialProgramEmphasisSchoolType)
            {
                target.MagnetSpecialProgramEmphasisSchoolType = source.MagnetSpecialProgramEmphasisSchoolType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsSchoolTypeSupported)
                && target.SchoolType != source.SchoolType)
            {
                target.SchoolType = source.SchoolType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsTitleIPartASchoolDesignationTypeSupported)
                && target.TitleIPartASchoolDesignationType != source.TitleIPartASchoolDesignationType)
            {
                target.TitleIPartASchoolDesignationType = source.TitleIPartASchoolDesignationType;
                isModified = true;
            }

            // Synch inherited lists
            if (sourceSupport == null || sourceSupport.IsEducationOrganizationAddressesSupported)
                isModified |= source.EducationOrganizationAddresses.SynchronizeListTo(target.EducationOrganizationAddresses, child => child.EducationOrganization = target,
                                sourceSupport == null ? null : sourceSupport.IsEducationOrganizationAddressIncluded);

            if (sourceSupport == null || sourceSupport.IsEducationOrganizationCategoriesSupported)
                isModified |= source.EducationOrganizationCategories.SynchronizeListTo(target.EducationOrganizationCategories, child => child.EducationOrganization = target,
                                sourceSupport == null ? null : sourceSupport.IsEducationOrganizationCategoryIncluded);

            if (sourceSupport == null || sourceSupport.IsEducationOrganizationIdentificationCodesSupported)
                isModified |= source.EducationOrganizationIdentificationCodes.SynchronizeListTo(target.EducationOrganizationIdentificationCodes, child => child.EducationOrganization = target,
                                sourceSupport == null ? null : sourceSupport.IsEducationOrganizationIdentificationCodeIncluded);

            if (sourceSupport == null || sourceSupport.IsEducationOrganizationInstitutionTelephonesSupported)
                isModified |= source.EducationOrganizationInstitutionTelephones.SynchronizeListTo(target.EducationOrganizationInstitutionTelephones, child => child.EducationOrganization = target,
                                sourceSupport == null ? null : sourceSupport.IsEducationOrganizationInstitutionTelephoneIncluded);

            if (sourceSupport == null || sourceSupport.IsEducationOrganizationInternationalAddressesSupported)
                isModified |= source.EducationOrganizationInternationalAddresses.SynchronizeListTo(target.EducationOrganizationInternationalAddresses, child => child.EducationOrganization = target,
                                sourceSupport == null ? null : sourceSupport.IsEducationOrganizationInternationalAddressIncluded);



            // Sync lists
            if (sourceSupport == null || sourceSupport.IsSchoolCategoriesSupported)
                isModified |= source.SchoolCategories.SynchronizeListTo(target.SchoolCategories, child => child.School = target,
                                sourceSupport == null ? null : sourceSupport.IsSchoolCategoryIncluded);

            if (sourceSupport == null || sourceSupport.IsSchoolGradeLevelsSupported)
                isModified |= source.SchoolGradeLevels.SynchronizeListTo(target.SchoolGradeLevels, child => child.School = target,
                                sourceSupport == null ? null : sourceSupport.IsSchoolGradeLevelIncluded);


            return isModified;
        }



        public static void MapTo(this ISchool source, ISchool target, Action<ISchool, ISchool> onMapped)
        {
            var sourceSynchSupport = source as ISchoolSynchronizationSourceSupport;
            var targetSynchSupport = target as ISchoolSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.SchoolId = source.SchoolId;

            // Copy inherited non-PK properties

            if (sourceSynchSupport.IsNameOfInstitutionSupported)
                target.NameOfInstitution = source.NameOfInstitution;
            else
                targetSynchSupport.IsNameOfInstitutionSupported = false;

            if (sourceSynchSupport.IsOperationalStatusTypeSupported)
                target.OperationalStatusType = source.OperationalStatusType;
            else
                targetSynchSupport.IsOperationalStatusTypeSupported = false;

            if (sourceSynchSupport.IsShortNameOfInstitutionSupported)
                target.ShortNameOfInstitution = source.ShortNameOfInstitution;
            else
                targetSynchSupport.IsShortNameOfInstitutionSupported = false;

            if (sourceSynchSupport.IsStateOrganizationIdSupported)
                target.StateOrganizationId = source.StateOrganizationId;
            else
                targetSynchSupport.IsStateOrganizationIdSupported = false;

            if (sourceSynchSupport.IsWebSiteSupported)
                target.WebSite = source.WebSite;
            else
                targetSynchSupport.IsWebSiteSupported = false;

            // Copy non-PK properties

            if (sourceSynchSupport.IsAdministrativeFundingControlDescriptorSupported)
                target.AdministrativeFundingControlDescriptor = source.AdministrativeFundingControlDescriptor;
            else
                targetSynchSupport.IsAdministrativeFundingControlDescriptorSupported = false;

            if (sourceSynchSupport.IsCharterApprovalAgencyTypeSupported)
                target.CharterApprovalAgencyType = source.CharterApprovalAgencyType;
            else
                targetSynchSupport.IsCharterApprovalAgencyTypeSupported = false;

            if (sourceSynchSupport.IsCharterApprovalSchoolYearSupported)
                target.CharterApprovalSchoolYear = source.CharterApprovalSchoolYear;
            else
                targetSynchSupport.IsCharterApprovalSchoolYearSupported = false;

            if (sourceSynchSupport.IsCharterStatusTypeSupported)
                target.CharterStatusType = source.CharterStatusType;
            else
                targetSynchSupport.IsCharterStatusTypeSupported = false;

            if (sourceSynchSupport.IsInternetAccessTypeSupported)
                target.InternetAccessType = source.InternetAccessType;
            else
                targetSynchSupport.IsInternetAccessTypeSupported = false;

            if (sourceSynchSupport.IsLocalEducationAgencyIdSupported)
                target.LocalEducationAgencyId = source.LocalEducationAgencyId;
            else
                targetSynchSupport.IsLocalEducationAgencyIdSupported = false;

            if (sourceSynchSupport.IsMagnetSpecialProgramEmphasisSchoolTypeSupported)
                target.MagnetSpecialProgramEmphasisSchoolType = source.MagnetSpecialProgramEmphasisSchoolType;
            else
                targetSynchSupport.IsMagnetSpecialProgramEmphasisSchoolTypeSupported = false;

            if (sourceSynchSupport.IsSchoolTypeSupported)
                target.SchoolType = source.SchoolType;
            else
                targetSynchSupport.IsSchoolTypeSupported = false;

            if (sourceSynchSupport.IsTitleIPartASchoolDesignationTypeSupported)
                target.TitleIPartASchoolDesignationType = source.TitleIPartASchoolDesignationType;
            else
                targetSynchSupport.IsTitleIPartASchoolDesignationTypeSupported = false;

            // Map inherited lists

            if (sourceSynchSupport.IsEducationOrganizationAddressesSupported)
            {
                targetSynchSupport.IsEducationOrganizationAddressIncluded = sourceSynchSupport.IsEducationOrganizationAddressIncluded;
                source.EducationOrganizationAddresses.MapListTo(target.EducationOrganizationAddresses);
            }
            else
            {
                targetSynchSupport.IsEducationOrganizationAddressesSupported = false;
            }

            if (sourceSynchSupport.IsEducationOrganizationCategoriesSupported)
            {
                targetSynchSupport.IsEducationOrganizationCategoryIncluded = sourceSynchSupport.IsEducationOrganizationCategoryIncluded;
                source.EducationOrganizationCategories.MapListTo(target.EducationOrganizationCategories);
            }
            else
            {
                targetSynchSupport.IsEducationOrganizationCategoriesSupported = false;
            }

            if (sourceSynchSupport.IsEducationOrganizationIdentificationCodesSupported)
            {
                targetSynchSupport.IsEducationOrganizationIdentificationCodeIncluded = sourceSynchSupport.IsEducationOrganizationIdentificationCodeIncluded;
                source.EducationOrganizationIdentificationCodes.MapListTo(target.EducationOrganizationIdentificationCodes);
            }
            else
            {
                targetSynchSupport.IsEducationOrganizationIdentificationCodesSupported = false;
            }

            if (sourceSynchSupport.IsEducationOrganizationInstitutionTelephonesSupported)
            {
                targetSynchSupport.IsEducationOrganizationInstitutionTelephoneIncluded = sourceSynchSupport.IsEducationOrganizationInstitutionTelephoneIncluded;
                source.EducationOrganizationInstitutionTelephones.MapListTo(target.EducationOrganizationInstitutionTelephones);
            }
            else
            {
                targetSynchSupport.IsEducationOrganizationInstitutionTelephonesSupported = false;
            }

            if (sourceSynchSupport.IsEducationOrganizationInternationalAddressesSupported)
            {
                targetSynchSupport.IsEducationOrganizationInternationalAddressIncluded = sourceSynchSupport.IsEducationOrganizationInternationalAddressIncluded;
                source.EducationOrganizationInternationalAddresses.MapListTo(target.EducationOrganizationInternationalAddresses);
            }
            else
            {
                targetSynchSupport.IsEducationOrganizationInternationalAddressesSupported = false;
            }

            // Map lists

            if (sourceSynchSupport.IsSchoolCategoriesSupported)
            {    
                targetSynchSupport.IsSchoolCategoryIncluded = sourceSynchSupport.IsSchoolCategoryIncluded;
                source.SchoolCategories.MapListTo(target.SchoolCategories);
            }
            else
            {
                targetSynchSupport.IsSchoolCategoriesSupported = false;
            }

            if (sourceSynchSupport.IsSchoolGradeLevelsSupported)
            {    
                targetSynchSupport.IsSchoolGradeLevelIncluded = sourceSynchSupport.IsSchoolGradeLevelIncluded;
                source.SchoolGradeLevels.MapListTo(target.SchoolGradeLevels);
            }
            else
            {
                targetSynchSupport.IsSchoolGradeLevelsSupported = false;
            }

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ISchoolSynchronizationSourceSupport
    {
        bool IsAdministrativeFundingControlDescriptorSupported { get; set; }
        bool IsCharterApprovalAgencyTypeSupported { get; set; }
        bool IsCharterApprovalSchoolYearSupported { get; set; }
        bool IsCharterStatusTypeSupported { get; set; }
        bool IsEducationOrganizationAddressesSupported { get; set; }
        bool IsEducationOrganizationCategoriesSupported { get; set; }
        bool IsEducationOrganizationIdentificationCodesSupported { get; set; }
        bool IsEducationOrganizationInstitutionTelephonesSupported { get; set; }
        bool IsEducationOrganizationInternationalAddressesSupported { get; set; }
        bool IsInternetAccessTypeSupported { get; set; }
        bool IsLocalEducationAgencyIdSupported { get; set; }
        bool IsMagnetSpecialProgramEmphasisSchoolTypeSupported { get; set; }
        bool IsNameOfInstitutionSupported { get; set; }
        bool IsOperationalStatusTypeSupported { get; set; }
        bool IsSchoolCategoriesSupported { get; set; }
        bool IsSchoolGradeLevelsSupported { get; set; }
        bool IsSchoolTypeSupported { get; set; }
        bool IsShortNameOfInstitutionSupported { get; set; }
        bool IsStateOrganizationIdSupported { get; set; }
        bool IsTitleIPartASchoolDesignationTypeSupported { get; set; }
        bool IsWebSiteSupported { get; set; }
        Func<IEducationOrganizationAddress, bool> IsEducationOrganizationAddressIncluded { get; set; }
        Func<IEducationOrganizationCategory, bool> IsEducationOrganizationCategoryIncluded { get; set; }
        Func<IEducationOrganizationIdentificationCode, bool> IsEducationOrganizationIdentificationCodeIncluded { get; set; }
        Func<IEducationOrganizationInstitutionTelephone, bool> IsEducationOrganizationInstitutionTelephoneIncluded { get; set; }
        Func<IEducationOrganizationInternationalAddress, bool> IsEducationOrganizationInternationalAddressIncluded { get; set; }
        Func<ISchoolCategory, bool> IsSchoolCategoryIncluded { get; set; }
        Func<ISchoolGradeLevel, bool> IsSchoolGradeLevelIncluded { get; set; }
    }
 
    public static class SchoolCategoryMapper 
    {
        public static bool SynchronizeTo(this ISchoolCategory source, ISchoolCategory target)
        {
            bool isModified = false;

            var sourceSupport = source as ISchoolCategorySynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.SchoolCategoryType != target.SchoolCategoryType)
            {
                source.SchoolCategoryType = target.SchoolCategoryType;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ISchoolCategory source, ISchoolCategory target, Action<ISchoolCategory, ISchoolCategory> onMapped)
        {
            var sourceSynchSupport = source as ISchoolCategorySynchronizationSourceSupport;
            var targetSynchSupport = target as ISchoolCategorySynchronizationSourceSupport;

            // Copy contextual primary key values
            target.SchoolCategoryType = source.SchoolCategoryType;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ISchoolCategorySynchronizationSourceSupport
    {
    }
 
    public static class SchoolGradeLevelMapper 
    {
        public static bool SynchronizeTo(this ISchoolGradeLevel source, ISchoolGradeLevel target)
        {
            bool isModified = false;

            var sourceSupport = source as ISchoolGradeLevelSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.GradeLevelDescriptor != target.GradeLevelDescriptor)
            {
                source.GradeLevelDescriptor = target.GradeLevelDescriptor;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ISchoolGradeLevel source, ISchoolGradeLevel target, Action<ISchoolGradeLevel, ISchoolGradeLevel> onMapped)
        {
            var sourceSynchSupport = source as ISchoolGradeLevelSynchronizationSourceSupport;
            var targetSynchSupport = target as ISchoolGradeLevelSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.GradeLevelDescriptor = source.GradeLevelDescriptor;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ISchoolGradeLevelSynchronizationSourceSupport
    {
    }
 
}
// Aggregate: SchoolCategoryType

namespace EdFi.Ods.Entities.Common //.SchoolCategoryTypeAggregate
{ 
    public static class SchoolCategoryTypeMapper 
    {
        public static bool SynchronizeTo(this ISchoolCategoryType source, ISchoolCategoryType target)
        {
            bool isModified = false;

            var sourceSupport = source as ISchoolCategoryTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.SchoolCategoryTypeId != target.SchoolCategoryTypeId)
            {
                source.SchoolCategoryTypeId = target.SchoolCategoryTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ISchoolCategoryType source, ISchoolCategoryType target, Action<ISchoolCategoryType, ISchoolCategoryType> onMapped)
        {
            var sourceSynchSupport = source as ISchoolCategoryTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as ISchoolCategoryTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.SchoolCategoryTypeId = source.SchoolCategoryTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ISchoolCategoryTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: SchoolChoiceImplementStatusType

namespace EdFi.Ods.Entities.Common //.SchoolChoiceImplementStatusTypeAggregate
{ 
    public static class SchoolChoiceImplementStatusTypeMapper 
    {
        public static bool SynchronizeTo(this ISchoolChoiceImplementStatusType source, ISchoolChoiceImplementStatusType target)
        {
            bool isModified = false;

            var sourceSupport = source as ISchoolChoiceImplementStatusTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.SchoolChoiceImplementStatusTypeId != target.SchoolChoiceImplementStatusTypeId)
            {
                source.SchoolChoiceImplementStatusTypeId = target.SchoolChoiceImplementStatusTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ISchoolChoiceImplementStatusType source, ISchoolChoiceImplementStatusType target, Action<ISchoolChoiceImplementStatusType, ISchoolChoiceImplementStatusType> onMapped)
        {
            var sourceSynchSupport = source as ISchoolChoiceImplementStatusTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as ISchoolChoiceImplementStatusTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.SchoolChoiceImplementStatusTypeId = source.SchoolChoiceImplementStatusTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ISchoolChoiceImplementStatusTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: SchoolFoodServicesEligibilityDescriptor

namespace EdFi.Ods.Entities.Common //.SchoolFoodServicesEligibilityDescriptorAggregate
{ 
    public static class SchoolFoodServicesEligibilityDescriptorMapper 
    {
        public static bool SynchronizeTo(this ISchoolFoodServicesEligibilityDescriptor source, ISchoolFoodServicesEligibilityDescriptor target)
        {
            bool isModified = false;

            var sourceSupport = source as ISchoolFoodServicesEligibilityDescriptorSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.SchoolFoodServicesEligibilityDescriptorId != target.SchoolFoodServicesEligibilityDescriptorId)
            {
                source.SchoolFoodServicesEligibilityDescriptorId = target.SchoolFoodServicesEligibilityDescriptorId;
            }

            // Copy inherited non-PK properties


            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveBeginDateSupported)
                && target.EffectiveBeginDate != source.EffectiveBeginDate)
            {
                target.EffectiveBeginDate = source.EffectiveBeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveEndDateSupported)
                && target.EffectiveEndDate != source.EffectiveEndDate)
            {
                target.EffectiveEndDate = source.EffectiveEndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNamespaceSupported)
                && target.Namespace != source.Namespace)
            {
                target.Namespace = source.Namespace;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPriorDescriptorIdSupported)
                && target.PriorDescriptorId != source.PriorDescriptorId)
            {
                target.PriorDescriptorId = source.PriorDescriptorId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsSchoolFoodServicesEligibilityTypeSupported)
                && target.SchoolFoodServicesEligibilityType != source.SchoolFoodServicesEligibilityType)
            {
                target.SchoolFoodServicesEligibilityType = source.SchoolFoodServicesEligibilityType;
                isModified = true;
            }

            // Synch inherited lists


            // Sync lists

            return isModified;
        }



        public static void MapTo(this ISchoolFoodServicesEligibilityDescriptor source, ISchoolFoodServicesEligibilityDescriptor target, Action<ISchoolFoodServicesEligibilityDescriptor, ISchoolFoodServicesEligibilityDescriptor> onMapped)
        {
            var sourceSynchSupport = source as ISchoolFoodServicesEligibilityDescriptorSynchronizationSourceSupport;
            var targetSynchSupport = target as ISchoolFoodServicesEligibilityDescriptorSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.SchoolFoodServicesEligibilityDescriptorId = source.SchoolFoodServicesEligibilityDescriptorId;

            // Copy inherited non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsEffectiveBeginDateSupported)
                target.EffectiveBeginDate = source.EffectiveBeginDate;
            else
                targetSynchSupport.IsEffectiveBeginDateSupported = false;

            if (sourceSynchSupport.IsEffectiveEndDateSupported)
                target.EffectiveEndDate = source.EffectiveEndDate;
            else
                targetSynchSupport.IsEffectiveEndDateSupported = false;

            if (sourceSynchSupport.IsNamespaceSupported)
                target.Namespace = source.Namespace;
            else
                targetSynchSupport.IsNamespaceSupported = false;

            if (sourceSynchSupport.IsPriorDescriptorIdSupported)
                target.PriorDescriptorId = source.PriorDescriptorId;
            else
                targetSynchSupport.IsPriorDescriptorIdSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Copy non-PK properties

            if (sourceSynchSupport.IsSchoolFoodServicesEligibilityTypeSupported)
                target.SchoolFoodServicesEligibilityType = source.SchoolFoodServicesEligibilityType;
            else
                targetSynchSupport.IsSchoolFoodServicesEligibilityTypeSupported = false;

            // Map inherited lists

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ISchoolFoodServicesEligibilityDescriptorSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsEffectiveBeginDateSupported { get; set; }
        bool IsEffectiveEndDateSupported { get; set; }
        bool IsNamespaceSupported { get; set; }
        bool IsPriorDescriptorIdSupported { get; set; }
        bool IsSchoolFoodServicesEligibilityTypeSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: SchoolFoodServicesEligibilityType

namespace EdFi.Ods.Entities.Common //.SchoolFoodServicesEligibilityTypeAggregate
{ 
    public static class SchoolFoodServicesEligibilityTypeMapper 
    {
        public static bool SynchronizeTo(this ISchoolFoodServicesEligibilityType source, ISchoolFoodServicesEligibilityType target)
        {
            bool isModified = false;

            var sourceSupport = source as ISchoolFoodServicesEligibilityTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.SchoolFoodServicesEligibilityTypeId != target.SchoolFoodServicesEligibilityTypeId)
            {
                source.SchoolFoodServicesEligibilityTypeId = target.SchoolFoodServicesEligibilityTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ISchoolFoodServicesEligibilityType source, ISchoolFoodServicesEligibilityType target, Action<ISchoolFoodServicesEligibilityType, ISchoolFoodServicesEligibilityType> onMapped)
        {
            var sourceSynchSupport = source as ISchoolFoodServicesEligibilityTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as ISchoolFoodServicesEligibilityTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.SchoolFoodServicesEligibilityTypeId = source.SchoolFoodServicesEligibilityTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ISchoolFoodServicesEligibilityTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: SchoolType

namespace EdFi.Ods.Entities.Common //.SchoolTypeAggregate
{ 
    public static class SchoolTypeMapper 
    {
        public static bool SynchronizeTo(this ISchoolType source, ISchoolType target)
        {
            bool isModified = false;

            var sourceSupport = source as ISchoolTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.SchoolTypeId != target.SchoolTypeId)
            {
                source.SchoolTypeId = target.SchoolTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ISchoolType source, ISchoolType target, Action<ISchoolType, ISchoolType> onMapped)
        {
            var sourceSynchSupport = source as ISchoolTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as ISchoolTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.SchoolTypeId = source.SchoolTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ISchoolTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: SchoolYearType

namespace EdFi.Ods.Entities.Common //.SchoolYearTypeAggregate
{ 
    public static class SchoolYearTypeMapper 
    {
        public static bool SynchronizeTo(this ISchoolYearType source, ISchoolYearType target)
        {
            bool isModified = false;

            var sourceSupport = source as ISchoolYearTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.SchoolYear != target.SchoolYear)
            {
                source.SchoolYear = target.SchoolYear;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCurrentSchoolYearSupported)
                && target.CurrentSchoolYear != source.CurrentSchoolYear)
            {
                target.CurrentSchoolYear = source.CurrentSchoolYear;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsSchoolYearDescriptionSupported)
                && target.SchoolYearDescription != source.SchoolYearDescription)
            {
                target.SchoolYearDescription = source.SchoolYearDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ISchoolYearType source, ISchoolYearType target, Action<ISchoolYearType, ISchoolYearType> onMapped)
        {
            var sourceSynchSupport = source as ISchoolYearTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as ISchoolYearTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.SchoolYear = source.SchoolYear;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCurrentSchoolYearSupported)
                target.CurrentSchoolYear = source.CurrentSchoolYear;
            else
                targetSynchSupport.IsCurrentSchoolYearSupported = false;

            if (sourceSynchSupport.IsSchoolYearDescriptionSupported)
                target.SchoolYearDescription = source.SchoolYearDescription;
            else
                targetSynchSupport.IsSchoolYearDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ISchoolYearTypeSynchronizationSourceSupport
    {
        bool IsCurrentSchoolYearSupported { get; set; }
        bool IsSchoolYearDescriptionSupported { get; set; }
    }
 
}
// Aggregate: Section

namespace EdFi.Ods.Entities.Common //.SectionAggregate
{ 
    public static class SectionMapper 
    {
        public static bool SynchronizeTo(this ISection source, ISection target)
        {
            bool isModified = false;

            var sourceSupport = source as ISectionSynchronizationSourceSupport;

            // Allow PK column updates on Section
            if (
                 (target.ClassPeriodName != source.ClassPeriodName)
                || (target.ClassroomIdentificationCode != source.ClassroomIdentificationCode)
                || (target.LocalCourseCode != source.LocalCourseCode)
                || (target.SchoolId != source.SchoolId)
                || (target.SchoolYear != source.SchoolYear)
                || (target.SequenceOfCourse != source.SequenceOfCourse)
                || (target.TermDescriptor != source.TermDescriptor)
                || (target.UniqueSectionCode != source.UniqueSectionCode))
            {            
                isModified = true;

                var sourceWithPrimaryKeyValues = (source as IHasPrimaryKeyValues);

                if (sourceWithPrimaryKeyValues != null)
                {
                    var targetWithNewKeyValues = target as IHasCascadableKeyValues;

                    if (targetWithNewKeyValues != null)
                        targetWithNewKeyValues.NewKeyValues = sourceWithPrimaryKeyValues.GetPrimaryKeyValues();
                }
            }

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.ClassPeriodName != target.ClassPeriodName)
            {
                source.ClassPeriodName = target.ClassPeriodName;
            }
            if (source.ClassroomIdentificationCode != target.ClassroomIdentificationCode)
            {
                source.ClassroomIdentificationCode = target.ClassroomIdentificationCode;
            }
            if (source.LocalCourseCode != target.LocalCourseCode)
            {
                source.LocalCourseCode = target.LocalCourseCode;
            }
            if (source.SchoolId != target.SchoolId)
            {
                source.SchoolId = target.SchoolId;
            }
            if (source.SchoolYear != target.SchoolYear)
            {
                source.SchoolYear = target.SchoolYear;
            }
            if (source.SequenceOfCourse != target.SequenceOfCourse)
            {
                source.SequenceOfCourse = target.SequenceOfCourse;
            }
            if (source.TermDescriptor != target.TermDescriptor)
            {
                source.TermDescriptor = target.TermDescriptor;
            }
            if (source.UniqueSectionCode != target.UniqueSectionCode)
            {
                source.UniqueSectionCode = target.UniqueSectionCode;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsAvailableCreditConversionSupported)
                && target.AvailableCreditConversion != source.AvailableCreditConversion)
            {
                target.AvailableCreditConversion = source.AvailableCreditConversion;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsAvailableCreditsSupported)
                && target.AvailableCredits != source.AvailableCredits)
            {
                target.AvailableCredits = source.AvailableCredits;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsAvailableCreditTypeSupported)
                && target.AvailableCreditType != source.AvailableCreditType)
            {
                target.AvailableCreditType = source.AvailableCreditType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEducationalEnvironmentTypeSupported)
                && target.EducationalEnvironmentType != source.EducationalEnvironmentType)
            {
                target.EducationalEnvironmentType = source.EducationalEnvironmentType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsInstructionLanguageDescriptorSupported)
                && target.InstructionLanguageDescriptor != source.InstructionLanguageDescriptor)
            {
                target.InstructionLanguageDescriptor = source.InstructionLanguageDescriptor;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsMediumOfInstructionTypeSupported)
                && target.MediumOfInstructionType != source.MediumOfInstructionType)
            {
                target.MediumOfInstructionType = source.MediumOfInstructionType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPopulationServedTypeSupported)
                && target.PopulationServedType != source.PopulationServedType)
            {
                target.PopulationServedType = source.PopulationServedType;
                isModified = true;
            }



            // Sync lists
            if (sourceSupport == null || sourceSupport.IsSectionCharacteristicsSupported)
                isModified |= source.SectionCharacteristics.SynchronizeListTo(target.SectionCharacteristics, child => child.Section = target,
                                sourceSupport == null ? null : sourceSupport.IsSectionCharacteristicIncluded);

            if (sourceSupport == null || sourceSupport.IsSectionProgramsSupported)
                isModified |= source.SectionPrograms.SynchronizeListTo(target.SectionPrograms, child => child.Section = target,
                                sourceSupport == null ? null : sourceSupport.IsSectionProgramIncluded);


            return isModified;
        }



        public static void MapTo(this ISection source, ISection target, Action<ISection, ISection> onMapped)
        {
            var sourceSynchSupport = source as ISectionSynchronizationSourceSupport;
            var targetSynchSupport = target as ISectionSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.ClassPeriodName = source.ClassPeriodName;
            target.ClassroomIdentificationCode = source.ClassroomIdentificationCode;
            target.LocalCourseCode = source.LocalCourseCode;
            target.SchoolId = source.SchoolId;
            target.SchoolYear = source.SchoolYear;
            target.SequenceOfCourse = source.SequenceOfCourse;
            target.TermDescriptor = source.TermDescriptor;
            target.UniqueSectionCode = source.UniqueSectionCode;

            // Copy non-PK properties

            if (sourceSynchSupport.IsAvailableCreditConversionSupported)
                target.AvailableCreditConversion = source.AvailableCreditConversion;
            else
                targetSynchSupport.IsAvailableCreditConversionSupported = false;

            if (sourceSynchSupport.IsAvailableCreditsSupported)
                target.AvailableCredits = source.AvailableCredits;
            else
                targetSynchSupport.IsAvailableCreditsSupported = false;

            if (sourceSynchSupport.IsAvailableCreditTypeSupported)
                target.AvailableCreditType = source.AvailableCreditType;
            else
                targetSynchSupport.IsAvailableCreditTypeSupported = false;

            if (sourceSynchSupport.IsEducationalEnvironmentTypeSupported)
                target.EducationalEnvironmentType = source.EducationalEnvironmentType;
            else
                targetSynchSupport.IsEducationalEnvironmentTypeSupported = false;

            if (sourceSynchSupport.IsInstructionLanguageDescriptorSupported)
                target.InstructionLanguageDescriptor = source.InstructionLanguageDescriptor;
            else
                targetSynchSupport.IsInstructionLanguageDescriptorSupported = false;

            if (sourceSynchSupport.IsMediumOfInstructionTypeSupported)
                target.MediumOfInstructionType = source.MediumOfInstructionType;
            else
                targetSynchSupport.IsMediumOfInstructionTypeSupported = false;

            if (sourceSynchSupport.IsPopulationServedTypeSupported)
                target.PopulationServedType = source.PopulationServedType;
            else
                targetSynchSupport.IsPopulationServedTypeSupported = false;

            // Map lists

            if (sourceSynchSupport.IsSectionCharacteristicsSupported)
            {    
                targetSynchSupport.IsSectionCharacteristicIncluded = sourceSynchSupport.IsSectionCharacteristicIncluded;
                source.SectionCharacteristics.MapListTo(target.SectionCharacteristics);
            }
            else
            {
                targetSynchSupport.IsSectionCharacteristicsSupported = false;
            }

            if (sourceSynchSupport.IsSectionProgramsSupported)
            {    
                targetSynchSupport.IsSectionProgramIncluded = sourceSynchSupport.IsSectionProgramIncluded;
                source.SectionPrograms.MapListTo(target.SectionPrograms);
            }
            else
            {
                targetSynchSupport.IsSectionProgramsSupported = false;
            }

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ISectionSynchronizationSourceSupport
    {
        bool IsAvailableCreditConversionSupported { get; set; }
        bool IsAvailableCreditsSupported { get; set; }
        bool IsAvailableCreditTypeSupported { get; set; }
        bool IsEducationalEnvironmentTypeSupported { get; set; }
        bool IsInstructionLanguageDescriptorSupported { get; set; }
        bool IsMediumOfInstructionTypeSupported { get; set; }
        bool IsPopulationServedTypeSupported { get; set; }
        bool IsSectionCharacteristicsSupported { get; set; }
        bool IsSectionProgramsSupported { get; set; }
        Func<ISectionCharacteristic, bool> IsSectionCharacteristicIncluded { get; set; }
        Func<ISectionProgram, bool> IsSectionProgramIncluded { get; set; }
    }
 
    public static class SectionCharacteristicMapper 
    {
        public static bool SynchronizeTo(this ISectionCharacteristic source, ISectionCharacteristic target)
        {
            bool isModified = false;

            var sourceSupport = source as ISectionCharacteristicSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.SectionCharacteristicDescriptor != target.SectionCharacteristicDescriptor)
            {
                source.SectionCharacteristicDescriptor = target.SectionCharacteristicDescriptor;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ISectionCharacteristic source, ISectionCharacteristic target, Action<ISectionCharacteristic, ISectionCharacteristic> onMapped)
        {
            var sourceSynchSupport = source as ISectionCharacteristicSynchronizationSourceSupport;
            var targetSynchSupport = target as ISectionCharacteristicSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.SectionCharacteristicDescriptor = source.SectionCharacteristicDescriptor;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ISectionCharacteristicSynchronizationSourceSupport
    {
    }
 
    public static class SectionProgramMapper 
    {
        public static bool SynchronizeTo(this ISectionProgram source, ISectionProgram target)
        {
            bool isModified = false;

            var sourceSupport = source as ISectionProgramSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.EducationOrganizationId != target.EducationOrganizationId)
            {
                source.EducationOrganizationId = target.EducationOrganizationId;
            }
            if (source.ProgramName != target.ProgramName)
            {
                source.ProgramName = target.ProgramName;
            }
            if (source.ProgramType != target.ProgramType)
            {
                source.ProgramType = target.ProgramType;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ISectionProgram source, ISectionProgram target, Action<ISectionProgram, ISectionProgram> onMapped)
        {
            var sourceSynchSupport = source as ISectionProgramSynchronizationSourceSupport;
            var targetSynchSupport = target as ISectionProgramSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.EducationOrganizationId = source.EducationOrganizationId;
            target.ProgramName = source.ProgramName;
            target.ProgramType = source.ProgramType;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ISectionProgramSynchronizationSourceSupport
    {
    }
 
}
// Aggregate: SectionAttendanceTakenEvent

namespace EdFi.Ods.Entities.Common //.SectionAttendanceTakenEventAggregate
{ 
    public static class SectionAttendanceTakenEventMapper 
    {
        public static bool SynchronizeTo(this ISectionAttendanceTakenEvent source, ISectionAttendanceTakenEvent target)
        {
            bool isModified = false;

            var sourceSupport = source as ISectionAttendanceTakenEventSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.ClassPeriodName != target.ClassPeriodName)
            {
                source.ClassPeriodName = target.ClassPeriodName;
            }
            if (source.ClassroomIdentificationCode != target.ClassroomIdentificationCode)
            {
                source.ClassroomIdentificationCode = target.ClassroomIdentificationCode;
            }
            if (source.Date != target.Date)
            {
                source.Date = target.Date;
            }
            if (source.LocalCourseCode != target.LocalCourseCode)
            {
                source.LocalCourseCode = target.LocalCourseCode;
            }
            if (source.SchoolId != target.SchoolId)
            {
                source.SchoolId = target.SchoolId;
            }
            if (source.SchoolYear != target.SchoolYear)
            {
                source.SchoolYear = target.SchoolYear;
            }
            if (source.SequenceOfCourse != target.SequenceOfCourse)
            {
                source.SequenceOfCourse = target.SequenceOfCourse;
            }
            if (source.TermDescriptor != target.TermDescriptor)
            {
                source.TermDescriptor = target.TermDescriptor;
            }
            if (source.UniqueSectionCode != target.UniqueSectionCode)
            {
                source.UniqueSectionCode = target.UniqueSectionCode;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsEventDateSupported)
                && target.EventDate != source.EventDate)
            {
                target.EventDate = source.EventDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsStaffUniqueIdSupported)
                && target.StaffUniqueId != source.StaffUniqueId)
            {
                target.StaffUniqueId = source.StaffUniqueId;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ISectionAttendanceTakenEvent source, ISectionAttendanceTakenEvent target, Action<ISectionAttendanceTakenEvent, ISectionAttendanceTakenEvent> onMapped)
        {
            var sourceSynchSupport = source as ISectionAttendanceTakenEventSynchronizationSourceSupport;
            var targetSynchSupport = target as ISectionAttendanceTakenEventSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.ClassPeriodName = source.ClassPeriodName;
            target.ClassroomIdentificationCode = source.ClassroomIdentificationCode;
            target.Date = source.Date;
            target.LocalCourseCode = source.LocalCourseCode;
            target.SchoolId = source.SchoolId;
            target.SchoolYear = source.SchoolYear;
            target.SequenceOfCourse = source.SequenceOfCourse;
            target.TermDescriptor = source.TermDescriptor;
            target.UniqueSectionCode = source.UniqueSectionCode;

            // Copy non-PK properties

            if (sourceSynchSupport.IsEventDateSupported)
                target.EventDate = source.EventDate;
            else
                targetSynchSupport.IsEventDateSupported = false;

            if (sourceSynchSupport.IsStaffUniqueIdSupported)
                target.StaffUniqueId = source.StaffUniqueId;
            else
                targetSynchSupport.IsStaffUniqueIdSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ISectionAttendanceTakenEventSynchronizationSourceSupport
    {
        bool IsEventDateSupported { get; set; }
        bool IsStaffUniqueIdSupported { get; set; }
    }
 
}
// Aggregate: SectionCharacteristicDescriptor

namespace EdFi.Ods.Entities.Common //.SectionCharacteristicDescriptorAggregate
{ 
    public static class SectionCharacteristicDescriptorMapper 
    {
        public static bool SynchronizeTo(this ISectionCharacteristicDescriptor source, ISectionCharacteristicDescriptor target)
        {
            bool isModified = false;

            var sourceSupport = source as ISectionCharacteristicDescriptorSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.SectionCharacteristicDescriptorId != target.SectionCharacteristicDescriptorId)
            {
                source.SectionCharacteristicDescriptorId = target.SectionCharacteristicDescriptorId;
            }

            // Copy inherited non-PK properties


            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveBeginDateSupported)
                && target.EffectiveBeginDate != source.EffectiveBeginDate)
            {
                target.EffectiveBeginDate = source.EffectiveBeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveEndDateSupported)
                && target.EffectiveEndDate != source.EffectiveEndDate)
            {
                target.EffectiveEndDate = source.EffectiveEndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNamespaceSupported)
                && target.Namespace != source.Namespace)
            {
                target.Namespace = source.Namespace;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPriorDescriptorIdSupported)
                && target.PriorDescriptorId != source.PriorDescriptorId)
            {
                target.PriorDescriptorId = source.PriorDescriptorId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsSectionCharacteristicTypeSupported)
                && target.SectionCharacteristicType != source.SectionCharacteristicType)
            {
                target.SectionCharacteristicType = source.SectionCharacteristicType;
                isModified = true;
            }

            // Synch inherited lists


            // Sync lists

            return isModified;
        }



        public static void MapTo(this ISectionCharacteristicDescriptor source, ISectionCharacteristicDescriptor target, Action<ISectionCharacteristicDescriptor, ISectionCharacteristicDescriptor> onMapped)
        {
            var sourceSynchSupport = source as ISectionCharacteristicDescriptorSynchronizationSourceSupport;
            var targetSynchSupport = target as ISectionCharacteristicDescriptorSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.SectionCharacteristicDescriptorId = source.SectionCharacteristicDescriptorId;

            // Copy inherited non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsEffectiveBeginDateSupported)
                target.EffectiveBeginDate = source.EffectiveBeginDate;
            else
                targetSynchSupport.IsEffectiveBeginDateSupported = false;

            if (sourceSynchSupport.IsEffectiveEndDateSupported)
                target.EffectiveEndDate = source.EffectiveEndDate;
            else
                targetSynchSupport.IsEffectiveEndDateSupported = false;

            if (sourceSynchSupport.IsNamespaceSupported)
                target.Namespace = source.Namespace;
            else
                targetSynchSupport.IsNamespaceSupported = false;

            if (sourceSynchSupport.IsPriorDescriptorIdSupported)
                target.PriorDescriptorId = source.PriorDescriptorId;
            else
                targetSynchSupport.IsPriorDescriptorIdSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Copy non-PK properties

            if (sourceSynchSupport.IsSectionCharacteristicTypeSupported)
                target.SectionCharacteristicType = source.SectionCharacteristicType;
            else
                targetSynchSupport.IsSectionCharacteristicTypeSupported = false;

            // Map inherited lists

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ISectionCharacteristicDescriptorSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsEffectiveBeginDateSupported { get; set; }
        bool IsEffectiveEndDateSupported { get; set; }
        bool IsNamespaceSupported { get; set; }
        bool IsPriorDescriptorIdSupported { get; set; }
        bool IsSectionCharacteristicTypeSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: SectionCharacteristicType

namespace EdFi.Ods.Entities.Common //.SectionCharacteristicTypeAggregate
{ 
    public static class SectionCharacteristicTypeMapper 
    {
        public static bool SynchronizeTo(this ISectionCharacteristicType source, ISectionCharacteristicType target)
        {
            bool isModified = false;

            var sourceSupport = source as ISectionCharacteristicTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.SectionCharacteristicTypeId != target.SectionCharacteristicTypeId)
            {
                source.SectionCharacteristicTypeId = target.SectionCharacteristicTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ISectionCharacteristicType source, ISectionCharacteristicType target, Action<ISectionCharacteristicType, ISectionCharacteristicType> onMapped)
        {
            var sourceSynchSupport = source as ISectionCharacteristicTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as ISectionCharacteristicTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.SectionCharacteristicTypeId = source.SectionCharacteristicTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ISectionCharacteristicTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: SeparationReasonDescriptor

namespace EdFi.Ods.Entities.Common //.SeparationReasonDescriptorAggregate
{ 
    public static class SeparationReasonDescriptorMapper 
    {
        public static bool SynchronizeTo(this ISeparationReasonDescriptor source, ISeparationReasonDescriptor target)
        {
            bool isModified = false;

            var sourceSupport = source as ISeparationReasonDescriptorSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.SeparationReasonDescriptorId != target.SeparationReasonDescriptorId)
            {
                source.SeparationReasonDescriptorId = target.SeparationReasonDescriptorId;
            }

            // Copy inherited non-PK properties


            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveBeginDateSupported)
                && target.EffectiveBeginDate != source.EffectiveBeginDate)
            {
                target.EffectiveBeginDate = source.EffectiveBeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveEndDateSupported)
                && target.EffectiveEndDate != source.EffectiveEndDate)
            {
                target.EffectiveEndDate = source.EffectiveEndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNamespaceSupported)
                && target.Namespace != source.Namespace)
            {
                target.Namespace = source.Namespace;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPriorDescriptorIdSupported)
                && target.PriorDescriptorId != source.PriorDescriptorId)
            {
                target.PriorDescriptorId = source.PriorDescriptorId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsSeparationReasonTypeSupported)
                && target.SeparationReasonType != source.SeparationReasonType)
            {
                target.SeparationReasonType = source.SeparationReasonType;
                isModified = true;
            }

            // Synch inherited lists


            // Sync lists

            return isModified;
        }



        public static void MapTo(this ISeparationReasonDescriptor source, ISeparationReasonDescriptor target, Action<ISeparationReasonDescriptor, ISeparationReasonDescriptor> onMapped)
        {
            var sourceSynchSupport = source as ISeparationReasonDescriptorSynchronizationSourceSupport;
            var targetSynchSupport = target as ISeparationReasonDescriptorSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.SeparationReasonDescriptorId = source.SeparationReasonDescriptorId;

            // Copy inherited non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsEffectiveBeginDateSupported)
                target.EffectiveBeginDate = source.EffectiveBeginDate;
            else
                targetSynchSupport.IsEffectiveBeginDateSupported = false;

            if (sourceSynchSupport.IsEffectiveEndDateSupported)
                target.EffectiveEndDate = source.EffectiveEndDate;
            else
                targetSynchSupport.IsEffectiveEndDateSupported = false;

            if (sourceSynchSupport.IsNamespaceSupported)
                target.Namespace = source.Namespace;
            else
                targetSynchSupport.IsNamespaceSupported = false;

            if (sourceSynchSupport.IsPriorDescriptorIdSupported)
                target.PriorDescriptorId = source.PriorDescriptorId;
            else
                targetSynchSupport.IsPriorDescriptorIdSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Copy non-PK properties

            if (sourceSynchSupport.IsSeparationReasonTypeSupported)
                target.SeparationReasonType = source.SeparationReasonType;
            else
                targetSynchSupport.IsSeparationReasonTypeSupported = false;

            // Map inherited lists

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ISeparationReasonDescriptorSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsEffectiveBeginDateSupported { get; set; }
        bool IsEffectiveEndDateSupported { get; set; }
        bool IsNamespaceSupported { get; set; }
        bool IsPriorDescriptorIdSupported { get; set; }
        bool IsSeparationReasonTypeSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: SeparationReasonType

namespace EdFi.Ods.Entities.Common //.SeparationReasonTypeAggregate
{ 
    public static class SeparationReasonTypeMapper 
    {
        public static bool SynchronizeTo(this ISeparationReasonType source, ISeparationReasonType target)
        {
            bool isModified = false;

            var sourceSupport = source as ISeparationReasonTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.SeparationReasonTypeId != target.SeparationReasonTypeId)
            {
                source.SeparationReasonTypeId = target.SeparationReasonTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ISeparationReasonType source, ISeparationReasonType target, Action<ISeparationReasonType, ISeparationReasonType> onMapped)
        {
            var sourceSynchSupport = source as ISeparationReasonTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as ISeparationReasonTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.SeparationReasonTypeId = source.SeparationReasonTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ISeparationReasonTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: SeparationType

namespace EdFi.Ods.Entities.Common //.SeparationTypeAggregate
{ 
    public static class SeparationTypeMapper 
    {
        public static bool SynchronizeTo(this ISeparationType source, ISeparationType target)
        {
            bool isModified = false;

            var sourceSupport = source as ISeparationTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.SeparationTypeId != target.SeparationTypeId)
            {
                source.SeparationTypeId = target.SeparationTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ISeparationType source, ISeparationType target, Action<ISeparationType, ISeparationType> onMapped)
        {
            var sourceSynchSupport = source as ISeparationTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as ISeparationTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.SeparationTypeId = source.SeparationTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ISeparationTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: ServiceDescriptor

namespace EdFi.Ods.Entities.Common //.ServiceDescriptorAggregate
{ 
    public static class ServiceDescriptorMapper 
    {
        public static bool SynchronizeTo(this IServiceDescriptor source, IServiceDescriptor target)
        {
            bool isModified = false;

            var sourceSupport = source as IServiceDescriptorSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.ServiceDescriptorId != target.ServiceDescriptorId)
            {
                source.ServiceDescriptorId = target.ServiceDescriptorId;
            }

            // Copy inherited non-PK properties


            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveBeginDateSupported)
                && target.EffectiveBeginDate != source.EffectiveBeginDate)
            {
                target.EffectiveBeginDate = source.EffectiveBeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveEndDateSupported)
                && target.EffectiveEndDate != source.EffectiveEndDate)
            {
                target.EffectiveEndDate = source.EffectiveEndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNamespaceSupported)
                && target.Namespace != source.Namespace)
            {
                target.Namespace = source.Namespace;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPriorDescriptorIdSupported)
                && target.PriorDescriptorId != source.PriorDescriptorId)
            {
                target.PriorDescriptorId = source.PriorDescriptorId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsServiceCategorySupported)
                && target.ServiceCategory != source.ServiceCategory)
            {
                target.ServiceCategory = source.ServiceCategory;
                isModified = true;
            }

            // Synch inherited lists


            // Sync lists

            return isModified;
        }



        public static void MapTo(this IServiceDescriptor source, IServiceDescriptor target, Action<IServiceDescriptor, IServiceDescriptor> onMapped)
        {
            var sourceSynchSupport = source as IServiceDescriptorSynchronizationSourceSupport;
            var targetSynchSupport = target as IServiceDescriptorSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.ServiceDescriptorId = source.ServiceDescriptorId;

            // Copy inherited non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsEffectiveBeginDateSupported)
                target.EffectiveBeginDate = source.EffectiveBeginDate;
            else
                targetSynchSupport.IsEffectiveBeginDateSupported = false;

            if (sourceSynchSupport.IsEffectiveEndDateSupported)
                target.EffectiveEndDate = source.EffectiveEndDate;
            else
                targetSynchSupport.IsEffectiveEndDateSupported = false;

            if (sourceSynchSupport.IsNamespaceSupported)
                target.Namespace = source.Namespace;
            else
                targetSynchSupport.IsNamespaceSupported = false;

            if (sourceSynchSupport.IsPriorDescriptorIdSupported)
                target.PriorDescriptorId = source.PriorDescriptorId;
            else
                targetSynchSupport.IsPriorDescriptorIdSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Copy non-PK properties

            if (sourceSynchSupport.IsServiceCategorySupported)
                target.ServiceCategory = source.ServiceCategory;
            else
                targetSynchSupport.IsServiceCategorySupported = false;

            // Map inherited lists

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IServiceDescriptorSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsEffectiveBeginDateSupported { get; set; }
        bool IsEffectiveEndDateSupported { get; set; }
        bool IsNamespaceSupported { get; set; }
        bool IsPriorDescriptorIdSupported { get; set; }
        bool IsServiceCategorySupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: Session

namespace EdFi.Ods.Entities.Common //.SessionAggregate
{ 
    public static class SessionMapper 
    {
        public static bool SynchronizeTo(this ISession source, ISession target)
        {
            bool isModified = false;

            var sourceSupport = source as ISessionSynchronizationSourceSupport;

            // Allow PK column updates on Session
            if (
                 (target.SchoolId != source.SchoolId)
                || (target.SchoolYear != source.SchoolYear)
                || (target.TermDescriptor != source.TermDescriptor))
            {            
                isModified = true;

                var sourceWithPrimaryKeyValues = (source as IHasPrimaryKeyValues);

                if (sourceWithPrimaryKeyValues != null)
                {
                    var targetWithNewKeyValues = target as IHasCascadableKeyValues;

                    if (targetWithNewKeyValues != null)
                        targetWithNewKeyValues.NewKeyValues = sourceWithPrimaryKeyValues.GetPrimaryKeyValues();
                }
            }

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.SchoolId != target.SchoolId)
            {
                source.SchoolId = target.SchoolId;
            }
            if (source.SchoolYear != target.SchoolYear)
            {
                source.SchoolYear = target.SchoolYear;
            }
            if (source.TermDescriptor != target.TermDescriptor)
            {
                source.TermDescriptor = target.TermDescriptor;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsBeginDateSupported)
                && target.BeginDate != source.BeginDate)
            {
                target.BeginDate = source.BeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEndDateSupported)
                && target.EndDate != source.EndDate)
            {
                target.EndDate = source.EndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsSessionNameSupported)
                && target.SessionName != source.SessionName)
            {
                target.SessionName = source.SessionName;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsTotalInstructionalDaysSupported)
                && target.TotalInstructionalDays != source.TotalInstructionalDays)
            {
                target.TotalInstructionalDays = source.TotalInstructionalDays;
                isModified = true;
            }



            // Sync lists
            if (sourceSupport == null || sourceSupport.IsSessionAcademicWeeksSupported)
                isModified |= source.SessionAcademicWeeks.SynchronizeListTo(target.SessionAcademicWeeks, child => child.Session = target,
                                sourceSupport == null ? null : sourceSupport.IsSessionAcademicWeekIncluded);

            if (sourceSupport == null || sourceSupport.IsSessionGradingPeriodsSupported)
                isModified |= source.SessionGradingPeriods.SynchronizeListTo(target.SessionGradingPeriods, child => child.Session = target,
                                sourceSupport == null ? null : sourceSupport.IsSessionGradingPeriodIncluded);


            return isModified;
        }



        public static void MapTo(this ISession source, ISession target, Action<ISession, ISession> onMapped)
        {
            var sourceSynchSupport = source as ISessionSynchronizationSourceSupport;
            var targetSynchSupport = target as ISessionSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.SchoolId = source.SchoolId;
            target.SchoolYear = source.SchoolYear;
            target.TermDescriptor = source.TermDescriptor;

            // Copy non-PK properties

            if (sourceSynchSupport.IsBeginDateSupported)
                target.BeginDate = source.BeginDate;
            else
                targetSynchSupport.IsBeginDateSupported = false;

            if (sourceSynchSupport.IsEndDateSupported)
                target.EndDate = source.EndDate;
            else
                targetSynchSupport.IsEndDateSupported = false;

            if (sourceSynchSupport.IsSessionNameSupported)
                target.SessionName = source.SessionName;
            else
                targetSynchSupport.IsSessionNameSupported = false;

            if (sourceSynchSupport.IsTotalInstructionalDaysSupported)
                target.TotalInstructionalDays = source.TotalInstructionalDays;
            else
                targetSynchSupport.IsTotalInstructionalDaysSupported = false;

            // Map lists

            if (sourceSynchSupport.IsSessionAcademicWeeksSupported)
            {    
                targetSynchSupport.IsSessionAcademicWeekIncluded = sourceSynchSupport.IsSessionAcademicWeekIncluded;
                source.SessionAcademicWeeks.MapListTo(target.SessionAcademicWeeks);
            }
            else
            {
                targetSynchSupport.IsSessionAcademicWeeksSupported = false;
            }

            if (sourceSynchSupport.IsSessionGradingPeriodsSupported)
            {    
                targetSynchSupport.IsSessionGradingPeriodIncluded = sourceSynchSupport.IsSessionGradingPeriodIncluded;
                source.SessionGradingPeriods.MapListTo(target.SessionGradingPeriods);
            }
            else
            {
                targetSynchSupport.IsSessionGradingPeriodsSupported = false;
            }

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ISessionSynchronizationSourceSupport
    {
        bool IsBeginDateSupported { get; set; }
        bool IsEndDateSupported { get; set; }
        bool IsSessionAcademicWeeksSupported { get; set; }
        bool IsSessionGradingPeriodsSupported { get; set; }
        bool IsSessionNameSupported { get; set; }
        bool IsTotalInstructionalDaysSupported { get; set; }
        Func<ISessionAcademicWeek, bool> IsSessionAcademicWeekIncluded { get; set; }
        Func<ISessionGradingPeriod, bool> IsSessionGradingPeriodIncluded { get; set; }
    }
 
    public static class SessionAcademicWeekMapper 
    {
        public static bool SynchronizeTo(this ISessionAcademicWeek source, ISessionAcademicWeek target)
        {
            bool isModified = false;

            var sourceSupport = source as ISessionAcademicWeekSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.WeekIdentifier != target.WeekIdentifier)
            {
                source.WeekIdentifier = target.WeekIdentifier;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ISessionAcademicWeek source, ISessionAcademicWeek target, Action<ISessionAcademicWeek, ISessionAcademicWeek> onMapped)
        {
            var sourceSynchSupport = source as ISessionAcademicWeekSynchronizationSourceSupport;
            var targetSynchSupport = target as ISessionAcademicWeekSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.WeekIdentifier = source.WeekIdentifier;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ISessionAcademicWeekSynchronizationSourceSupport
    {
    }
 
    public static class SessionGradingPeriodMapper 
    {
        public static bool SynchronizeTo(this ISessionGradingPeriod source, ISessionGradingPeriod target)
        {
            bool isModified = false;

            var sourceSupport = source as ISessionGradingPeriodSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.BeginDate != target.BeginDate)
            {
                source.BeginDate = target.BeginDate;
            }
            if (source.GradingPeriodDescriptor != target.GradingPeriodDescriptor)
            {
                source.GradingPeriodDescriptor = target.GradingPeriodDescriptor;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ISessionGradingPeriod source, ISessionGradingPeriod target, Action<ISessionGradingPeriod, ISessionGradingPeriod> onMapped)
        {
            var sourceSynchSupport = source as ISessionGradingPeriodSynchronizationSourceSupport;
            var targetSynchSupport = target as ISessionGradingPeriodSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.BeginDate = source.BeginDate;
            target.GradingPeriodDescriptor = source.GradingPeriodDescriptor;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ISessionGradingPeriodSynchronizationSourceSupport
    {
    }
 
}
// Aggregate: SexType

namespace EdFi.Ods.Entities.Common //.SexTypeAggregate
{ 
    public static class SexTypeMapper 
    {
        public static bool SynchronizeTo(this ISexType source, ISexType target)
        {
            bool isModified = false;

            var sourceSupport = source as ISexTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.SexTypeId != target.SexTypeId)
            {
                source.SexTypeId = target.SexTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ISexType source, ISexType target, Action<ISexType, ISexType> onMapped)
        {
            var sourceSynchSupport = source as ISexTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as ISexTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.SexTypeId = source.SexTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ISexTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: SpecialEducationSettingDescriptor

namespace EdFi.Ods.Entities.Common //.SpecialEducationSettingDescriptorAggregate
{ 
    public static class SpecialEducationSettingDescriptorMapper 
    {
        public static bool SynchronizeTo(this ISpecialEducationSettingDescriptor source, ISpecialEducationSettingDescriptor target)
        {
            bool isModified = false;

            var sourceSupport = source as ISpecialEducationSettingDescriptorSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.SpecialEducationSettingDescriptorId != target.SpecialEducationSettingDescriptorId)
            {
                source.SpecialEducationSettingDescriptorId = target.SpecialEducationSettingDescriptorId;
            }

            // Copy inherited non-PK properties


            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveBeginDateSupported)
                && target.EffectiveBeginDate != source.EffectiveBeginDate)
            {
                target.EffectiveBeginDate = source.EffectiveBeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveEndDateSupported)
                && target.EffectiveEndDate != source.EffectiveEndDate)
            {
                target.EffectiveEndDate = source.EffectiveEndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNamespaceSupported)
                && target.Namespace != source.Namespace)
            {
                target.Namespace = source.Namespace;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPriorDescriptorIdSupported)
                && target.PriorDescriptorId != source.PriorDescriptorId)
            {
                target.PriorDescriptorId = source.PriorDescriptorId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsSpecialEducationSettingTypeSupported)
                && target.SpecialEducationSettingType != source.SpecialEducationSettingType)
            {
                target.SpecialEducationSettingType = source.SpecialEducationSettingType;
                isModified = true;
            }

            // Synch inherited lists


            // Sync lists

            return isModified;
        }



        public static void MapTo(this ISpecialEducationSettingDescriptor source, ISpecialEducationSettingDescriptor target, Action<ISpecialEducationSettingDescriptor, ISpecialEducationSettingDescriptor> onMapped)
        {
            var sourceSynchSupport = source as ISpecialEducationSettingDescriptorSynchronizationSourceSupport;
            var targetSynchSupport = target as ISpecialEducationSettingDescriptorSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.SpecialEducationSettingDescriptorId = source.SpecialEducationSettingDescriptorId;

            // Copy inherited non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsEffectiveBeginDateSupported)
                target.EffectiveBeginDate = source.EffectiveBeginDate;
            else
                targetSynchSupport.IsEffectiveBeginDateSupported = false;

            if (sourceSynchSupport.IsEffectiveEndDateSupported)
                target.EffectiveEndDate = source.EffectiveEndDate;
            else
                targetSynchSupport.IsEffectiveEndDateSupported = false;

            if (sourceSynchSupport.IsNamespaceSupported)
                target.Namespace = source.Namespace;
            else
                targetSynchSupport.IsNamespaceSupported = false;

            if (sourceSynchSupport.IsPriorDescriptorIdSupported)
                target.PriorDescriptorId = source.PriorDescriptorId;
            else
                targetSynchSupport.IsPriorDescriptorIdSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Copy non-PK properties

            if (sourceSynchSupport.IsSpecialEducationSettingTypeSupported)
                target.SpecialEducationSettingType = source.SpecialEducationSettingType;
            else
                targetSynchSupport.IsSpecialEducationSettingTypeSupported = false;

            // Map inherited lists

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ISpecialEducationSettingDescriptorSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsEffectiveBeginDateSupported { get; set; }
        bool IsEffectiveEndDateSupported { get; set; }
        bool IsNamespaceSupported { get; set; }
        bool IsPriorDescriptorIdSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
        bool IsSpecialEducationSettingTypeSupported { get; set; }
    }
 
}
// Aggregate: SpecialEducationSettingType

namespace EdFi.Ods.Entities.Common //.SpecialEducationSettingTypeAggregate
{ 
    public static class SpecialEducationSettingTypeMapper 
    {
        public static bool SynchronizeTo(this ISpecialEducationSettingType source, ISpecialEducationSettingType target)
        {
            bool isModified = false;

            var sourceSupport = source as ISpecialEducationSettingTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.SpecialEducationSettingTypeId != target.SpecialEducationSettingTypeId)
            {
                source.SpecialEducationSettingTypeId = target.SpecialEducationSettingTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ISpecialEducationSettingType source, ISpecialEducationSettingType target, Action<ISpecialEducationSettingType, ISpecialEducationSettingType> onMapped)
        {
            var sourceSynchSupport = source as ISpecialEducationSettingTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as ISpecialEducationSettingTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.SpecialEducationSettingTypeId = source.SpecialEducationSettingTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ISpecialEducationSettingTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: Staff

namespace EdFi.Ods.Entities.Common //.StaffAggregate
{ 
    public static class StaffMapper 
    {
        public static bool SynchronizeTo(this IStaff source, IStaff target)
        {
            bool isModified = false;

            var sourceSupport = source as IStaffSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsBirthDateSupported)
                && target.BirthDate != source.BirthDate)
            {
                target.BirthDate = source.BirthDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsCitizenshipStatusTypeSupported)
                && target.CitizenshipStatusType != source.CitizenshipStatusType)
            {
                target.CitizenshipStatusType = source.CitizenshipStatusType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsFirstNameSupported)
                && target.FirstName != source.FirstName)
            {
                target.FirstName = source.FirstName;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsGenerationCodeSuffixSupported)
                && target.GenerationCodeSuffix != source.GenerationCodeSuffix)
            {
                target.GenerationCodeSuffix = source.GenerationCodeSuffix;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsHighestCompletedLevelOfEducationDescriptorSupported)
                && target.HighestCompletedLevelOfEducationDescriptor != source.HighestCompletedLevelOfEducationDescriptor)
            {
                target.HighestCompletedLevelOfEducationDescriptor = source.HighestCompletedLevelOfEducationDescriptor;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsHighlyQualifiedTeacherSupported)
                && target.HighlyQualifiedTeacher != source.HighlyQualifiedTeacher)
            {
                target.HighlyQualifiedTeacher = source.HighlyQualifiedTeacher;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsHispanicLatinoEthnicitySupported)
                && target.HispanicLatinoEthnicity != source.HispanicLatinoEthnicity)
            {
                target.HispanicLatinoEthnicity = source.HispanicLatinoEthnicity;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsLastSurnameSupported)
                && target.LastSurname != source.LastSurname)
            {
                target.LastSurname = source.LastSurname;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsLoginIdSupported)
                && target.LoginId != source.LoginId)
            {
                target.LoginId = source.LoginId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsMaidenNameSupported)
                && target.MaidenName != source.MaidenName)
            {
                target.MaidenName = source.MaidenName;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsMiddleNameSupported)
                && target.MiddleName != source.MiddleName)
            {
                target.MiddleName = source.MiddleName;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsOldEthnicityTypeSupported)
                && target.OldEthnicityType != source.OldEthnicityType)
            {
                target.OldEthnicityType = source.OldEthnicityType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPersonalTitlePrefixSupported)
                && target.PersonalTitlePrefix != source.PersonalTitlePrefix)
            {
                target.PersonalTitlePrefix = source.PersonalTitlePrefix;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsSexTypeSupported)
                && target.SexType != source.SexType)
            {
                target.SexType = source.SexType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsStaffUniqueIdSupported)
                && target.StaffUniqueId != source.StaffUniqueId)
            {
                target.StaffUniqueId = source.StaffUniqueId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsYearsOfPriorProfessionalExperienceSupported)
                && target.YearsOfPriorProfessionalExperience != source.YearsOfPriorProfessionalExperience)
            {
                target.YearsOfPriorProfessionalExperience = source.YearsOfPriorProfessionalExperience;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsYearsOfPriorTeachingExperienceSupported)
                && target.YearsOfPriorTeachingExperience != source.YearsOfPriorTeachingExperience)
            {
                target.YearsOfPriorTeachingExperience = source.YearsOfPriorTeachingExperience;
                isModified = true;
            }



            // Sync lists
            if (sourceSupport == null || sourceSupport.IsStaffAddressesSupported)
                isModified |= source.StaffAddresses.SynchronizeListTo(target.StaffAddresses, child => child.Staff = target,
                                sourceSupport == null ? null : sourceSupport.IsStaffAddressIncluded);

            if (sourceSupport == null || sourceSupport.IsStaffCredentialsSupported)
                isModified |= source.StaffCredentials.SynchronizeListTo(target.StaffCredentials, child => child.Staff = target,
                                sourceSupport == null ? null : sourceSupport.IsStaffCredentialIncluded);

            if (sourceSupport == null || sourceSupport.IsStaffElectronicMailsSupported)
                isModified |= source.StaffElectronicMails.SynchronizeListTo(target.StaffElectronicMails, child => child.Staff = target,
                                sourceSupport == null ? null : sourceSupport.IsStaffElectronicMailIncluded);

            if (sourceSupport == null || sourceSupport.IsStaffIdentificationCodesSupported)
                isModified |= source.StaffIdentificationCodes.SynchronizeListTo(target.StaffIdentificationCodes, child => child.Staff = target,
                                sourceSupport == null ? null : sourceSupport.IsStaffIdentificationCodeIncluded);

            if (sourceSupport == null || sourceSupport.IsStaffIdentificationDocumentsSupported)
                isModified |= source.StaffIdentificationDocuments.SynchronizeListTo(target.StaffIdentificationDocuments, child => child.Staff = target,
                                sourceSupport == null ? null : sourceSupport.IsStaffIdentificationDocumentIncluded);

            if (sourceSupport == null || sourceSupport.IsStaffInternationalAddressesSupported)
                isModified |= source.StaffInternationalAddresses.SynchronizeListTo(target.StaffInternationalAddresses, child => child.Staff = target,
                                sourceSupport == null ? null : sourceSupport.IsStaffInternationalAddressIncluded);

            if (sourceSupport == null || sourceSupport.IsStaffLanguagesSupported)
                isModified |= source.StaffLanguages.SynchronizeListTo(target.StaffLanguages, child => child.Staff = target,
                                sourceSupport == null ? null : sourceSupport.IsStaffLanguageIncluded);

            if (sourceSupport == null || sourceSupport.IsStaffOtherNamesSupported)
                isModified |= source.StaffOtherNames.SynchronizeListTo(target.StaffOtherNames, child => child.Staff = target,
                                sourceSupport == null ? null : sourceSupport.IsStaffOtherNameIncluded);

            if (sourceSupport == null || sourceSupport.IsStaffRacesSupported)
                isModified |= source.StaffRaces.SynchronizeListTo(target.StaffRaces, child => child.Staff = target,
                                sourceSupport == null ? null : sourceSupport.IsStaffRaceIncluded);

            if (sourceSupport == null || sourceSupport.IsStaffTelephonesSupported)
                isModified |= source.StaffTelephones.SynchronizeListTo(target.StaffTelephones, child => child.Staff = target,
                                sourceSupport == null ? null : sourceSupport.IsStaffTelephoneIncluded);

            if (sourceSupport == null || sourceSupport.IsStaffVisasSupported)
                isModified |= source.StaffVisas.SynchronizeListTo(target.StaffVisas, child => child.Staff = target,
                                sourceSupport == null ? null : sourceSupport.IsStaffVisaIncluded);


            return isModified;
        }



        public static void MapTo(this IStaff source, IStaff target, Action<IStaff, IStaff> onMapped)
        {
            var sourceSynchSupport = source as IStaffSynchronizationSourceSupport;
            var targetSynchSupport = target as IStaffSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.StaffUniqueId = source.StaffUniqueId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsBirthDateSupported)
                target.BirthDate = source.BirthDate;
            else
                targetSynchSupport.IsBirthDateSupported = false;

            if (sourceSynchSupport.IsCitizenshipStatusTypeSupported)
                target.CitizenshipStatusType = source.CitizenshipStatusType;
            else
                targetSynchSupport.IsCitizenshipStatusTypeSupported = false;

            if (sourceSynchSupport.IsFirstNameSupported)
                target.FirstName = source.FirstName;
            else
                targetSynchSupport.IsFirstNameSupported = false;

            if (sourceSynchSupport.IsGenerationCodeSuffixSupported)
                target.GenerationCodeSuffix = source.GenerationCodeSuffix;
            else
                targetSynchSupport.IsGenerationCodeSuffixSupported = false;

            if (sourceSynchSupport.IsHighestCompletedLevelOfEducationDescriptorSupported)
                target.HighestCompletedLevelOfEducationDescriptor = source.HighestCompletedLevelOfEducationDescriptor;
            else
                targetSynchSupport.IsHighestCompletedLevelOfEducationDescriptorSupported = false;

            if (sourceSynchSupport.IsHighlyQualifiedTeacherSupported)
                target.HighlyQualifiedTeacher = source.HighlyQualifiedTeacher;
            else
                targetSynchSupport.IsHighlyQualifiedTeacherSupported = false;

            if (sourceSynchSupport.IsHispanicLatinoEthnicitySupported)
                target.HispanicLatinoEthnicity = source.HispanicLatinoEthnicity;
            else
                targetSynchSupport.IsHispanicLatinoEthnicitySupported = false;

            if (sourceSynchSupport.IsLastSurnameSupported)
                target.LastSurname = source.LastSurname;
            else
                targetSynchSupport.IsLastSurnameSupported = false;

            if (sourceSynchSupport.IsLoginIdSupported)
                target.LoginId = source.LoginId;
            else
                targetSynchSupport.IsLoginIdSupported = false;

            if (sourceSynchSupport.IsMaidenNameSupported)
                target.MaidenName = source.MaidenName;
            else
                targetSynchSupport.IsMaidenNameSupported = false;

            if (sourceSynchSupport.IsMiddleNameSupported)
                target.MiddleName = source.MiddleName;
            else
                targetSynchSupport.IsMiddleNameSupported = false;

            if (sourceSynchSupport.IsOldEthnicityTypeSupported)
                target.OldEthnicityType = source.OldEthnicityType;
            else
                targetSynchSupport.IsOldEthnicityTypeSupported = false;

            if (sourceSynchSupport.IsPersonalTitlePrefixSupported)
                target.PersonalTitlePrefix = source.PersonalTitlePrefix;
            else
                targetSynchSupport.IsPersonalTitlePrefixSupported = false;

            if (sourceSynchSupport.IsSexTypeSupported)
                target.SexType = source.SexType;
            else
                targetSynchSupport.IsSexTypeSupported = false;

            if (sourceSynchSupport.IsStaffUniqueIdSupported)
                target.StaffUniqueId = source.StaffUniqueId;
            else
                targetSynchSupport.IsStaffUniqueIdSupported = false;

            if (sourceSynchSupport.IsYearsOfPriorProfessionalExperienceSupported)
                target.YearsOfPriorProfessionalExperience = source.YearsOfPriorProfessionalExperience;
            else
                targetSynchSupport.IsYearsOfPriorProfessionalExperienceSupported = false;

            if (sourceSynchSupport.IsYearsOfPriorTeachingExperienceSupported)
                target.YearsOfPriorTeachingExperience = source.YearsOfPriorTeachingExperience;
            else
                targetSynchSupport.IsYearsOfPriorTeachingExperienceSupported = false;

            // Map lists

            if (sourceSynchSupport.IsStaffAddressesSupported)
            {    
                targetSynchSupport.IsStaffAddressIncluded = sourceSynchSupport.IsStaffAddressIncluded;
                source.StaffAddresses.MapListTo(target.StaffAddresses);
            }
            else
            {
                targetSynchSupport.IsStaffAddressesSupported = false;
            }

            if (sourceSynchSupport.IsStaffCredentialsSupported)
            {    
                targetSynchSupport.IsStaffCredentialIncluded = sourceSynchSupport.IsStaffCredentialIncluded;
                source.StaffCredentials.MapListTo(target.StaffCredentials);
            }
            else
            {
                targetSynchSupport.IsStaffCredentialsSupported = false;
            }

            if (sourceSynchSupport.IsStaffElectronicMailsSupported)
            {    
                targetSynchSupport.IsStaffElectronicMailIncluded = sourceSynchSupport.IsStaffElectronicMailIncluded;
                source.StaffElectronicMails.MapListTo(target.StaffElectronicMails);
            }
            else
            {
                targetSynchSupport.IsStaffElectronicMailsSupported = false;
            }

            if (sourceSynchSupport.IsStaffIdentificationCodesSupported)
            {    
                targetSynchSupport.IsStaffIdentificationCodeIncluded = sourceSynchSupport.IsStaffIdentificationCodeIncluded;
                source.StaffIdentificationCodes.MapListTo(target.StaffIdentificationCodes);
            }
            else
            {
                targetSynchSupport.IsStaffIdentificationCodesSupported = false;
            }

            if (sourceSynchSupport.IsStaffIdentificationDocumentsSupported)
            {    
                targetSynchSupport.IsStaffIdentificationDocumentIncluded = sourceSynchSupport.IsStaffIdentificationDocumentIncluded;
                source.StaffIdentificationDocuments.MapListTo(target.StaffIdentificationDocuments);
            }
            else
            {
                targetSynchSupport.IsStaffIdentificationDocumentsSupported = false;
            }

            if (sourceSynchSupport.IsStaffInternationalAddressesSupported)
            {    
                targetSynchSupport.IsStaffInternationalAddressIncluded = sourceSynchSupport.IsStaffInternationalAddressIncluded;
                source.StaffInternationalAddresses.MapListTo(target.StaffInternationalAddresses);
            }
            else
            {
                targetSynchSupport.IsStaffInternationalAddressesSupported = false;
            }

            if (sourceSynchSupport.IsStaffLanguagesSupported)
            {    
                targetSynchSupport.IsStaffLanguageIncluded = sourceSynchSupport.IsStaffLanguageIncluded;
                source.StaffLanguages.MapListTo(target.StaffLanguages);
            }
            else
            {
                targetSynchSupport.IsStaffLanguagesSupported = false;
            }

            if (sourceSynchSupport.IsStaffOtherNamesSupported)
            {    
                targetSynchSupport.IsStaffOtherNameIncluded = sourceSynchSupport.IsStaffOtherNameIncluded;
                source.StaffOtherNames.MapListTo(target.StaffOtherNames);
            }
            else
            {
                targetSynchSupport.IsStaffOtherNamesSupported = false;
            }

            if (sourceSynchSupport.IsStaffRacesSupported)
            {    
                targetSynchSupport.IsStaffRaceIncluded = sourceSynchSupport.IsStaffRaceIncluded;
                source.StaffRaces.MapListTo(target.StaffRaces);
            }
            else
            {
                targetSynchSupport.IsStaffRacesSupported = false;
            }

            if (sourceSynchSupport.IsStaffTelephonesSupported)
            {    
                targetSynchSupport.IsStaffTelephoneIncluded = sourceSynchSupport.IsStaffTelephoneIncluded;
                source.StaffTelephones.MapListTo(target.StaffTelephones);
            }
            else
            {
                targetSynchSupport.IsStaffTelephonesSupported = false;
            }

            if (sourceSynchSupport.IsStaffVisasSupported)
            {    
                targetSynchSupport.IsStaffVisaIncluded = sourceSynchSupport.IsStaffVisaIncluded;
                source.StaffVisas.MapListTo(target.StaffVisas);
            }
            else
            {
                targetSynchSupport.IsStaffVisasSupported = false;
            }

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStaffSynchronizationSourceSupport
    {
        bool IsBirthDateSupported { get; set; }
        bool IsCitizenshipStatusTypeSupported { get; set; }
        bool IsFirstNameSupported { get; set; }
        bool IsGenerationCodeSuffixSupported { get; set; }
        bool IsHighestCompletedLevelOfEducationDescriptorSupported { get; set; }
        bool IsHighlyQualifiedTeacherSupported { get; set; }
        bool IsHispanicLatinoEthnicitySupported { get; set; }
        bool IsLastSurnameSupported { get; set; }
        bool IsLoginIdSupported { get; set; }
        bool IsMaidenNameSupported { get; set; }
        bool IsMiddleNameSupported { get; set; }
        bool IsOldEthnicityTypeSupported { get; set; }
        bool IsPersonalTitlePrefixSupported { get; set; }
        bool IsSexTypeSupported { get; set; }
        bool IsStaffAddressesSupported { get; set; }
        bool IsStaffCredentialsSupported { get; set; }
        bool IsStaffElectronicMailsSupported { get; set; }
        bool IsStaffIdentificationCodesSupported { get; set; }
        bool IsStaffIdentificationDocumentsSupported { get; set; }
        bool IsStaffInternationalAddressesSupported { get; set; }
        bool IsStaffLanguagesSupported { get; set; }
        bool IsStaffOtherNamesSupported { get; set; }
        bool IsStaffRacesSupported { get; set; }
        bool IsStaffTelephonesSupported { get; set; }
        bool IsStaffUniqueIdSupported { get; set; }
        bool IsStaffVisasSupported { get; set; }
        bool IsYearsOfPriorProfessionalExperienceSupported { get; set; }
        bool IsYearsOfPriorTeachingExperienceSupported { get; set; }
        Func<IStaffAddress, bool> IsStaffAddressIncluded { get; set; }
        Func<IStaffCredential, bool> IsStaffCredentialIncluded { get; set; }
        Func<IStaffElectronicMail, bool> IsStaffElectronicMailIncluded { get; set; }
        Func<IStaffIdentificationCode, bool> IsStaffIdentificationCodeIncluded { get; set; }
        Func<IStaffIdentificationDocument, bool> IsStaffIdentificationDocumentIncluded { get; set; }
        Func<IStaffInternationalAddress, bool> IsStaffInternationalAddressIncluded { get; set; }
        Func<IStaffLanguage, bool> IsStaffLanguageIncluded { get; set; }
        Func<IStaffOtherName, bool> IsStaffOtherNameIncluded { get; set; }
        Func<IStaffRace, bool> IsStaffRaceIncluded { get; set; }
        Func<IStaffTelephone, bool> IsStaffTelephoneIncluded { get; set; }
        Func<IStaffVisa, bool> IsStaffVisaIncluded { get; set; }
    }
 
    public static class StaffAddressMapper 
    {
        public static bool SynchronizeTo(this IStaffAddress source, IStaffAddress target)
        {
            bool isModified = false;

            var sourceSupport = source as IStaffAddressSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AddressType != target.AddressType)
            {
                source.AddressType = target.AddressType;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsApartmentRoomSuiteNumberSupported)
                && target.ApartmentRoomSuiteNumber != source.ApartmentRoomSuiteNumber)
            {
                target.ApartmentRoomSuiteNumber = source.ApartmentRoomSuiteNumber;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsBeginDateSupported)
                && target.BeginDate != source.BeginDate)
            {
                target.BeginDate = source.BeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsBuildingSiteNumberSupported)
                && target.BuildingSiteNumber != source.BuildingSiteNumber)
            {
                target.BuildingSiteNumber = source.BuildingSiteNumber;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsCitySupported)
                && target.City != source.City)
            {
                target.City = source.City;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsCountyFIPSCodeSupported)
                && target.CountyFIPSCode != source.CountyFIPSCode)
            {
                target.CountyFIPSCode = source.CountyFIPSCode;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEndDateSupported)
                && target.EndDate != source.EndDate)
            {
                target.EndDate = source.EndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsLatitudeSupported)
                && target.Latitude != source.Latitude)
            {
                target.Latitude = source.Latitude;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsLongitudeSupported)
                && target.Longitude != source.Longitude)
            {
                target.Longitude = source.Longitude;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNameOfCountySupported)
                && target.NameOfCounty != source.NameOfCounty)
            {
                target.NameOfCounty = source.NameOfCounty;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPostalCodeSupported)
                && target.PostalCode != source.PostalCode)
            {
                target.PostalCode = source.PostalCode;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsStateAbbreviationTypeSupported)
                && target.StateAbbreviationType != source.StateAbbreviationType)
            {
                target.StateAbbreviationType = source.StateAbbreviationType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsStreetNumberNameSupported)
                && target.StreetNumberName != source.StreetNumberName)
            {
                target.StreetNumberName = source.StreetNumberName;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStaffAddress source, IStaffAddress target, Action<IStaffAddress, IStaffAddress> onMapped)
        {
            var sourceSynchSupport = source as IStaffAddressSynchronizationSourceSupport;
            var targetSynchSupport = target as IStaffAddressSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.AddressType = source.AddressType;

            // Copy non-PK properties

            if (sourceSynchSupport.IsApartmentRoomSuiteNumberSupported)
                target.ApartmentRoomSuiteNumber = source.ApartmentRoomSuiteNumber;
            else
                targetSynchSupport.IsApartmentRoomSuiteNumberSupported = false;

            if (sourceSynchSupport.IsBeginDateSupported)
                target.BeginDate = source.BeginDate;
            else
                targetSynchSupport.IsBeginDateSupported = false;

            if (sourceSynchSupport.IsBuildingSiteNumberSupported)
                target.BuildingSiteNumber = source.BuildingSiteNumber;
            else
                targetSynchSupport.IsBuildingSiteNumberSupported = false;

            if (sourceSynchSupport.IsCitySupported)
                target.City = source.City;
            else
                targetSynchSupport.IsCitySupported = false;

            if (sourceSynchSupport.IsCountyFIPSCodeSupported)
                target.CountyFIPSCode = source.CountyFIPSCode;
            else
                targetSynchSupport.IsCountyFIPSCodeSupported = false;

            if (sourceSynchSupport.IsEndDateSupported)
                target.EndDate = source.EndDate;
            else
                targetSynchSupport.IsEndDateSupported = false;

            if (sourceSynchSupport.IsLatitudeSupported)
                target.Latitude = source.Latitude;
            else
                targetSynchSupport.IsLatitudeSupported = false;

            if (sourceSynchSupport.IsLongitudeSupported)
                target.Longitude = source.Longitude;
            else
                targetSynchSupport.IsLongitudeSupported = false;

            if (sourceSynchSupport.IsNameOfCountySupported)
                target.NameOfCounty = source.NameOfCounty;
            else
                targetSynchSupport.IsNameOfCountySupported = false;

            if (sourceSynchSupport.IsPostalCodeSupported)
                target.PostalCode = source.PostalCode;
            else
                targetSynchSupport.IsPostalCodeSupported = false;

            if (sourceSynchSupport.IsStateAbbreviationTypeSupported)
                target.StateAbbreviationType = source.StateAbbreviationType;
            else
                targetSynchSupport.IsStateAbbreviationTypeSupported = false;

            if (sourceSynchSupport.IsStreetNumberNameSupported)
                target.StreetNumberName = source.StreetNumberName;
            else
                targetSynchSupport.IsStreetNumberNameSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStaffAddressSynchronizationSourceSupport
    {
        bool IsApartmentRoomSuiteNumberSupported { get; set; }
        bool IsBeginDateSupported { get; set; }
        bool IsBuildingSiteNumberSupported { get; set; }
        bool IsCitySupported { get; set; }
        bool IsCountyFIPSCodeSupported { get; set; }
        bool IsEndDateSupported { get; set; }
        bool IsLatitudeSupported { get; set; }
        bool IsLongitudeSupported { get; set; }
        bool IsNameOfCountySupported { get; set; }
        bool IsPostalCodeSupported { get; set; }
        bool IsStateAbbreviationTypeSupported { get; set; }
        bool IsStreetNumberNameSupported { get; set; }
    }
 
    public static class StaffCredentialMapper 
    {
        public static bool SynchronizeTo(this IStaffCredential source, IStaffCredential target)
        {
            bool isModified = false;

            var sourceSupport = source as IStaffCredentialSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.CredentialFieldDescriptor != target.CredentialFieldDescriptor)
            {
                source.CredentialFieldDescriptor = target.CredentialFieldDescriptor;
            }
            if (source.CredentialIssuanceDate != target.CredentialIssuanceDate)
            {
                source.CredentialIssuanceDate = target.CredentialIssuanceDate;
            }
            if (source.CredentialType != target.CredentialType)
            {
                source.CredentialType = target.CredentialType;
            }
            if (source.LevelDescriptor != target.LevelDescriptor)
            {
                source.LevelDescriptor = target.LevelDescriptor;
            }
            if (source.TeachingCredentialDescriptor != target.TeachingCredentialDescriptor)
            {
                source.TeachingCredentialDescriptor = target.TeachingCredentialDescriptor;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCredentialExpirationDateSupported)
                && target.CredentialExpirationDate != source.CredentialExpirationDate)
            {
                target.CredentialExpirationDate = source.CredentialExpirationDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsStateOfIssueStateAbbreviationTypeSupported)
                && target.StateOfIssueStateAbbreviationType != source.StateOfIssueStateAbbreviationType)
            {
                target.StateOfIssueStateAbbreviationType = source.StateOfIssueStateAbbreviationType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsTeachingCredentialBasisTypeSupported)
                && target.TeachingCredentialBasisType != source.TeachingCredentialBasisType)
            {
                target.TeachingCredentialBasisType = source.TeachingCredentialBasisType;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStaffCredential source, IStaffCredential target, Action<IStaffCredential, IStaffCredential> onMapped)
        {
            var sourceSynchSupport = source as IStaffCredentialSynchronizationSourceSupport;
            var targetSynchSupport = target as IStaffCredentialSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.CredentialFieldDescriptor = source.CredentialFieldDescriptor;
            target.CredentialIssuanceDate = source.CredentialIssuanceDate;
            target.CredentialType = source.CredentialType;
            target.LevelDescriptor = source.LevelDescriptor;
            target.TeachingCredentialDescriptor = source.TeachingCredentialDescriptor;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCredentialExpirationDateSupported)
                target.CredentialExpirationDate = source.CredentialExpirationDate;
            else
                targetSynchSupport.IsCredentialExpirationDateSupported = false;

            if (sourceSynchSupport.IsStateOfIssueStateAbbreviationTypeSupported)
                target.StateOfIssueStateAbbreviationType = source.StateOfIssueStateAbbreviationType;
            else
                targetSynchSupport.IsStateOfIssueStateAbbreviationTypeSupported = false;

            if (sourceSynchSupport.IsTeachingCredentialBasisTypeSupported)
                target.TeachingCredentialBasisType = source.TeachingCredentialBasisType;
            else
                targetSynchSupport.IsTeachingCredentialBasisTypeSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStaffCredentialSynchronizationSourceSupport
    {
        bool IsCredentialExpirationDateSupported { get; set; }
        bool IsStateOfIssueStateAbbreviationTypeSupported { get; set; }
        bool IsTeachingCredentialBasisTypeSupported { get; set; }
    }
 
    public static class StaffElectronicMailMapper 
    {
        public static bool SynchronizeTo(this IStaffElectronicMail source, IStaffElectronicMail target)
        {
            bool isModified = false;

            var sourceSupport = source as IStaffElectronicMailSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.ElectronicMailType != target.ElectronicMailType)
            {
                source.ElectronicMailType = target.ElectronicMailType;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsElectronicMailAddressSupported)
                && target.ElectronicMailAddress != source.ElectronicMailAddress)
            {
                target.ElectronicMailAddress = source.ElectronicMailAddress;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPrimaryEmailAddressIndicatorSupported)
                && target.PrimaryEmailAddressIndicator != source.PrimaryEmailAddressIndicator)
            {
                target.PrimaryEmailAddressIndicator = source.PrimaryEmailAddressIndicator;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStaffElectronicMail source, IStaffElectronicMail target, Action<IStaffElectronicMail, IStaffElectronicMail> onMapped)
        {
            var sourceSynchSupport = source as IStaffElectronicMailSynchronizationSourceSupport;
            var targetSynchSupport = target as IStaffElectronicMailSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.ElectronicMailType = source.ElectronicMailType;

            // Copy non-PK properties

            if (sourceSynchSupport.IsElectronicMailAddressSupported)
                target.ElectronicMailAddress = source.ElectronicMailAddress;
            else
                targetSynchSupport.IsElectronicMailAddressSupported = false;

            if (sourceSynchSupport.IsPrimaryEmailAddressIndicatorSupported)
                target.PrimaryEmailAddressIndicator = source.PrimaryEmailAddressIndicator;
            else
                targetSynchSupport.IsPrimaryEmailAddressIndicatorSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStaffElectronicMailSynchronizationSourceSupport
    {
        bool IsElectronicMailAddressSupported { get; set; }
        bool IsPrimaryEmailAddressIndicatorSupported { get; set; }
    }
 
    public static class StaffIdentificationCodeMapper 
    {
        public static bool SynchronizeTo(this IStaffIdentificationCode source, IStaffIdentificationCode target)
        {
            bool isModified = false;

            var sourceSupport = source as IStaffIdentificationCodeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.StaffIdentificationSystemDescriptor != target.StaffIdentificationSystemDescriptor)
            {
                source.StaffIdentificationSystemDescriptor = target.StaffIdentificationSystemDescriptor;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsAssigningOrganizationIdentificationCodeSupported)
                && target.AssigningOrganizationIdentificationCode != source.AssigningOrganizationIdentificationCode)
            {
                target.AssigningOrganizationIdentificationCode = source.AssigningOrganizationIdentificationCode;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsIdentificationCodeSupported)
                && target.IdentificationCode != source.IdentificationCode)
            {
                target.IdentificationCode = source.IdentificationCode;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStaffIdentificationCode source, IStaffIdentificationCode target, Action<IStaffIdentificationCode, IStaffIdentificationCode> onMapped)
        {
            var sourceSynchSupport = source as IStaffIdentificationCodeSynchronizationSourceSupport;
            var targetSynchSupport = target as IStaffIdentificationCodeSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.StaffIdentificationSystemDescriptor = source.StaffIdentificationSystemDescriptor;

            // Copy non-PK properties

            if (sourceSynchSupport.IsAssigningOrganizationIdentificationCodeSupported)
                target.AssigningOrganizationIdentificationCode = source.AssigningOrganizationIdentificationCode;
            else
                targetSynchSupport.IsAssigningOrganizationIdentificationCodeSupported = false;

            if (sourceSynchSupport.IsIdentificationCodeSupported)
                target.IdentificationCode = source.IdentificationCode;
            else
                targetSynchSupport.IsIdentificationCodeSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStaffIdentificationCodeSynchronizationSourceSupport
    {
        bool IsAssigningOrganizationIdentificationCodeSupported { get; set; }
        bool IsIdentificationCodeSupported { get; set; }
    }
 
    public static class StaffIdentificationDocumentMapper 
    {
        public static bool SynchronizeTo(this IStaffIdentificationDocument source, IStaffIdentificationDocument target)
        {
            bool isModified = false;

            var sourceSupport = source as IStaffIdentificationDocumentSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.IdentificationDocumentUseType != target.IdentificationDocumentUseType)
            {
                source.IdentificationDocumentUseType = target.IdentificationDocumentUseType;
            }
            if (source.PersonalInformationVerificationType != target.PersonalInformationVerificationType)
            {
                source.PersonalInformationVerificationType = target.PersonalInformationVerificationType;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsDocumentExpirationDateSupported)
                && target.DocumentExpirationDate != source.DocumentExpirationDate)
            {
                target.DocumentExpirationDate = source.DocumentExpirationDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDocumentTitleSupported)
                && target.DocumentTitle != source.DocumentTitle)
            {
                target.DocumentTitle = source.DocumentTitle;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsIssuerCountryDescriptorSupported)
                && target.IssuerCountryDescriptor != source.IssuerCountryDescriptor)
            {
                target.IssuerCountryDescriptor = source.IssuerCountryDescriptor;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsIssuerDocumentIdentificationCodeSupported)
                && target.IssuerDocumentIdentificationCode != source.IssuerDocumentIdentificationCode)
            {
                target.IssuerDocumentIdentificationCode = source.IssuerDocumentIdentificationCode;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsIssuerNameSupported)
                && target.IssuerName != source.IssuerName)
            {
                target.IssuerName = source.IssuerName;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStaffIdentificationDocument source, IStaffIdentificationDocument target, Action<IStaffIdentificationDocument, IStaffIdentificationDocument> onMapped)
        {
            var sourceSynchSupport = source as IStaffIdentificationDocumentSynchronizationSourceSupport;
            var targetSynchSupport = target as IStaffIdentificationDocumentSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.IdentificationDocumentUseType = source.IdentificationDocumentUseType;
            target.PersonalInformationVerificationType = source.PersonalInformationVerificationType;

            // Copy non-PK properties

            if (sourceSynchSupport.IsDocumentExpirationDateSupported)
                target.DocumentExpirationDate = source.DocumentExpirationDate;
            else
                targetSynchSupport.IsDocumentExpirationDateSupported = false;

            if (sourceSynchSupport.IsDocumentTitleSupported)
                target.DocumentTitle = source.DocumentTitle;
            else
                targetSynchSupport.IsDocumentTitleSupported = false;

            if (sourceSynchSupport.IsIssuerCountryDescriptorSupported)
                target.IssuerCountryDescriptor = source.IssuerCountryDescriptor;
            else
                targetSynchSupport.IsIssuerCountryDescriptorSupported = false;

            if (sourceSynchSupport.IsIssuerDocumentIdentificationCodeSupported)
                target.IssuerDocumentIdentificationCode = source.IssuerDocumentIdentificationCode;
            else
                targetSynchSupport.IsIssuerDocumentIdentificationCodeSupported = false;

            if (sourceSynchSupport.IsIssuerNameSupported)
                target.IssuerName = source.IssuerName;
            else
                targetSynchSupport.IsIssuerNameSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStaffIdentificationDocumentSynchronizationSourceSupport
    {
        bool IsDocumentExpirationDateSupported { get; set; }
        bool IsDocumentTitleSupported { get; set; }
        bool IsIssuerCountryDescriptorSupported { get; set; }
        bool IsIssuerDocumentIdentificationCodeSupported { get; set; }
        bool IsIssuerNameSupported { get; set; }
    }
 
    public static class StaffInternationalAddressMapper 
    {
        public static bool SynchronizeTo(this IStaffInternationalAddress source, IStaffInternationalAddress target)
        {
            bool isModified = false;

            var sourceSupport = source as IStaffInternationalAddressSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AddressType != target.AddressType)
            {
                source.AddressType = target.AddressType;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsAddressLine1Supported)
                && target.AddressLine1 != source.AddressLine1)
            {
                target.AddressLine1 = source.AddressLine1;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsAddressLine2Supported)
                && target.AddressLine2 != source.AddressLine2)
            {
                target.AddressLine2 = source.AddressLine2;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsAddressLine3Supported)
                && target.AddressLine3 != source.AddressLine3)
            {
                target.AddressLine3 = source.AddressLine3;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsAddressLine4Supported)
                && target.AddressLine4 != source.AddressLine4)
            {
                target.AddressLine4 = source.AddressLine4;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsBeginDateSupported)
                && target.BeginDate != source.BeginDate)
            {
                target.BeginDate = source.BeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsCountryDescriptorSupported)
                && target.CountryDescriptor != source.CountryDescriptor)
            {
                target.CountryDescriptor = source.CountryDescriptor;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEndDateSupported)
                && target.EndDate != source.EndDate)
            {
                target.EndDate = source.EndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsLatitudeSupported)
                && target.Latitude != source.Latitude)
            {
                target.Latitude = source.Latitude;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsLongitudeSupported)
                && target.Longitude != source.Longitude)
            {
                target.Longitude = source.Longitude;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStaffInternationalAddress source, IStaffInternationalAddress target, Action<IStaffInternationalAddress, IStaffInternationalAddress> onMapped)
        {
            var sourceSynchSupport = source as IStaffInternationalAddressSynchronizationSourceSupport;
            var targetSynchSupport = target as IStaffInternationalAddressSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.AddressType = source.AddressType;

            // Copy non-PK properties

            if (sourceSynchSupport.IsAddressLine1Supported)
                target.AddressLine1 = source.AddressLine1;
            else
                targetSynchSupport.IsAddressLine1Supported = false;

            if (sourceSynchSupport.IsAddressLine2Supported)
                target.AddressLine2 = source.AddressLine2;
            else
                targetSynchSupport.IsAddressLine2Supported = false;

            if (sourceSynchSupport.IsAddressLine3Supported)
                target.AddressLine3 = source.AddressLine3;
            else
                targetSynchSupport.IsAddressLine3Supported = false;

            if (sourceSynchSupport.IsAddressLine4Supported)
                target.AddressLine4 = source.AddressLine4;
            else
                targetSynchSupport.IsAddressLine4Supported = false;

            if (sourceSynchSupport.IsBeginDateSupported)
                target.BeginDate = source.BeginDate;
            else
                targetSynchSupport.IsBeginDateSupported = false;

            if (sourceSynchSupport.IsCountryDescriptorSupported)
                target.CountryDescriptor = source.CountryDescriptor;
            else
                targetSynchSupport.IsCountryDescriptorSupported = false;

            if (sourceSynchSupport.IsEndDateSupported)
                target.EndDate = source.EndDate;
            else
                targetSynchSupport.IsEndDateSupported = false;

            if (sourceSynchSupport.IsLatitudeSupported)
                target.Latitude = source.Latitude;
            else
                targetSynchSupport.IsLatitudeSupported = false;

            if (sourceSynchSupport.IsLongitudeSupported)
                target.Longitude = source.Longitude;
            else
                targetSynchSupport.IsLongitudeSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStaffInternationalAddressSynchronizationSourceSupport
    {
        bool IsAddressLine1Supported { get; set; }
        bool IsAddressLine2Supported { get; set; }
        bool IsAddressLine3Supported { get; set; }
        bool IsAddressLine4Supported { get; set; }
        bool IsBeginDateSupported { get; set; }
        bool IsCountryDescriptorSupported { get; set; }
        bool IsEndDateSupported { get; set; }
        bool IsLatitudeSupported { get; set; }
        bool IsLongitudeSupported { get; set; }
    }
 
    public static class StaffLanguageMapper 
    {
        public static bool SynchronizeTo(this IStaffLanguage source, IStaffLanguage target)
        {
            bool isModified = false;

            var sourceSupport = source as IStaffLanguageSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.LanguageDescriptor != target.LanguageDescriptor)
            {
                source.LanguageDescriptor = target.LanguageDescriptor;
            }

            // Copy non-PK properties



            // Sync lists
            if (sourceSupport == null || sourceSupport.IsStaffLanguageUsesSupported)
                isModified |= source.StaffLanguageUses.SynchronizeListTo(target.StaffLanguageUses, child => child.StaffLanguage = target,
                                sourceSupport == null ? null : sourceSupport.IsStaffLanguageUseIncluded);


            return isModified;
        }



        public static void MapTo(this IStaffLanguage source, IStaffLanguage target, Action<IStaffLanguage, IStaffLanguage> onMapped)
        {
            var sourceSynchSupport = source as IStaffLanguageSynchronizationSourceSupport;
            var targetSynchSupport = target as IStaffLanguageSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.LanguageDescriptor = source.LanguageDescriptor;

            // Copy non-PK properties

            // Map lists

            if (sourceSynchSupport.IsStaffLanguageUsesSupported)
            {    
                targetSynchSupport.IsStaffLanguageUseIncluded = sourceSynchSupport.IsStaffLanguageUseIncluded;
                source.StaffLanguageUses.MapListTo(target.StaffLanguageUses);
            }
            else
            {
                targetSynchSupport.IsStaffLanguageUsesSupported = false;
            }

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStaffLanguageSynchronizationSourceSupport
    {
        bool IsStaffLanguageUsesSupported { get; set; }
        Func<IStaffLanguageUse, bool> IsStaffLanguageUseIncluded { get; set; }
    }
 
    public static class StaffLanguageUseMapper 
    {
        public static bool SynchronizeTo(this IStaffLanguageUse source, IStaffLanguageUse target)
        {
            bool isModified = false;

            var sourceSupport = source as IStaffLanguageUseSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.LanguageUseType != target.LanguageUseType)
            {
                source.LanguageUseType = target.LanguageUseType;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStaffLanguageUse source, IStaffLanguageUse target, Action<IStaffLanguageUse, IStaffLanguageUse> onMapped)
        {
            var sourceSynchSupport = source as IStaffLanguageUseSynchronizationSourceSupport;
            var targetSynchSupport = target as IStaffLanguageUseSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.LanguageUseType = source.LanguageUseType;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStaffLanguageUseSynchronizationSourceSupport
    {
    }
 
    public static class StaffOtherNameMapper 
    {
        public static bool SynchronizeTo(this IStaffOtherName source, IStaffOtherName target)
        {
            bool isModified = false;

            var sourceSupport = source as IStaffOtherNameSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.OtherNameType != target.OtherNameType)
            {
                source.OtherNameType = target.OtherNameType;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsFirstNameSupported)
                && target.FirstName != source.FirstName)
            {
                target.FirstName = source.FirstName;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsGenerationCodeSuffixSupported)
                && target.GenerationCodeSuffix != source.GenerationCodeSuffix)
            {
                target.GenerationCodeSuffix = source.GenerationCodeSuffix;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsLastSurnameSupported)
                && target.LastSurname != source.LastSurname)
            {
                target.LastSurname = source.LastSurname;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsMiddleNameSupported)
                && target.MiddleName != source.MiddleName)
            {
                target.MiddleName = source.MiddleName;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPersonalTitlePrefixSupported)
                && target.PersonalTitlePrefix != source.PersonalTitlePrefix)
            {
                target.PersonalTitlePrefix = source.PersonalTitlePrefix;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStaffOtherName source, IStaffOtherName target, Action<IStaffOtherName, IStaffOtherName> onMapped)
        {
            var sourceSynchSupport = source as IStaffOtherNameSynchronizationSourceSupport;
            var targetSynchSupport = target as IStaffOtherNameSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.OtherNameType = source.OtherNameType;

            // Copy non-PK properties

            if (sourceSynchSupport.IsFirstNameSupported)
                target.FirstName = source.FirstName;
            else
                targetSynchSupport.IsFirstNameSupported = false;

            if (sourceSynchSupport.IsGenerationCodeSuffixSupported)
                target.GenerationCodeSuffix = source.GenerationCodeSuffix;
            else
                targetSynchSupport.IsGenerationCodeSuffixSupported = false;

            if (sourceSynchSupport.IsLastSurnameSupported)
                target.LastSurname = source.LastSurname;
            else
                targetSynchSupport.IsLastSurnameSupported = false;

            if (sourceSynchSupport.IsMiddleNameSupported)
                target.MiddleName = source.MiddleName;
            else
                targetSynchSupport.IsMiddleNameSupported = false;

            if (sourceSynchSupport.IsPersonalTitlePrefixSupported)
                target.PersonalTitlePrefix = source.PersonalTitlePrefix;
            else
                targetSynchSupport.IsPersonalTitlePrefixSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStaffOtherNameSynchronizationSourceSupport
    {
        bool IsFirstNameSupported { get; set; }
        bool IsGenerationCodeSuffixSupported { get; set; }
        bool IsLastSurnameSupported { get; set; }
        bool IsMiddleNameSupported { get; set; }
        bool IsPersonalTitlePrefixSupported { get; set; }
    }
 
    public static class StaffRaceMapper 
    {
        public static bool SynchronizeTo(this IStaffRace source, IStaffRace target)
        {
            bool isModified = false;

            var sourceSupport = source as IStaffRaceSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.RaceType != target.RaceType)
            {
                source.RaceType = target.RaceType;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStaffRace source, IStaffRace target, Action<IStaffRace, IStaffRace> onMapped)
        {
            var sourceSynchSupport = source as IStaffRaceSynchronizationSourceSupport;
            var targetSynchSupport = target as IStaffRaceSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.RaceType = source.RaceType;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStaffRaceSynchronizationSourceSupport
    {
    }
 
    public static class StaffTelephoneMapper 
    {
        public static bool SynchronizeTo(this IStaffTelephone source, IStaffTelephone target)
        {
            bool isModified = false;

            var sourceSupport = source as IStaffTelephoneSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.TelephoneNumberType != target.TelephoneNumberType)
            {
                source.TelephoneNumberType = target.TelephoneNumberType;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsOrderOfPrioritySupported)
                && target.OrderOfPriority != source.OrderOfPriority)
            {
                target.OrderOfPriority = source.OrderOfPriority;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsTelephoneNumberSupported)
                && target.TelephoneNumber != source.TelephoneNumber)
            {
                target.TelephoneNumber = source.TelephoneNumber;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsTextMessageCapabilityIndicatorSupported)
                && target.TextMessageCapabilityIndicator != source.TextMessageCapabilityIndicator)
            {
                target.TextMessageCapabilityIndicator = source.TextMessageCapabilityIndicator;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStaffTelephone source, IStaffTelephone target, Action<IStaffTelephone, IStaffTelephone> onMapped)
        {
            var sourceSynchSupport = source as IStaffTelephoneSynchronizationSourceSupport;
            var targetSynchSupport = target as IStaffTelephoneSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.TelephoneNumberType = source.TelephoneNumberType;

            // Copy non-PK properties

            if (sourceSynchSupport.IsOrderOfPrioritySupported)
                target.OrderOfPriority = source.OrderOfPriority;
            else
                targetSynchSupport.IsOrderOfPrioritySupported = false;

            if (sourceSynchSupport.IsTelephoneNumberSupported)
                target.TelephoneNumber = source.TelephoneNumber;
            else
                targetSynchSupport.IsTelephoneNumberSupported = false;

            if (sourceSynchSupport.IsTextMessageCapabilityIndicatorSupported)
                target.TextMessageCapabilityIndicator = source.TextMessageCapabilityIndicator;
            else
                targetSynchSupport.IsTextMessageCapabilityIndicatorSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStaffTelephoneSynchronizationSourceSupport
    {
        bool IsOrderOfPrioritySupported { get; set; }
        bool IsTelephoneNumberSupported { get; set; }
        bool IsTextMessageCapabilityIndicatorSupported { get; set; }
    }
 
    public static class StaffVisaMapper 
    {
        public static bool SynchronizeTo(this IStaffVisa source, IStaffVisa target)
        {
            bool isModified = false;

            var sourceSupport = source as IStaffVisaSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.VisaType != target.VisaType)
            {
                source.VisaType = target.VisaType;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStaffVisa source, IStaffVisa target, Action<IStaffVisa, IStaffVisa> onMapped)
        {
            var sourceSynchSupport = source as IStaffVisaSynchronizationSourceSupport;
            var targetSynchSupport = target as IStaffVisaSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.VisaType = source.VisaType;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStaffVisaSynchronizationSourceSupport
    {
    }
 
}
// Aggregate: StaffClassificationDescriptor

namespace EdFi.Ods.Entities.Common //.StaffClassificationDescriptorAggregate
{ 
    public static class StaffClassificationDescriptorMapper 
    {
        public static bool SynchronizeTo(this IStaffClassificationDescriptor source, IStaffClassificationDescriptor target)
        {
            bool isModified = false;

            var sourceSupport = source as IStaffClassificationDescriptorSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.StaffClassificationDescriptorId != target.StaffClassificationDescriptorId)
            {
                source.StaffClassificationDescriptorId = target.StaffClassificationDescriptorId;
            }

            // Copy inherited non-PK properties


            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveBeginDateSupported)
                && target.EffectiveBeginDate != source.EffectiveBeginDate)
            {
                target.EffectiveBeginDate = source.EffectiveBeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveEndDateSupported)
                && target.EffectiveEndDate != source.EffectiveEndDate)
            {
                target.EffectiveEndDate = source.EffectiveEndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNamespaceSupported)
                && target.Namespace != source.Namespace)
            {
                target.Namespace = source.Namespace;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPriorDescriptorIdSupported)
                && target.PriorDescriptorId != source.PriorDescriptorId)
            {
                target.PriorDescriptorId = source.PriorDescriptorId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsStaffClassificationTypeSupported)
                && target.StaffClassificationType != source.StaffClassificationType)
            {
                target.StaffClassificationType = source.StaffClassificationType;
                isModified = true;
            }

            // Synch inherited lists


            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStaffClassificationDescriptor source, IStaffClassificationDescriptor target, Action<IStaffClassificationDescriptor, IStaffClassificationDescriptor> onMapped)
        {
            var sourceSynchSupport = source as IStaffClassificationDescriptorSynchronizationSourceSupport;
            var targetSynchSupport = target as IStaffClassificationDescriptorSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.StaffClassificationDescriptorId = source.StaffClassificationDescriptorId;

            // Copy inherited non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsEffectiveBeginDateSupported)
                target.EffectiveBeginDate = source.EffectiveBeginDate;
            else
                targetSynchSupport.IsEffectiveBeginDateSupported = false;

            if (sourceSynchSupport.IsEffectiveEndDateSupported)
                target.EffectiveEndDate = source.EffectiveEndDate;
            else
                targetSynchSupport.IsEffectiveEndDateSupported = false;

            if (sourceSynchSupport.IsNamespaceSupported)
                target.Namespace = source.Namespace;
            else
                targetSynchSupport.IsNamespaceSupported = false;

            if (sourceSynchSupport.IsPriorDescriptorIdSupported)
                target.PriorDescriptorId = source.PriorDescriptorId;
            else
                targetSynchSupport.IsPriorDescriptorIdSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Copy non-PK properties

            if (sourceSynchSupport.IsStaffClassificationTypeSupported)
                target.StaffClassificationType = source.StaffClassificationType;
            else
                targetSynchSupport.IsStaffClassificationTypeSupported = false;

            // Map inherited lists

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStaffClassificationDescriptorSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsEffectiveBeginDateSupported { get; set; }
        bool IsEffectiveEndDateSupported { get; set; }
        bool IsNamespaceSupported { get; set; }
        bool IsPriorDescriptorIdSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
        bool IsStaffClassificationTypeSupported { get; set; }
    }
 
}
// Aggregate: StaffClassificationType

namespace EdFi.Ods.Entities.Common //.StaffClassificationTypeAggregate
{ 
    public static class StaffClassificationTypeMapper 
    {
        public static bool SynchronizeTo(this IStaffClassificationType source, IStaffClassificationType target)
        {
            bool isModified = false;

            var sourceSupport = source as IStaffClassificationTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.StaffClassificationTypeId != target.StaffClassificationTypeId)
            {
                source.StaffClassificationTypeId = target.StaffClassificationTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStaffClassificationType source, IStaffClassificationType target, Action<IStaffClassificationType, IStaffClassificationType> onMapped)
        {
            var sourceSynchSupport = source as IStaffClassificationTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IStaffClassificationTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.StaffClassificationTypeId = source.StaffClassificationTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStaffClassificationTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: StaffCohortAssociation

namespace EdFi.Ods.Entities.Common //.StaffCohortAssociationAggregate
{ 
    public static class StaffCohortAssociationMapper 
    {
        public static bool SynchronizeTo(this IStaffCohortAssociation source, IStaffCohortAssociation target)
        {
            bool isModified = false;

            var sourceSupport = source as IStaffCohortAssociationSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.BeginDate != target.BeginDate)
            {
                source.BeginDate = target.BeginDate;
            }
            if (source.CohortIdentifier != target.CohortIdentifier)
            {
                source.CohortIdentifier = target.CohortIdentifier;
            }
            if (source.EducationOrganizationId != target.EducationOrganizationId)
            {
                source.EducationOrganizationId = target.EducationOrganizationId;
            }
            if (source.StaffUniqueId != target.StaffUniqueId)
            {
                source.StaffUniqueId = target.StaffUniqueId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsEndDateSupported)
                && target.EndDate != source.EndDate)
            {
                target.EndDate = source.EndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsStudentRecordAccessSupported)
                && target.StudentRecordAccess != source.StudentRecordAccess)
            {
                target.StudentRecordAccess = source.StudentRecordAccess;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStaffCohortAssociation source, IStaffCohortAssociation target, Action<IStaffCohortAssociation, IStaffCohortAssociation> onMapped)
        {
            var sourceSynchSupport = source as IStaffCohortAssociationSynchronizationSourceSupport;
            var targetSynchSupport = target as IStaffCohortAssociationSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.BeginDate = source.BeginDate;
            target.CohortIdentifier = source.CohortIdentifier;
            target.EducationOrganizationId = source.EducationOrganizationId;
            target.StaffUniqueId = source.StaffUniqueId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsEndDateSupported)
                target.EndDate = source.EndDate;
            else
                targetSynchSupport.IsEndDateSupported = false;

            if (sourceSynchSupport.IsStudentRecordAccessSupported)
                target.StudentRecordAccess = source.StudentRecordAccess;
            else
                targetSynchSupport.IsStudentRecordAccessSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStaffCohortAssociationSynchronizationSourceSupport
    {
        bool IsEndDateSupported { get; set; }
        bool IsStudentRecordAccessSupported { get; set; }
    }
 
}
// Aggregate: StaffEducationOrganizationAssignmentAssociation

namespace EdFi.Ods.Entities.Common //.StaffEducationOrganizationAssignmentAssociationAggregate
{ 
    public static class StaffEducationOrganizationAssignmentAssociationMapper 
    {
        public static bool SynchronizeTo(this IStaffEducationOrganizationAssignmentAssociation source, IStaffEducationOrganizationAssignmentAssociation target)
        {
            bool isModified = false;

            var sourceSupport = source as IStaffEducationOrganizationAssignmentAssociationSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.BeginDate != target.BeginDate)
            {
                source.BeginDate = target.BeginDate;
            }
            if (source.EducationOrganizationId != target.EducationOrganizationId)
            {
                source.EducationOrganizationId = target.EducationOrganizationId;
            }
            if (source.StaffClassificationDescriptor != target.StaffClassificationDescriptor)
            {
                source.StaffClassificationDescriptor = target.StaffClassificationDescriptor;
            }
            if (source.StaffUniqueId != target.StaffUniqueId)
            {
                source.StaffUniqueId = target.StaffUniqueId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsEmploymentEducationOrganizationIdSupported)
                && target.EmploymentEducationOrganizationId != source.EmploymentEducationOrganizationId)
            {
                target.EmploymentEducationOrganizationId = source.EmploymentEducationOrganizationId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEmploymentHireDateSupported)
                && target.EmploymentHireDate != source.EmploymentHireDate)
            {
                target.EmploymentHireDate = source.EmploymentHireDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEmploymentStatusDescriptorSupported)
                && target.EmploymentStatusDescriptor != source.EmploymentStatusDescriptor)
            {
                target.EmploymentStatusDescriptor = source.EmploymentStatusDescriptor;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEndDateSupported)
                && target.EndDate != source.EndDate)
            {
                target.EndDate = source.EndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsOrderOfAssignmentSupported)
                && target.OrderOfAssignment != source.OrderOfAssignment)
            {
                target.OrderOfAssignment = source.OrderOfAssignment;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPositionTitleSupported)
                && target.PositionTitle != source.PositionTitle)
            {
                target.PositionTitle = source.PositionTitle;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStaffEducationOrganizationAssignmentAssociation source, IStaffEducationOrganizationAssignmentAssociation target, Action<IStaffEducationOrganizationAssignmentAssociation, IStaffEducationOrganizationAssignmentAssociation> onMapped)
        {
            var sourceSynchSupport = source as IStaffEducationOrganizationAssignmentAssociationSynchronizationSourceSupport;
            var targetSynchSupport = target as IStaffEducationOrganizationAssignmentAssociationSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.BeginDate = source.BeginDate;
            target.EducationOrganizationId = source.EducationOrganizationId;
            target.StaffClassificationDescriptor = source.StaffClassificationDescriptor;
            target.StaffUniqueId = source.StaffUniqueId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsEmploymentEducationOrganizationIdSupported)
                target.EmploymentEducationOrganizationId = source.EmploymentEducationOrganizationId;
            else
                targetSynchSupport.IsEmploymentEducationOrganizationIdSupported = false;

            if (sourceSynchSupport.IsEmploymentHireDateSupported)
                target.EmploymentHireDate = source.EmploymentHireDate;
            else
                targetSynchSupport.IsEmploymentHireDateSupported = false;

            if (sourceSynchSupport.IsEmploymentStatusDescriptorSupported)
                target.EmploymentStatusDescriptor = source.EmploymentStatusDescriptor;
            else
                targetSynchSupport.IsEmploymentStatusDescriptorSupported = false;

            if (sourceSynchSupport.IsEndDateSupported)
                target.EndDate = source.EndDate;
            else
                targetSynchSupport.IsEndDateSupported = false;

            if (sourceSynchSupport.IsOrderOfAssignmentSupported)
                target.OrderOfAssignment = source.OrderOfAssignment;
            else
                targetSynchSupport.IsOrderOfAssignmentSupported = false;

            if (sourceSynchSupport.IsPositionTitleSupported)
                target.PositionTitle = source.PositionTitle;
            else
                targetSynchSupport.IsPositionTitleSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStaffEducationOrganizationAssignmentAssociationSynchronizationSourceSupport
    {
        bool IsEmploymentEducationOrganizationIdSupported { get; set; }
        bool IsEmploymentHireDateSupported { get; set; }
        bool IsEmploymentStatusDescriptorSupported { get; set; }
        bool IsEndDateSupported { get; set; }
        bool IsOrderOfAssignmentSupported { get; set; }
        bool IsPositionTitleSupported { get; set; }
    }
 
}
// Aggregate: StaffEducationOrganizationEmploymentAssociation

namespace EdFi.Ods.Entities.Common //.StaffEducationOrganizationEmploymentAssociationAggregate
{ 
    public static class StaffEducationOrganizationEmploymentAssociationMapper 
    {
        public static bool SynchronizeTo(this IStaffEducationOrganizationEmploymentAssociation source, IStaffEducationOrganizationEmploymentAssociation target)
        {
            bool isModified = false;

            var sourceSupport = source as IStaffEducationOrganizationEmploymentAssociationSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.EducationOrganizationId != target.EducationOrganizationId)
            {
                source.EducationOrganizationId = target.EducationOrganizationId;
            }
            if (source.EmploymentStatusDescriptor != target.EmploymentStatusDescriptor)
            {
                source.EmploymentStatusDescriptor = target.EmploymentStatusDescriptor;
            }
            if (source.HireDate != target.HireDate)
            {
                source.HireDate = target.HireDate;
            }
            if (source.StaffUniqueId != target.StaffUniqueId)
            {
                source.StaffUniqueId = target.StaffUniqueId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsDepartmentSupported)
                && target.Department != source.Department)
            {
                target.Department = source.Department;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEndDateSupported)
                && target.EndDate != source.EndDate)
            {
                target.EndDate = source.EndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsFullTimeEquivalencySupported)
                && target.FullTimeEquivalency != source.FullTimeEquivalency)
            {
                target.FullTimeEquivalency = source.FullTimeEquivalency;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsHourlyWageSupported)
                && target.HourlyWage != source.HourlyWage)
            {
                target.HourlyWage = source.HourlyWage;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsOfferDateSupported)
                && target.OfferDate != source.OfferDate)
            {
                target.OfferDate = source.OfferDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsSeparationReasonDescriptorSupported)
                && target.SeparationReasonDescriptor != source.SeparationReasonDescriptor)
            {
                target.SeparationReasonDescriptor = source.SeparationReasonDescriptor;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsSeparationTypeSupported)
                && target.SeparationType != source.SeparationType)
            {
                target.SeparationType = source.SeparationType;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStaffEducationOrganizationEmploymentAssociation source, IStaffEducationOrganizationEmploymentAssociation target, Action<IStaffEducationOrganizationEmploymentAssociation, IStaffEducationOrganizationEmploymentAssociation> onMapped)
        {
            var sourceSynchSupport = source as IStaffEducationOrganizationEmploymentAssociationSynchronizationSourceSupport;
            var targetSynchSupport = target as IStaffEducationOrganizationEmploymentAssociationSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.EducationOrganizationId = source.EducationOrganizationId;
            target.EmploymentStatusDescriptor = source.EmploymentStatusDescriptor;
            target.HireDate = source.HireDate;
            target.StaffUniqueId = source.StaffUniqueId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsDepartmentSupported)
                target.Department = source.Department;
            else
                targetSynchSupport.IsDepartmentSupported = false;

            if (sourceSynchSupport.IsEndDateSupported)
                target.EndDate = source.EndDate;
            else
                targetSynchSupport.IsEndDateSupported = false;

            if (sourceSynchSupport.IsFullTimeEquivalencySupported)
                target.FullTimeEquivalency = source.FullTimeEquivalency;
            else
                targetSynchSupport.IsFullTimeEquivalencySupported = false;

            if (sourceSynchSupport.IsHourlyWageSupported)
                target.HourlyWage = source.HourlyWage;
            else
                targetSynchSupport.IsHourlyWageSupported = false;

            if (sourceSynchSupport.IsOfferDateSupported)
                target.OfferDate = source.OfferDate;
            else
                targetSynchSupport.IsOfferDateSupported = false;

            if (sourceSynchSupport.IsSeparationReasonDescriptorSupported)
                target.SeparationReasonDescriptor = source.SeparationReasonDescriptor;
            else
                targetSynchSupport.IsSeparationReasonDescriptorSupported = false;

            if (sourceSynchSupport.IsSeparationTypeSupported)
                target.SeparationType = source.SeparationType;
            else
                targetSynchSupport.IsSeparationTypeSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStaffEducationOrganizationEmploymentAssociationSynchronizationSourceSupport
    {
        bool IsDepartmentSupported { get; set; }
        bool IsEndDateSupported { get; set; }
        bool IsFullTimeEquivalencySupported { get; set; }
        bool IsHourlyWageSupported { get; set; }
        bool IsOfferDateSupported { get; set; }
        bool IsSeparationReasonDescriptorSupported { get; set; }
        bool IsSeparationTypeSupported { get; set; }
    }
 
}
// Aggregate: StaffIdentificationSystemDescriptor

namespace EdFi.Ods.Entities.Common //.StaffIdentificationSystemDescriptorAggregate
{ 
    public static class StaffIdentificationSystemDescriptorMapper 
    {
        public static bool SynchronizeTo(this IStaffIdentificationSystemDescriptor source, IStaffIdentificationSystemDescriptor target)
        {
            bool isModified = false;

            var sourceSupport = source as IStaffIdentificationSystemDescriptorSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.StaffIdentificationSystemDescriptorId != target.StaffIdentificationSystemDescriptorId)
            {
                source.StaffIdentificationSystemDescriptorId = target.StaffIdentificationSystemDescriptorId;
            }

            // Copy inherited non-PK properties


            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveBeginDateSupported)
                && target.EffectiveBeginDate != source.EffectiveBeginDate)
            {
                target.EffectiveBeginDate = source.EffectiveBeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveEndDateSupported)
                && target.EffectiveEndDate != source.EffectiveEndDate)
            {
                target.EffectiveEndDate = source.EffectiveEndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNamespaceSupported)
                && target.Namespace != source.Namespace)
            {
                target.Namespace = source.Namespace;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPriorDescriptorIdSupported)
                && target.PriorDescriptorId != source.PriorDescriptorId)
            {
                target.PriorDescriptorId = source.PriorDescriptorId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsStaffIdentificationSystemTypeSupported)
                && target.StaffIdentificationSystemType != source.StaffIdentificationSystemType)
            {
                target.StaffIdentificationSystemType = source.StaffIdentificationSystemType;
                isModified = true;
            }

            // Synch inherited lists


            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStaffIdentificationSystemDescriptor source, IStaffIdentificationSystemDescriptor target, Action<IStaffIdentificationSystemDescriptor, IStaffIdentificationSystemDescriptor> onMapped)
        {
            var sourceSynchSupport = source as IStaffIdentificationSystemDescriptorSynchronizationSourceSupport;
            var targetSynchSupport = target as IStaffIdentificationSystemDescriptorSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.StaffIdentificationSystemDescriptorId = source.StaffIdentificationSystemDescriptorId;

            // Copy inherited non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsEffectiveBeginDateSupported)
                target.EffectiveBeginDate = source.EffectiveBeginDate;
            else
                targetSynchSupport.IsEffectiveBeginDateSupported = false;

            if (sourceSynchSupport.IsEffectiveEndDateSupported)
                target.EffectiveEndDate = source.EffectiveEndDate;
            else
                targetSynchSupport.IsEffectiveEndDateSupported = false;

            if (sourceSynchSupport.IsNamespaceSupported)
                target.Namespace = source.Namespace;
            else
                targetSynchSupport.IsNamespaceSupported = false;

            if (sourceSynchSupport.IsPriorDescriptorIdSupported)
                target.PriorDescriptorId = source.PriorDescriptorId;
            else
                targetSynchSupport.IsPriorDescriptorIdSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Copy non-PK properties

            if (sourceSynchSupport.IsStaffIdentificationSystemTypeSupported)
                target.StaffIdentificationSystemType = source.StaffIdentificationSystemType;
            else
                targetSynchSupport.IsStaffIdentificationSystemTypeSupported = false;

            // Map inherited lists

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStaffIdentificationSystemDescriptorSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsEffectiveBeginDateSupported { get; set; }
        bool IsEffectiveEndDateSupported { get; set; }
        bool IsNamespaceSupported { get; set; }
        bool IsPriorDescriptorIdSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
        bool IsStaffIdentificationSystemTypeSupported { get; set; }
    }
 
}
// Aggregate: StaffIdentificationSystemType

namespace EdFi.Ods.Entities.Common //.StaffIdentificationSystemTypeAggregate
{ 
    public static class StaffIdentificationSystemTypeMapper 
    {
        public static bool SynchronizeTo(this IStaffIdentificationSystemType source, IStaffIdentificationSystemType target)
        {
            bool isModified = false;

            var sourceSupport = source as IStaffIdentificationSystemTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.StaffIdentificationSystemTypeId != target.StaffIdentificationSystemTypeId)
            {
                source.StaffIdentificationSystemTypeId = target.StaffIdentificationSystemTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStaffIdentificationSystemType source, IStaffIdentificationSystemType target, Action<IStaffIdentificationSystemType, IStaffIdentificationSystemType> onMapped)
        {
            var sourceSynchSupport = source as IStaffIdentificationSystemTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IStaffIdentificationSystemTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.StaffIdentificationSystemTypeId = source.StaffIdentificationSystemTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStaffIdentificationSystemTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: StaffProgramAssociation

namespace EdFi.Ods.Entities.Common //.StaffProgramAssociationAggregate
{ 
    public static class StaffProgramAssociationMapper 
    {
        public static bool SynchronizeTo(this IStaffProgramAssociation source, IStaffProgramAssociation target)
        {
            bool isModified = false;

            var sourceSupport = source as IStaffProgramAssociationSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.BeginDate != target.BeginDate)
            {
                source.BeginDate = target.BeginDate;
            }
            if (source.ProgramEducationOrganizationId != target.ProgramEducationOrganizationId)
            {
                source.ProgramEducationOrganizationId = target.ProgramEducationOrganizationId;
            }
            if (source.ProgramName != target.ProgramName)
            {
                source.ProgramName = target.ProgramName;
            }
            if (source.ProgramType != target.ProgramType)
            {
                source.ProgramType = target.ProgramType;
            }
            if (source.StaffUniqueId != target.StaffUniqueId)
            {
                source.StaffUniqueId = target.StaffUniqueId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsEndDateSupported)
                && target.EndDate != source.EndDate)
            {
                target.EndDate = source.EndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsStudentRecordAccessSupported)
                && target.StudentRecordAccess != source.StudentRecordAccess)
            {
                target.StudentRecordAccess = source.StudentRecordAccess;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStaffProgramAssociation source, IStaffProgramAssociation target, Action<IStaffProgramAssociation, IStaffProgramAssociation> onMapped)
        {
            var sourceSynchSupport = source as IStaffProgramAssociationSynchronizationSourceSupport;
            var targetSynchSupport = target as IStaffProgramAssociationSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.BeginDate = source.BeginDate;
            target.ProgramEducationOrganizationId = source.ProgramEducationOrganizationId;
            target.ProgramName = source.ProgramName;
            target.ProgramType = source.ProgramType;
            target.StaffUniqueId = source.StaffUniqueId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsEndDateSupported)
                target.EndDate = source.EndDate;
            else
                targetSynchSupport.IsEndDateSupported = false;

            if (sourceSynchSupport.IsStudentRecordAccessSupported)
                target.StudentRecordAccess = source.StudentRecordAccess;
            else
                targetSynchSupport.IsStudentRecordAccessSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStaffProgramAssociationSynchronizationSourceSupport
    {
        bool IsEndDateSupported { get; set; }
        bool IsStudentRecordAccessSupported { get; set; }
    }
 
}
// Aggregate: StaffSchoolAssociation

namespace EdFi.Ods.Entities.Common //.StaffSchoolAssociationAggregate
{ 
    public static class StaffSchoolAssociationMapper 
    {
        public static bool SynchronizeTo(this IStaffSchoolAssociation source, IStaffSchoolAssociation target)
        {
            bool isModified = false;

            var sourceSupport = source as IStaffSchoolAssociationSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.ProgramAssignmentDescriptor != target.ProgramAssignmentDescriptor)
            {
                source.ProgramAssignmentDescriptor = target.ProgramAssignmentDescriptor;
            }
            if (source.SchoolId != target.SchoolId)
            {
                source.SchoolId = target.SchoolId;
            }
            if (source.StaffUniqueId != target.StaffUniqueId)
            {
                source.StaffUniqueId = target.StaffUniqueId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsSchoolYearSupported)
                && target.SchoolYear != source.SchoolYear)
            {
                target.SchoolYear = source.SchoolYear;
                isModified = true;
            }



            // Sync lists
            if (sourceSupport == null || sourceSupport.IsStaffSchoolAssociationAcademicSubjectsSupported)
                isModified |= source.StaffSchoolAssociationAcademicSubjects.SynchronizeListTo(target.StaffSchoolAssociationAcademicSubjects, child => child.StaffSchoolAssociation = target,
                                sourceSupport == null ? null : sourceSupport.IsStaffSchoolAssociationAcademicSubjectIncluded);

            if (sourceSupport == null || sourceSupport.IsStaffSchoolAssociationGradeLevelsSupported)
                isModified |= source.StaffSchoolAssociationGradeLevels.SynchronizeListTo(target.StaffSchoolAssociationGradeLevels, child => child.StaffSchoolAssociation = target,
                                sourceSupport == null ? null : sourceSupport.IsStaffSchoolAssociationGradeLevelIncluded);


            return isModified;
        }



        public static void MapTo(this IStaffSchoolAssociation source, IStaffSchoolAssociation target, Action<IStaffSchoolAssociation, IStaffSchoolAssociation> onMapped)
        {
            var sourceSynchSupport = source as IStaffSchoolAssociationSynchronizationSourceSupport;
            var targetSynchSupport = target as IStaffSchoolAssociationSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.ProgramAssignmentDescriptor = source.ProgramAssignmentDescriptor;
            target.SchoolId = source.SchoolId;
            target.StaffUniqueId = source.StaffUniqueId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsSchoolYearSupported)
                target.SchoolYear = source.SchoolYear;
            else
                targetSynchSupport.IsSchoolYearSupported = false;

            // Map lists

            if (sourceSynchSupport.IsStaffSchoolAssociationAcademicSubjectsSupported)
            {    
                targetSynchSupport.IsStaffSchoolAssociationAcademicSubjectIncluded = sourceSynchSupport.IsStaffSchoolAssociationAcademicSubjectIncluded;
                source.StaffSchoolAssociationAcademicSubjects.MapListTo(target.StaffSchoolAssociationAcademicSubjects);
            }
            else
            {
                targetSynchSupport.IsStaffSchoolAssociationAcademicSubjectsSupported = false;
            }

            if (sourceSynchSupport.IsStaffSchoolAssociationGradeLevelsSupported)
            {    
                targetSynchSupport.IsStaffSchoolAssociationGradeLevelIncluded = sourceSynchSupport.IsStaffSchoolAssociationGradeLevelIncluded;
                source.StaffSchoolAssociationGradeLevels.MapListTo(target.StaffSchoolAssociationGradeLevels);
            }
            else
            {
                targetSynchSupport.IsStaffSchoolAssociationGradeLevelsSupported = false;
            }

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStaffSchoolAssociationSynchronizationSourceSupport
    {
        bool IsSchoolYearSupported { get; set; }
        bool IsStaffSchoolAssociationAcademicSubjectsSupported { get; set; }
        bool IsStaffSchoolAssociationGradeLevelsSupported { get; set; }
        Func<IStaffSchoolAssociationAcademicSubject, bool> IsStaffSchoolAssociationAcademicSubjectIncluded { get; set; }
        Func<IStaffSchoolAssociationGradeLevel, bool> IsStaffSchoolAssociationGradeLevelIncluded { get; set; }
    }
 
    public static class StaffSchoolAssociationAcademicSubjectMapper 
    {
        public static bool SynchronizeTo(this IStaffSchoolAssociationAcademicSubject source, IStaffSchoolAssociationAcademicSubject target)
        {
            bool isModified = false;

            var sourceSupport = source as IStaffSchoolAssociationAcademicSubjectSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AcademicSubjectDescriptor != target.AcademicSubjectDescriptor)
            {
                source.AcademicSubjectDescriptor = target.AcademicSubjectDescriptor;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStaffSchoolAssociationAcademicSubject source, IStaffSchoolAssociationAcademicSubject target, Action<IStaffSchoolAssociationAcademicSubject, IStaffSchoolAssociationAcademicSubject> onMapped)
        {
            var sourceSynchSupport = source as IStaffSchoolAssociationAcademicSubjectSynchronizationSourceSupport;
            var targetSynchSupport = target as IStaffSchoolAssociationAcademicSubjectSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.AcademicSubjectDescriptor = source.AcademicSubjectDescriptor;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStaffSchoolAssociationAcademicSubjectSynchronizationSourceSupport
    {
    }
 
    public static class StaffSchoolAssociationGradeLevelMapper 
    {
        public static bool SynchronizeTo(this IStaffSchoolAssociationGradeLevel source, IStaffSchoolAssociationGradeLevel target)
        {
            bool isModified = false;

            var sourceSupport = source as IStaffSchoolAssociationGradeLevelSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.GradeLevelDescriptor != target.GradeLevelDescriptor)
            {
                source.GradeLevelDescriptor = target.GradeLevelDescriptor;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStaffSchoolAssociationGradeLevel source, IStaffSchoolAssociationGradeLevel target, Action<IStaffSchoolAssociationGradeLevel, IStaffSchoolAssociationGradeLevel> onMapped)
        {
            var sourceSynchSupport = source as IStaffSchoolAssociationGradeLevelSynchronizationSourceSupport;
            var targetSynchSupport = target as IStaffSchoolAssociationGradeLevelSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.GradeLevelDescriptor = source.GradeLevelDescriptor;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStaffSchoolAssociationGradeLevelSynchronizationSourceSupport
    {
    }
 
}
// Aggregate: StaffSectionAssociation

namespace EdFi.Ods.Entities.Common //.StaffSectionAssociationAggregate
{ 
    public static class StaffSectionAssociationMapper 
    {
        public static bool SynchronizeTo(this IStaffSectionAssociation source, IStaffSectionAssociation target)
        {
            bool isModified = false;

            var sourceSupport = source as IStaffSectionAssociationSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.ClassPeriodName != target.ClassPeriodName)
            {
                source.ClassPeriodName = target.ClassPeriodName;
            }
            if (source.ClassroomIdentificationCode != target.ClassroomIdentificationCode)
            {
                source.ClassroomIdentificationCode = target.ClassroomIdentificationCode;
            }
            if (source.LocalCourseCode != target.LocalCourseCode)
            {
                source.LocalCourseCode = target.LocalCourseCode;
            }
            if (source.SchoolId != target.SchoolId)
            {
                source.SchoolId = target.SchoolId;
            }
            if (source.SchoolYear != target.SchoolYear)
            {
                source.SchoolYear = target.SchoolYear;
            }
            if (source.SequenceOfCourse != target.SequenceOfCourse)
            {
                source.SequenceOfCourse = target.SequenceOfCourse;
            }
            if (source.StaffUniqueId != target.StaffUniqueId)
            {
                source.StaffUniqueId = target.StaffUniqueId;
            }
            if (source.TermDescriptor != target.TermDescriptor)
            {
                source.TermDescriptor = target.TermDescriptor;
            }
            if (source.UniqueSectionCode != target.UniqueSectionCode)
            {
                source.UniqueSectionCode = target.UniqueSectionCode;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsBeginDateSupported)
                && target.BeginDate != source.BeginDate)
            {
                target.BeginDate = source.BeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsClassroomPositionDescriptorSupported)
                && target.ClassroomPositionDescriptor != source.ClassroomPositionDescriptor)
            {
                target.ClassroomPositionDescriptor = source.ClassroomPositionDescriptor;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEndDateSupported)
                && target.EndDate != source.EndDate)
            {
                target.EndDate = source.EndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsHighlyQualifiedTeacherSupported)
                && target.HighlyQualifiedTeacher != source.HighlyQualifiedTeacher)
            {
                target.HighlyQualifiedTeacher = source.HighlyQualifiedTeacher;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPercentageContributionSupported)
                && target.PercentageContribution != source.PercentageContribution)
            {
                target.PercentageContribution = source.PercentageContribution;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsTeacherStudentDataLinkExclusionSupported)
                && target.TeacherStudentDataLinkExclusion != source.TeacherStudentDataLinkExclusion)
            {
                target.TeacherStudentDataLinkExclusion = source.TeacherStudentDataLinkExclusion;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStaffSectionAssociation source, IStaffSectionAssociation target, Action<IStaffSectionAssociation, IStaffSectionAssociation> onMapped)
        {
            var sourceSynchSupport = source as IStaffSectionAssociationSynchronizationSourceSupport;
            var targetSynchSupport = target as IStaffSectionAssociationSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.ClassPeriodName = source.ClassPeriodName;
            target.ClassroomIdentificationCode = source.ClassroomIdentificationCode;
            target.LocalCourseCode = source.LocalCourseCode;
            target.SchoolId = source.SchoolId;
            target.SchoolYear = source.SchoolYear;
            target.SequenceOfCourse = source.SequenceOfCourse;
            target.StaffUniqueId = source.StaffUniqueId;
            target.TermDescriptor = source.TermDescriptor;
            target.UniqueSectionCode = source.UniqueSectionCode;

            // Copy non-PK properties

            if (sourceSynchSupport.IsBeginDateSupported)
                target.BeginDate = source.BeginDate;
            else
                targetSynchSupport.IsBeginDateSupported = false;

            if (sourceSynchSupport.IsClassroomPositionDescriptorSupported)
                target.ClassroomPositionDescriptor = source.ClassroomPositionDescriptor;
            else
                targetSynchSupport.IsClassroomPositionDescriptorSupported = false;

            if (sourceSynchSupport.IsEndDateSupported)
                target.EndDate = source.EndDate;
            else
                targetSynchSupport.IsEndDateSupported = false;

            if (sourceSynchSupport.IsHighlyQualifiedTeacherSupported)
                target.HighlyQualifiedTeacher = source.HighlyQualifiedTeacher;
            else
                targetSynchSupport.IsHighlyQualifiedTeacherSupported = false;

            if (sourceSynchSupport.IsPercentageContributionSupported)
                target.PercentageContribution = source.PercentageContribution;
            else
                targetSynchSupport.IsPercentageContributionSupported = false;

            if (sourceSynchSupport.IsTeacherStudentDataLinkExclusionSupported)
                target.TeacherStudentDataLinkExclusion = source.TeacherStudentDataLinkExclusion;
            else
                targetSynchSupport.IsTeacherStudentDataLinkExclusionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStaffSectionAssociationSynchronizationSourceSupport
    {
        bool IsBeginDateSupported { get; set; }
        bool IsClassroomPositionDescriptorSupported { get; set; }
        bool IsEndDateSupported { get; set; }
        bool IsHighlyQualifiedTeacherSupported { get; set; }
        bool IsPercentageContributionSupported { get; set; }
        bool IsTeacherStudentDataLinkExclusionSupported { get; set; }
    }
 
}
// Aggregate: StateAbbreviationType

namespace EdFi.Ods.Entities.Common //.StateAbbreviationTypeAggregate
{ 
    public static class StateAbbreviationTypeMapper 
    {
        public static bool SynchronizeTo(this IStateAbbreviationType source, IStateAbbreviationType target)
        {
            bool isModified = false;

            var sourceSupport = source as IStateAbbreviationTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.StateAbbreviationTypeId != target.StateAbbreviationTypeId)
            {
                source.StateAbbreviationTypeId = target.StateAbbreviationTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStateAbbreviationType source, IStateAbbreviationType target, Action<IStateAbbreviationType, IStateAbbreviationType> onMapped)
        {
            var sourceSynchSupport = source as IStateAbbreviationTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IStateAbbreviationTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.StateAbbreviationTypeId = source.StateAbbreviationTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStateAbbreviationTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: StateEducationAgency

namespace EdFi.Ods.Entities.Common //.StateEducationAgencyAggregate
{ 
    public static class StateEducationAgencyMapper 
    {
        public static bool SynchronizeTo(this IStateEducationAgency source, IStateEducationAgency target)
        {
            bool isModified = false;

            var sourceSupport = source as IStateEducationAgencySynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.StateEducationAgencyId != target.StateEducationAgencyId)
            {
                source.StateEducationAgencyId = target.StateEducationAgencyId;
            }

            // Copy inherited non-PK properties


            if ((sourceSupport == null || sourceSupport.IsNameOfInstitutionSupported)
                && target.NameOfInstitution != source.NameOfInstitution)
            {
                target.NameOfInstitution = source.NameOfInstitution;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsOperationalStatusTypeSupported)
                && target.OperationalStatusType != source.OperationalStatusType)
            {
                target.OperationalStatusType = source.OperationalStatusType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortNameOfInstitutionSupported)
                && target.ShortNameOfInstitution != source.ShortNameOfInstitution)
            {
                target.ShortNameOfInstitution = source.ShortNameOfInstitution;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsStateOrganizationIdSupported)
                && target.StateOrganizationId != source.StateOrganizationId)
            {
                target.StateOrganizationId = source.StateOrganizationId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsWebSiteSupported)
                && target.WebSite != source.WebSite)
            {
                target.WebSite = source.WebSite;
                isModified = true;
            }

            // Copy non-PK properties

            // Synch inherited lists
            if (sourceSupport == null || sourceSupport.IsEducationOrganizationAddressesSupported)
                isModified |= source.EducationOrganizationAddresses.SynchronizeListTo(target.EducationOrganizationAddresses, child => child.EducationOrganization = target,
                                sourceSupport == null ? null : sourceSupport.IsEducationOrganizationAddressIncluded);

            if (sourceSupport == null || sourceSupport.IsEducationOrganizationCategoriesSupported)
                isModified |= source.EducationOrganizationCategories.SynchronizeListTo(target.EducationOrganizationCategories, child => child.EducationOrganization = target,
                                sourceSupport == null ? null : sourceSupport.IsEducationOrganizationCategoryIncluded);

            if (sourceSupport == null || sourceSupport.IsEducationOrganizationIdentificationCodesSupported)
                isModified |= source.EducationOrganizationIdentificationCodes.SynchronizeListTo(target.EducationOrganizationIdentificationCodes, child => child.EducationOrganization = target,
                                sourceSupport == null ? null : sourceSupport.IsEducationOrganizationIdentificationCodeIncluded);

            if (sourceSupport == null || sourceSupport.IsEducationOrganizationInstitutionTelephonesSupported)
                isModified |= source.EducationOrganizationInstitutionTelephones.SynchronizeListTo(target.EducationOrganizationInstitutionTelephones, child => child.EducationOrganization = target,
                                sourceSupport == null ? null : sourceSupport.IsEducationOrganizationInstitutionTelephoneIncluded);

            if (sourceSupport == null || sourceSupport.IsEducationOrganizationInternationalAddressesSupported)
                isModified |= source.EducationOrganizationInternationalAddresses.SynchronizeListTo(target.EducationOrganizationInternationalAddresses, child => child.EducationOrganization = target,
                                sourceSupport == null ? null : sourceSupport.IsEducationOrganizationInternationalAddressIncluded);



            // Sync lists
            if (sourceSupport == null || sourceSupport.IsStateEducationAgencyAccountabilitiesSupported)
                isModified |= source.StateEducationAgencyAccountabilities.SynchronizeListTo(target.StateEducationAgencyAccountabilities, child => child.StateEducationAgency = target,
                                sourceSupport == null ? null : sourceSupport.IsStateEducationAgencyAccountabilityIncluded);


            return isModified;
        }



        public static void MapTo(this IStateEducationAgency source, IStateEducationAgency target, Action<IStateEducationAgency, IStateEducationAgency> onMapped)
        {
            var sourceSynchSupport = source as IStateEducationAgencySynchronizationSourceSupport;
            var targetSynchSupport = target as IStateEducationAgencySynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.StateEducationAgencyId = source.StateEducationAgencyId;

            // Copy inherited non-PK properties

            if (sourceSynchSupport.IsNameOfInstitutionSupported)
                target.NameOfInstitution = source.NameOfInstitution;
            else
                targetSynchSupport.IsNameOfInstitutionSupported = false;

            if (sourceSynchSupport.IsOperationalStatusTypeSupported)
                target.OperationalStatusType = source.OperationalStatusType;
            else
                targetSynchSupport.IsOperationalStatusTypeSupported = false;

            if (sourceSynchSupport.IsShortNameOfInstitutionSupported)
                target.ShortNameOfInstitution = source.ShortNameOfInstitution;
            else
                targetSynchSupport.IsShortNameOfInstitutionSupported = false;

            if (sourceSynchSupport.IsStateOrganizationIdSupported)
                target.StateOrganizationId = source.StateOrganizationId;
            else
                targetSynchSupport.IsStateOrganizationIdSupported = false;

            if (sourceSynchSupport.IsWebSiteSupported)
                target.WebSite = source.WebSite;
            else
                targetSynchSupport.IsWebSiteSupported = false;

            // Copy non-PK properties

            // Map inherited lists

            if (sourceSynchSupport.IsEducationOrganizationAddressesSupported)
            {
                targetSynchSupport.IsEducationOrganizationAddressIncluded = sourceSynchSupport.IsEducationOrganizationAddressIncluded;
                source.EducationOrganizationAddresses.MapListTo(target.EducationOrganizationAddresses);
            }
            else
            {
                targetSynchSupport.IsEducationOrganizationAddressesSupported = false;
            }

            if (sourceSynchSupport.IsEducationOrganizationCategoriesSupported)
            {
                targetSynchSupport.IsEducationOrganizationCategoryIncluded = sourceSynchSupport.IsEducationOrganizationCategoryIncluded;
                source.EducationOrganizationCategories.MapListTo(target.EducationOrganizationCategories);
            }
            else
            {
                targetSynchSupport.IsEducationOrganizationCategoriesSupported = false;
            }

            if (sourceSynchSupport.IsEducationOrganizationIdentificationCodesSupported)
            {
                targetSynchSupport.IsEducationOrganizationIdentificationCodeIncluded = sourceSynchSupport.IsEducationOrganizationIdentificationCodeIncluded;
                source.EducationOrganizationIdentificationCodes.MapListTo(target.EducationOrganizationIdentificationCodes);
            }
            else
            {
                targetSynchSupport.IsEducationOrganizationIdentificationCodesSupported = false;
            }

            if (sourceSynchSupport.IsEducationOrganizationInstitutionTelephonesSupported)
            {
                targetSynchSupport.IsEducationOrganizationInstitutionTelephoneIncluded = sourceSynchSupport.IsEducationOrganizationInstitutionTelephoneIncluded;
                source.EducationOrganizationInstitutionTelephones.MapListTo(target.EducationOrganizationInstitutionTelephones);
            }
            else
            {
                targetSynchSupport.IsEducationOrganizationInstitutionTelephonesSupported = false;
            }

            if (sourceSynchSupport.IsEducationOrganizationInternationalAddressesSupported)
            {
                targetSynchSupport.IsEducationOrganizationInternationalAddressIncluded = sourceSynchSupport.IsEducationOrganizationInternationalAddressIncluded;
                source.EducationOrganizationInternationalAddresses.MapListTo(target.EducationOrganizationInternationalAddresses);
            }
            else
            {
                targetSynchSupport.IsEducationOrganizationInternationalAddressesSupported = false;
            }

            // Map lists

            if (sourceSynchSupport.IsStateEducationAgencyAccountabilitiesSupported)
            {    
                targetSynchSupport.IsStateEducationAgencyAccountabilityIncluded = sourceSynchSupport.IsStateEducationAgencyAccountabilityIncluded;
                source.StateEducationAgencyAccountabilities.MapListTo(target.StateEducationAgencyAccountabilities);
            }
            else
            {
                targetSynchSupport.IsStateEducationAgencyAccountabilitiesSupported = false;
            }

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStateEducationAgencySynchronizationSourceSupport
    {
        bool IsEducationOrganizationAddressesSupported { get; set; }
        bool IsEducationOrganizationCategoriesSupported { get; set; }
        bool IsEducationOrganizationIdentificationCodesSupported { get; set; }
        bool IsEducationOrganizationInstitutionTelephonesSupported { get; set; }
        bool IsEducationOrganizationInternationalAddressesSupported { get; set; }
        bool IsNameOfInstitutionSupported { get; set; }
        bool IsOperationalStatusTypeSupported { get; set; }
        bool IsShortNameOfInstitutionSupported { get; set; }
        bool IsStateEducationAgencyAccountabilitiesSupported { get; set; }
        bool IsStateOrganizationIdSupported { get; set; }
        bool IsWebSiteSupported { get; set; }
        Func<IEducationOrganizationAddress, bool> IsEducationOrganizationAddressIncluded { get; set; }
        Func<IEducationOrganizationCategory, bool> IsEducationOrganizationCategoryIncluded { get; set; }
        Func<IEducationOrganizationIdentificationCode, bool> IsEducationOrganizationIdentificationCodeIncluded { get; set; }
        Func<IEducationOrganizationInstitutionTelephone, bool> IsEducationOrganizationInstitutionTelephoneIncluded { get; set; }
        Func<IEducationOrganizationInternationalAddress, bool> IsEducationOrganizationInternationalAddressIncluded { get; set; }
        Func<IStateEducationAgencyAccountability, bool> IsStateEducationAgencyAccountabilityIncluded { get; set; }
    }
 
    public static class StateEducationAgencyAccountabilityMapper 
    {
        public static bool SynchronizeTo(this IStateEducationAgencyAccountability source, IStateEducationAgencyAccountability target)
        {
            bool isModified = false;

            var sourceSupport = source as IStateEducationAgencyAccountabilitySynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.SchoolYear != target.SchoolYear)
            {
                source.SchoolYear = target.SchoolYear;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCTEGraduationRateInclusionSupported)
                && target.CTEGraduationRateInclusion != source.CTEGraduationRateInclusion)
            {
                target.CTEGraduationRateInclusion = source.CTEGraduationRateInclusion;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStateEducationAgencyAccountability source, IStateEducationAgencyAccountability target, Action<IStateEducationAgencyAccountability, IStateEducationAgencyAccountability> onMapped)
        {
            var sourceSynchSupport = source as IStateEducationAgencyAccountabilitySynchronizationSourceSupport;
            var targetSynchSupport = target as IStateEducationAgencyAccountabilitySynchronizationSourceSupport;

            // Copy contextual primary key values
            target.SchoolYear = source.SchoolYear;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCTEGraduationRateInclusionSupported)
                target.CTEGraduationRateInclusion = source.CTEGraduationRateInclusion;
            else
                targetSynchSupport.IsCTEGraduationRateInclusionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStateEducationAgencyAccountabilitySynchronizationSourceSupport
    {
        bool IsCTEGraduationRateInclusionSupported { get; set; }
    }
 
}
// Aggregate: Student

namespace EdFi.Ods.Entities.Common //.StudentAggregate
{ 
    public static class StudentMapper 
    {
        public static bool SynchronizeTo(this IStudent source, IStudent target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsBirthCitySupported)
                && target.BirthCity != source.BirthCity)
            {
                target.BirthCity = source.BirthCity;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsBirthCountryDescriptorSupported)
                && target.BirthCountryDescriptor != source.BirthCountryDescriptor)
            {
                target.BirthCountryDescriptor = source.BirthCountryDescriptor;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsBirthDateSupported)
                && target.BirthDate != source.BirthDate)
            {
                target.BirthDate = source.BirthDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsBirthInternationalProvinceSupported)
                && target.BirthInternationalProvince != source.BirthInternationalProvince)
            {
                target.BirthInternationalProvince = source.BirthInternationalProvince;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsBirthStateAbbreviationTypeSupported)
                && target.BirthStateAbbreviationType != source.BirthStateAbbreviationType)
            {
                target.BirthStateAbbreviationType = source.BirthStateAbbreviationType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsCitizenshipStatusTypeSupported)
                && target.CitizenshipStatusType != source.CitizenshipStatusType)
            {
                target.CitizenshipStatusType = source.CitizenshipStatusType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDateEnteredUSSupported)
                && target.DateEnteredUS != source.DateEnteredUS)
            {
                target.DateEnteredUS = source.DateEnteredUS;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDisplacementStatusSupported)
                && target.DisplacementStatus != source.DisplacementStatus)
            {
                target.DisplacementStatus = source.DisplacementStatus;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEconomicDisadvantagedSupported)
                && target.EconomicDisadvantaged != source.EconomicDisadvantaged)
            {
                target.EconomicDisadvantaged = source.EconomicDisadvantaged;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsFirstNameSupported)
                && target.FirstName != source.FirstName)
            {
                target.FirstName = source.FirstName;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsGenerationCodeSuffixSupported)
                && target.GenerationCodeSuffix != source.GenerationCodeSuffix)
            {
                target.GenerationCodeSuffix = source.GenerationCodeSuffix;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsHispanicLatinoEthnicitySupported)
                && target.HispanicLatinoEthnicity != source.HispanicLatinoEthnicity)
            {
                target.HispanicLatinoEthnicity = source.HispanicLatinoEthnicity;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsLastSurnameSupported)
                && target.LastSurname != source.LastSurname)
            {
                target.LastSurname = source.LastSurname;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsLimitedEnglishProficiencyDescriptorSupported)
                && target.LimitedEnglishProficiencyDescriptor != source.LimitedEnglishProficiencyDescriptor)
            {
                target.LimitedEnglishProficiencyDescriptor = source.LimitedEnglishProficiencyDescriptor;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsLoginIdSupported)
                && target.LoginId != source.LoginId)
            {
                target.LoginId = source.LoginId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsMaidenNameSupported)
                && target.MaidenName != source.MaidenName)
            {
                target.MaidenName = source.MaidenName;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsMiddleNameSupported)
                && target.MiddleName != source.MiddleName)
            {
                target.MiddleName = source.MiddleName;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsMultipleBirthStatusSupported)
                && target.MultipleBirthStatus != source.MultipleBirthStatus)
            {
                target.MultipleBirthStatus = source.MultipleBirthStatus;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsOldEthnicityTypeSupported)
                && target.OldEthnicityType != source.OldEthnicityType)
            {
                target.OldEthnicityType = source.OldEthnicityType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPersonalTitlePrefixSupported)
                && target.PersonalTitlePrefix != source.PersonalTitlePrefix)
            {
                target.PersonalTitlePrefix = source.PersonalTitlePrefix;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsProfileThumbnailSupported)
                && target.ProfileThumbnail != source.ProfileThumbnail)
            {
                target.ProfileThumbnail = source.ProfileThumbnail;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsSchoolFoodServicesEligibilityDescriptorSupported)
                && target.SchoolFoodServicesEligibilityDescriptor != source.SchoolFoodServicesEligibilityDescriptor)
            {
                target.SchoolFoodServicesEligibilityDescriptor = source.SchoolFoodServicesEligibilityDescriptor;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsSexTypeSupported)
                && target.SexType != source.SexType)
            {
                target.SexType = source.SexType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsStudentUniqueIdSupported)
                && target.StudentUniqueId != source.StudentUniqueId)
            {
                target.StudentUniqueId = source.StudentUniqueId;
                isModified = true;
            }

            // ----------------------------------            
            //   Synch One-to-one relationships
            // ----------------------------------            
            // StudentLearningStyle
            if (sourceSupport == null || sourceSupport.IsStudentLearningStyleSupported)
            {
                if (source.StudentLearningStyle == null)
                {
                    if (target.StudentLearningStyle != null)
                    {
                        target.StudentLearningStyle = null;
                        isModified = true;
                    }
                }
                else
                {
                    if (target.StudentLearningStyle == null)
                    {
                        var itemType = target.GetType().GetProperty("StudentLearningStyle").PropertyType;
                        var newItem = Activator.CreateInstance(itemType);
                        target.StudentLearningStyle = (IStudentLearningStyle) newItem;
                    }

                    isModified |= source.StudentLearningStyle.Synchronize(target.StudentLearningStyle);
                }
            }
            
            // -------------------------------------------------------------



            // Sync lists
            if (sourceSupport == null || sourceSupport.IsStudentAddressesSupported)
                isModified |= source.StudentAddresses.SynchronizeListTo(target.StudentAddresses, child => child.Student = target,
                                sourceSupport == null ? null : sourceSupport.IsStudentAddressIncluded);

            if (sourceSupport == null || sourceSupport.IsStudentCharacteristicsSupported)
                isModified |= source.StudentCharacteristics.SynchronizeListTo(target.StudentCharacteristics, child => child.Student = target,
                                sourceSupport == null ? null : sourceSupport.IsStudentCharacteristicIncluded);

            if (sourceSupport == null || sourceSupport.IsStudentCohortYearsSupported)
                isModified |= source.StudentCohortYears.SynchronizeListTo(target.StudentCohortYears, child => child.Student = target,
                                sourceSupport == null ? null : sourceSupport.IsStudentCohortYearIncluded);

            if (sourceSupport == null || sourceSupport.IsStudentDisabilitiesSupported)
                isModified |= source.StudentDisabilities.SynchronizeListTo(target.StudentDisabilities, child => child.Student = target,
                                sourceSupport == null ? null : sourceSupport.IsStudentDisabilityIncluded);

            if (sourceSupport == null || sourceSupport.IsStudentElectronicMailsSupported)
                isModified |= source.StudentElectronicMails.SynchronizeListTo(target.StudentElectronicMails, child => child.Student = target,
                                sourceSupport == null ? null : sourceSupport.IsStudentElectronicMailIncluded);

            if (sourceSupport == null || sourceSupport.IsStudentIdentificationCodesSupported)
                isModified |= source.StudentIdentificationCodes.SynchronizeListTo(target.StudentIdentificationCodes, child => child.Student = target,
                                sourceSupport == null ? null : sourceSupport.IsStudentIdentificationCodeIncluded);

            if (sourceSupport == null || sourceSupport.IsStudentIdentificationDocumentsSupported)
                isModified |= source.StudentIdentificationDocuments.SynchronizeListTo(target.StudentIdentificationDocuments, child => child.Student = target,
                                sourceSupport == null ? null : sourceSupport.IsStudentIdentificationDocumentIncluded);

            if (sourceSupport == null || sourceSupport.IsStudentIndicatorsSupported)
                isModified |= source.StudentIndicators.SynchronizeListTo(target.StudentIndicators, child => child.Student = target,
                                sourceSupport == null ? null : sourceSupport.IsStudentIndicatorIncluded);

            if (sourceSupport == null || sourceSupport.IsStudentInternationalAddressesSupported)
                isModified |= source.StudentInternationalAddresses.SynchronizeListTo(target.StudentInternationalAddresses, child => child.Student = target,
                                sourceSupport == null ? null : sourceSupport.IsStudentInternationalAddressIncluded);

            if (sourceSupport == null || sourceSupport.IsStudentLanguagesSupported)
                isModified |= source.StudentLanguages.SynchronizeListTo(target.StudentLanguages, child => child.Student = target,
                                sourceSupport == null ? null : sourceSupport.IsStudentLanguageIncluded);

            if (sourceSupport == null || sourceSupport.IsStudentOtherNamesSupported)
                isModified |= source.StudentOtherNames.SynchronizeListTo(target.StudentOtherNames, child => child.Student = target,
                                sourceSupport == null ? null : sourceSupport.IsStudentOtherNameIncluded);

            if (sourceSupport == null || sourceSupport.IsStudentProgramParticipationsSupported)
                isModified |= source.StudentProgramParticipations.SynchronizeListTo(target.StudentProgramParticipations, child => child.Student = target,
                                sourceSupport == null ? null : sourceSupport.IsStudentProgramParticipationIncluded);

            if (sourceSupport == null || sourceSupport.IsStudentRacesSupported)
                isModified |= source.StudentRaces.SynchronizeListTo(target.StudentRaces, child => child.Student = target,
                                sourceSupport == null ? null : sourceSupport.IsStudentRaceIncluded);

            if (sourceSupport == null || sourceSupport.IsStudentTelephonesSupported)
                isModified |= source.StudentTelephones.SynchronizeListTo(target.StudentTelephones, child => child.Student = target,
                                sourceSupport == null ? null : sourceSupport.IsStudentTelephoneIncluded);

            if (sourceSupport == null || sourceSupport.IsStudentVisasSupported)
                isModified |= source.StudentVisas.SynchronizeListTo(target.StudentVisas, child => child.Student = target,
                                sourceSupport == null ? null : sourceSupport.IsStudentVisaIncluded);


            return isModified;
        }



        public static void MapTo(this IStudent source, IStudent target, Action<IStudent, IStudent> onMapped)
        {
            var sourceSynchSupport = source as IStudentSynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.StudentUniqueId = source.StudentUniqueId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsBirthCitySupported)
                target.BirthCity = source.BirthCity;
            else
                targetSynchSupport.IsBirthCitySupported = false;

            if (sourceSynchSupport.IsBirthCountryDescriptorSupported)
                target.BirthCountryDescriptor = source.BirthCountryDescriptor;
            else
                targetSynchSupport.IsBirthCountryDescriptorSupported = false;

            if (sourceSynchSupport.IsBirthDateSupported)
                target.BirthDate = source.BirthDate;
            else
                targetSynchSupport.IsBirthDateSupported = false;

            if (sourceSynchSupport.IsBirthInternationalProvinceSupported)
                target.BirthInternationalProvince = source.BirthInternationalProvince;
            else
                targetSynchSupport.IsBirthInternationalProvinceSupported = false;

            if (sourceSynchSupport.IsBirthStateAbbreviationTypeSupported)
                target.BirthStateAbbreviationType = source.BirthStateAbbreviationType;
            else
                targetSynchSupport.IsBirthStateAbbreviationTypeSupported = false;

            if (sourceSynchSupport.IsCitizenshipStatusTypeSupported)
                target.CitizenshipStatusType = source.CitizenshipStatusType;
            else
                targetSynchSupport.IsCitizenshipStatusTypeSupported = false;

            if (sourceSynchSupport.IsDateEnteredUSSupported)
                target.DateEnteredUS = source.DateEnteredUS;
            else
                targetSynchSupport.IsDateEnteredUSSupported = false;

            if (sourceSynchSupport.IsDisplacementStatusSupported)
                target.DisplacementStatus = source.DisplacementStatus;
            else
                targetSynchSupport.IsDisplacementStatusSupported = false;

            if (sourceSynchSupport.IsEconomicDisadvantagedSupported)
                target.EconomicDisadvantaged = source.EconomicDisadvantaged;
            else
                targetSynchSupport.IsEconomicDisadvantagedSupported = false;

            if (sourceSynchSupport.IsFirstNameSupported)
                target.FirstName = source.FirstName;
            else
                targetSynchSupport.IsFirstNameSupported = false;

            if (sourceSynchSupport.IsGenerationCodeSuffixSupported)
                target.GenerationCodeSuffix = source.GenerationCodeSuffix;
            else
                targetSynchSupport.IsGenerationCodeSuffixSupported = false;

            if (sourceSynchSupport.IsHispanicLatinoEthnicitySupported)
                target.HispanicLatinoEthnicity = source.HispanicLatinoEthnicity;
            else
                targetSynchSupport.IsHispanicLatinoEthnicitySupported = false;

            if (sourceSynchSupport.IsLastSurnameSupported)
                target.LastSurname = source.LastSurname;
            else
                targetSynchSupport.IsLastSurnameSupported = false;

            if (sourceSynchSupport.IsLimitedEnglishProficiencyDescriptorSupported)
                target.LimitedEnglishProficiencyDescriptor = source.LimitedEnglishProficiencyDescriptor;
            else
                targetSynchSupport.IsLimitedEnglishProficiencyDescriptorSupported = false;

            if (sourceSynchSupport.IsLoginIdSupported)
                target.LoginId = source.LoginId;
            else
                targetSynchSupport.IsLoginIdSupported = false;

            if (sourceSynchSupport.IsMaidenNameSupported)
                target.MaidenName = source.MaidenName;
            else
                targetSynchSupport.IsMaidenNameSupported = false;

            if (sourceSynchSupport.IsMiddleNameSupported)
                target.MiddleName = source.MiddleName;
            else
                targetSynchSupport.IsMiddleNameSupported = false;

            if (sourceSynchSupport.IsMultipleBirthStatusSupported)
                target.MultipleBirthStatus = source.MultipleBirthStatus;
            else
                targetSynchSupport.IsMultipleBirthStatusSupported = false;

            if (sourceSynchSupport.IsOldEthnicityTypeSupported)
                target.OldEthnicityType = source.OldEthnicityType;
            else
                targetSynchSupport.IsOldEthnicityTypeSupported = false;

            if (sourceSynchSupport.IsPersonalTitlePrefixSupported)
                target.PersonalTitlePrefix = source.PersonalTitlePrefix;
            else
                targetSynchSupport.IsPersonalTitlePrefixSupported = false;

            if (sourceSynchSupport.IsProfileThumbnailSupported)
                target.ProfileThumbnail = source.ProfileThumbnail;
            else
                targetSynchSupport.IsProfileThumbnailSupported = false;

            if (sourceSynchSupport.IsSchoolFoodServicesEligibilityDescriptorSupported)
                target.SchoolFoodServicesEligibilityDescriptor = source.SchoolFoodServicesEligibilityDescriptor;
            else
                targetSynchSupport.IsSchoolFoodServicesEligibilityDescriptorSupported = false;

            if (sourceSynchSupport.IsSexTypeSupported)
                target.SexType = source.SexType;
            else
                targetSynchSupport.IsSexTypeSupported = false;

            if (sourceSynchSupport.IsStudentUniqueIdSupported)
                target.StudentUniqueId = source.StudentUniqueId;
            else
                targetSynchSupport.IsStudentUniqueIdSupported = false;

            // ----------------------------------
            //   Map One-to-one relationships
            // ----------------------------------
            // StudentLearningStyle (Source)
            if (sourceSynchSupport.IsStudentLearningStyleSupported)
            {
                var itemProperty = target.GetType().GetProperty("StudentLearningStyle");
                
                if (itemProperty != null)
                {                    
                    if (source.StudentLearningStyle == null)
                    {
                        target.StudentLearningStyle = null;
                    }
                    else
                    {
                        var itemType = itemProperty.PropertyType;
                        object targetStudentLearningStyle = Activator.CreateInstance(itemType);

                        source.StudentLearningStyle.Map(targetStudentLearningStyle);
                        
                        // Update the target reference appropriately
                        target.StudentLearningStyle = (IStudentLearningStyle) targetStudentLearningStyle;
                    }
                }
            }
            else
            {
                targetSynchSupport.IsStudentLearningStyleSupported = false; 
            }
            // -------------------------------------------------------------

            // Map lists

            if (sourceSynchSupport.IsStudentAddressesSupported)
            {    
                targetSynchSupport.IsStudentAddressIncluded = sourceSynchSupport.IsStudentAddressIncluded;
                source.StudentAddresses.MapListTo(target.StudentAddresses);
            }
            else
            {
                targetSynchSupport.IsStudentAddressesSupported = false;
            }

            if (sourceSynchSupport.IsStudentCharacteristicsSupported)
            {    
                targetSynchSupport.IsStudentCharacteristicIncluded = sourceSynchSupport.IsStudentCharacteristicIncluded;
                source.StudentCharacteristics.MapListTo(target.StudentCharacteristics);
            }
            else
            {
                targetSynchSupport.IsStudentCharacteristicsSupported = false;
            }

            if (sourceSynchSupport.IsStudentCohortYearsSupported)
            {    
                targetSynchSupport.IsStudentCohortYearIncluded = sourceSynchSupport.IsStudentCohortYearIncluded;
                source.StudentCohortYears.MapListTo(target.StudentCohortYears);
            }
            else
            {
                targetSynchSupport.IsStudentCohortYearsSupported = false;
            }

            if (sourceSynchSupport.IsStudentDisabilitiesSupported)
            {    
                targetSynchSupport.IsStudentDisabilityIncluded = sourceSynchSupport.IsStudentDisabilityIncluded;
                source.StudentDisabilities.MapListTo(target.StudentDisabilities);
            }
            else
            {
                targetSynchSupport.IsStudentDisabilitiesSupported = false;
            }

            if (sourceSynchSupport.IsStudentElectronicMailsSupported)
            {    
                targetSynchSupport.IsStudentElectronicMailIncluded = sourceSynchSupport.IsStudentElectronicMailIncluded;
                source.StudentElectronicMails.MapListTo(target.StudentElectronicMails);
            }
            else
            {
                targetSynchSupport.IsStudentElectronicMailsSupported = false;
            }

            if (sourceSynchSupport.IsStudentIdentificationCodesSupported)
            {    
                targetSynchSupport.IsStudentIdentificationCodeIncluded = sourceSynchSupport.IsStudentIdentificationCodeIncluded;
                source.StudentIdentificationCodes.MapListTo(target.StudentIdentificationCodes);
            }
            else
            {
                targetSynchSupport.IsStudentIdentificationCodesSupported = false;
            }

            if (sourceSynchSupport.IsStudentIdentificationDocumentsSupported)
            {    
                targetSynchSupport.IsStudentIdentificationDocumentIncluded = sourceSynchSupport.IsStudentIdentificationDocumentIncluded;
                source.StudentIdentificationDocuments.MapListTo(target.StudentIdentificationDocuments);
            }
            else
            {
                targetSynchSupport.IsStudentIdentificationDocumentsSupported = false;
            }

            if (sourceSynchSupport.IsStudentIndicatorsSupported)
            {    
                targetSynchSupport.IsStudentIndicatorIncluded = sourceSynchSupport.IsStudentIndicatorIncluded;
                source.StudentIndicators.MapListTo(target.StudentIndicators);
            }
            else
            {
                targetSynchSupport.IsStudentIndicatorsSupported = false;
            }

            if (sourceSynchSupport.IsStudentInternationalAddressesSupported)
            {    
                targetSynchSupport.IsStudentInternationalAddressIncluded = sourceSynchSupport.IsStudentInternationalAddressIncluded;
                source.StudentInternationalAddresses.MapListTo(target.StudentInternationalAddresses);
            }
            else
            {
                targetSynchSupport.IsStudentInternationalAddressesSupported = false;
            }

            if (sourceSynchSupport.IsStudentLanguagesSupported)
            {    
                targetSynchSupport.IsStudentLanguageIncluded = sourceSynchSupport.IsStudentLanguageIncluded;
                source.StudentLanguages.MapListTo(target.StudentLanguages);
            }
            else
            {
                targetSynchSupport.IsStudentLanguagesSupported = false;
            }

            if (sourceSynchSupport.IsStudentOtherNamesSupported)
            {    
                targetSynchSupport.IsStudentOtherNameIncluded = sourceSynchSupport.IsStudentOtherNameIncluded;
                source.StudentOtherNames.MapListTo(target.StudentOtherNames);
            }
            else
            {
                targetSynchSupport.IsStudentOtherNamesSupported = false;
            }

            if (sourceSynchSupport.IsStudentProgramParticipationsSupported)
            {    
                targetSynchSupport.IsStudentProgramParticipationIncluded = sourceSynchSupport.IsStudentProgramParticipationIncluded;
                source.StudentProgramParticipations.MapListTo(target.StudentProgramParticipations);
            }
            else
            {
                targetSynchSupport.IsStudentProgramParticipationsSupported = false;
            }

            if (sourceSynchSupport.IsStudentRacesSupported)
            {    
                targetSynchSupport.IsStudentRaceIncluded = sourceSynchSupport.IsStudentRaceIncluded;
                source.StudentRaces.MapListTo(target.StudentRaces);
            }
            else
            {
                targetSynchSupport.IsStudentRacesSupported = false;
            }

            if (sourceSynchSupport.IsStudentTelephonesSupported)
            {    
                targetSynchSupport.IsStudentTelephoneIncluded = sourceSynchSupport.IsStudentTelephoneIncluded;
                source.StudentTelephones.MapListTo(target.StudentTelephones);
            }
            else
            {
                targetSynchSupport.IsStudentTelephonesSupported = false;
            }

            if (sourceSynchSupport.IsStudentVisasSupported)
            {    
                targetSynchSupport.IsStudentVisaIncluded = sourceSynchSupport.IsStudentVisaIncluded;
                source.StudentVisas.MapListTo(target.StudentVisas);
            }
            else
            {
                targetSynchSupport.IsStudentVisasSupported = false;
            }

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentSynchronizationSourceSupport
    {
        bool IsBirthCitySupported { get; set; }
        bool IsBirthCountryDescriptorSupported { get; set; }
        bool IsBirthDateSupported { get; set; }
        bool IsBirthInternationalProvinceSupported { get; set; }
        bool IsBirthStateAbbreviationTypeSupported { get; set; }
        bool IsCitizenshipStatusTypeSupported { get; set; }
        bool IsDateEnteredUSSupported { get; set; }
        bool IsDisplacementStatusSupported { get; set; }
        bool IsEconomicDisadvantagedSupported { get; set; }
        bool IsFirstNameSupported { get; set; }
        bool IsGenerationCodeSuffixSupported { get; set; }
        bool IsHispanicLatinoEthnicitySupported { get; set; }
        bool IsLastSurnameSupported { get; set; }
        bool IsLimitedEnglishProficiencyDescriptorSupported { get; set; }
        bool IsLoginIdSupported { get; set; }
        bool IsMaidenNameSupported { get; set; }
        bool IsMiddleNameSupported { get; set; }
        bool IsMultipleBirthStatusSupported { get; set; }
        bool IsOldEthnicityTypeSupported { get; set; }
        bool IsPersonalTitlePrefixSupported { get; set; }
        bool IsProfileThumbnailSupported { get; set; }
        bool IsSchoolFoodServicesEligibilityDescriptorSupported { get; set; }
        bool IsSexTypeSupported { get; set; }
        bool IsStudentAddressesSupported { get; set; }
        bool IsStudentCharacteristicsSupported { get; set; }
        bool IsStudentCohortYearsSupported { get; set; }
        bool IsStudentDisabilitiesSupported { get; set; }
        bool IsStudentElectronicMailsSupported { get; set; }
        bool IsStudentIdentificationCodesSupported { get; set; }
        bool IsStudentIdentificationDocumentsSupported { get; set; }
        bool IsStudentIndicatorsSupported { get; set; }
        bool IsStudentInternationalAddressesSupported { get; set; }
        bool IsStudentLanguagesSupported { get; set; }
        bool IsStudentLearningStyleSupported { get; set; }
        bool IsStudentOtherNamesSupported { get; set; }
        bool IsStudentProgramParticipationsSupported { get; set; }
        bool IsStudentRacesSupported { get; set; }
        bool IsStudentTelephonesSupported { get; set; }
        bool IsStudentUniqueIdSupported { get; set; }
        bool IsStudentVisasSupported { get; set; }
        Func<IStudentAddress, bool> IsStudentAddressIncluded { get; set; }
        Func<IStudentCharacteristic, bool> IsStudentCharacteristicIncluded { get; set; }
        Func<IStudentCohortYear, bool> IsStudentCohortYearIncluded { get; set; }
        Func<IStudentDisability, bool> IsStudentDisabilityIncluded { get; set; }
        Func<IStudentElectronicMail, bool> IsStudentElectronicMailIncluded { get; set; }
        Func<IStudentIdentificationCode, bool> IsStudentIdentificationCodeIncluded { get; set; }
        Func<IStudentIdentificationDocument, bool> IsStudentIdentificationDocumentIncluded { get; set; }
        Func<IStudentIndicator, bool> IsStudentIndicatorIncluded { get; set; }
        Func<IStudentInternationalAddress, bool> IsStudentInternationalAddressIncluded { get; set; }
        Func<IStudentLanguage, bool> IsStudentLanguageIncluded { get; set; }
        Func<IStudentOtherName, bool> IsStudentOtherNameIncluded { get; set; }
        Func<IStudentProgramParticipation, bool> IsStudentProgramParticipationIncluded { get; set; }
        Func<IStudentRace, bool> IsStudentRaceIncluded { get; set; }
        Func<IStudentTelephone, bool> IsStudentTelephoneIncluded { get; set; }
        Func<IStudentVisa, bool> IsStudentVisaIncluded { get; set; }
    }
 
    public static class StudentAddressMapper 
    {
        public static bool SynchronizeTo(this IStudentAddress source, IStudentAddress target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentAddressSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AddressType != target.AddressType)
            {
                source.AddressType = target.AddressType;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsApartmentRoomSuiteNumberSupported)
                && target.ApartmentRoomSuiteNumber != source.ApartmentRoomSuiteNumber)
            {
                target.ApartmentRoomSuiteNumber = source.ApartmentRoomSuiteNumber;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsBeginDateSupported)
                && target.BeginDate != source.BeginDate)
            {
                target.BeginDate = source.BeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsBuildingSiteNumberSupported)
                && target.BuildingSiteNumber != source.BuildingSiteNumber)
            {
                target.BuildingSiteNumber = source.BuildingSiteNumber;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsCitySupported)
                && target.City != source.City)
            {
                target.City = source.City;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsCountyFIPSCodeSupported)
                && target.CountyFIPSCode != source.CountyFIPSCode)
            {
                target.CountyFIPSCode = source.CountyFIPSCode;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEndDateSupported)
                && target.EndDate != source.EndDate)
            {
                target.EndDate = source.EndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsLatitudeSupported)
                && target.Latitude != source.Latitude)
            {
                target.Latitude = source.Latitude;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsLongitudeSupported)
                && target.Longitude != source.Longitude)
            {
                target.Longitude = source.Longitude;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNameOfCountySupported)
                && target.NameOfCounty != source.NameOfCounty)
            {
                target.NameOfCounty = source.NameOfCounty;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPostalCodeSupported)
                && target.PostalCode != source.PostalCode)
            {
                target.PostalCode = source.PostalCode;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsStateAbbreviationTypeSupported)
                && target.StateAbbreviationType != source.StateAbbreviationType)
            {
                target.StateAbbreviationType = source.StateAbbreviationType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsStreetNumberNameSupported)
                && target.StreetNumberName != source.StreetNumberName)
            {
                target.StreetNumberName = source.StreetNumberName;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStudentAddress source, IStudentAddress target, Action<IStudentAddress, IStudentAddress> onMapped)
        {
            var sourceSynchSupport = source as IStudentAddressSynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentAddressSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.AddressType = source.AddressType;

            // Copy non-PK properties

            if (sourceSynchSupport.IsApartmentRoomSuiteNumberSupported)
                target.ApartmentRoomSuiteNumber = source.ApartmentRoomSuiteNumber;
            else
                targetSynchSupport.IsApartmentRoomSuiteNumberSupported = false;

            if (sourceSynchSupport.IsBeginDateSupported)
                target.BeginDate = source.BeginDate;
            else
                targetSynchSupport.IsBeginDateSupported = false;

            if (sourceSynchSupport.IsBuildingSiteNumberSupported)
                target.BuildingSiteNumber = source.BuildingSiteNumber;
            else
                targetSynchSupport.IsBuildingSiteNumberSupported = false;

            if (sourceSynchSupport.IsCitySupported)
                target.City = source.City;
            else
                targetSynchSupport.IsCitySupported = false;

            if (sourceSynchSupport.IsCountyFIPSCodeSupported)
                target.CountyFIPSCode = source.CountyFIPSCode;
            else
                targetSynchSupport.IsCountyFIPSCodeSupported = false;

            if (sourceSynchSupport.IsEndDateSupported)
                target.EndDate = source.EndDate;
            else
                targetSynchSupport.IsEndDateSupported = false;

            if (sourceSynchSupport.IsLatitudeSupported)
                target.Latitude = source.Latitude;
            else
                targetSynchSupport.IsLatitudeSupported = false;

            if (sourceSynchSupport.IsLongitudeSupported)
                target.Longitude = source.Longitude;
            else
                targetSynchSupport.IsLongitudeSupported = false;

            if (sourceSynchSupport.IsNameOfCountySupported)
                target.NameOfCounty = source.NameOfCounty;
            else
                targetSynchSupport.IsNameOfCountySupported = false;

            if (sourceSynchSupport.IsPostalCodeSupported)
                target.PostalCode = source.PostalCode;
            else
                targetSynchSupport.IsPostalCodeSupported = false;

            if (sourceSynchSupport.IsStateAbbreviationTypeSupported)
                target.StateAbbreviationType = source.StateAbbreviationType;
            else
                targetSynchSupport.IsStateAbbreviationTypeSupported = false;

            if (sourceSynchSupport.IsStreetNumberNameSupported)
                target.StreetNumberName = source.StreetNumberName;
            else
                targetSynchSupport.IsStreetNumberNameSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentAddressSynchronizationSourceSupport
    {
        bool IsApartmentRoomSuiteNumberSupported { get; set; }
        bool IsBeginDateSupported { get; set; }
        bool IsBuildingSiteNumberSupported { get; set; }
        bool IsCitySupported { get; set; }
        bool IsCountyFIPSCodeSupported { get; set; }
        bool IsEndDateSupported { get; set; }
        bool IsLatitudeSupported { get; set; }
        bool IsLongitudeSupported { get; set; }
        bool IsNameOfCountySupported { get; set; }
        bool IsPostalCodeSupported { get; set; }
        bool IsStateAbbreviationTypeSupported { get; set; }
        bool IsStreetNumberNameSupported { get; set; }
    }
 
    public static class StudentCharacteristicMapper 
    {
        public static bool SynchronizeTo(this IStudentCharacteristic source, IStudentCharacteristic target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentCharacteristicSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.StudentCharacteristicDescriptor != target.StudentCharacteristicDescriptor)
            {
                source.StudentCharacteristicDescriptor = target.StudentCharacteristicDescriptor;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsBeginDateSupported)
                && target.BeginDate != source.BeginDate)
            {
                target.BeginDate = source.BeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDesignatedBySupported)
                && target.DesignatedBy != source.DesignatedBy)
            {
                target.DesignatedBy = source.DesignatedBy;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEndDateSupported)
                && target.EndDate != source.EndDate)
            {
                target.EndDate = source.EndDate;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStudentCharacteristic source, IStudentCharacteristic target, Action<IStudentCharacteristic, IStudentCharacteristic> onMapped)
        {
            var sourceSynchSupport = source as IStudentCharacteristicSynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentCharacteristicSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.StudentCharacteristicDescriptor = source.StudentCharacteristicDescriptor;

            // Copy non-PK properties

            if (sourceSynchSupport.IsBeginDateSupported)
                target.BeginDate = source.BeginDate;
            else
                targetSynchSupport.IsBeginDateSupported = false;

            if (sourceSynchSupport.IsDesignatedBySupported)
                target.DesignatedBy = source.DesignatedBy;
            else
                targetSynchSupport.IsDesignatedBySupported = false;

            if (sourceSynchSupport.IsEndDateSupported)
                target.EndDate = source.EndDate;
            else
                targetSynchSupport.IsEndDateSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentCharacteristicSynchronizationSourceSupport
    {
        bool IsBeginDateSupported { get; set; }
        bool IsDesignatedBySupported { get; set; }
        bool IsEndDateSupported { get; set; }
    }
 
    public static class StudentCohortYearMapper 
    {
        public static bool SynchronizeTo(this IStudentCohortYear source, IStudentCohortYear target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentCohortYearSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.CohortYearType != target.CohortYearType)
            {
                source.CohortYearType = target.CohortYearType;
            }
            if (source.SchoolYear != target.SchoolYear)
            {
                source.SchoolYear = target.SchoolYear;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStudentCohortYear source, IStudentCohortYear target, Action<IStudentCohortYear, IStudentCohortYear> onMapped)
        {
            var sourceSynchSupport = source as IStudentCohortYearSynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentCohortYearSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.CohortYearType = source.CohortYearType;
            target.SchoolYear = source.SchoolYear;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentCohortYearSynchronizationSourceSupport
    {
    }
 
    public static class StudentDisabilityMapper 
    {
        public static bool SynchronizeTo(this IStudentDisability source, IStudentDisability target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentDisabilitySynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.DisabilityDescriptor != target.DisabilityDescriptor)
            {
                source.DisabilityDescriptor = target.DisabilityDescriptor;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsDisabilityDeterminationSourceTypeSupported)
                && target.DisabilityDeterminationSourceType != source.DisabilityDeterminationSourceType)
            {
                target.DisabilityDeterminationSourceType = source.DisabilityDeterminationSourceType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDisabilityDiagnosisSupported)
                && target.DisabilityDiagnosis != source.DisabilityDiagnosis)
            {
                target.DisabilityDiagnosis = source.DisabilityDiagnosis;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsOrderOfDisabilitySupported)
                && target.OrderOfDisability != source.OrderOfDisability)
            {
                target.OrderOfDisability = source.OrderOfDisability;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStudentDisability source, IStudentDisability target, Action<IStudentDisability, IStudentDisability> onMapped)
        {
            var sourceSynchSupport = source as IStudentDisabilitySynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentDisabilitySynchronizationSourceSupport;

            // Copy contextual primary key values
            target.DisabilityDescriptor = source.DisabilityDescriptor;

            // Copy non-PK properties

            if (sourceSynchSupport.IsDisabilityDeterminationSourceTypeSupported)
                target.DisabilityDeterminationSourceType = source.DisabilityDeterminationSourceType;
            else
                targetSynchSupport.IsDisabilityDeterminationSourceTypeSupported = false;

            if (sourceSynchSupport.IsDisabilityDiagnosisSupported)
                target.DisabilityDiagnosis = source.DisabilityDiagnosis;
            else
                targetSynchSupport.IsDisabilityDiagnosisSupported = false;

            if (sourceSynchSupport.IsOrderOfDisabilitySupported)
                target.OrderOfDisability = source.OrderOfDisability;
            else
                targetSynchSupport.IsOrderOfDisabilitySupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentDisabilitySynchronizationSourceSupport
    {
        bool IsDisabilityDeterminationSourceTypeSupported { get; set; }
        bool IsDisabilityDiagnosisSupported { get; set; }
        bool IsOrderOfDisabilitySupported { get; set; }
    }
 
    public static class StudentElectronicMailMapper 
    {
        public static bool SynchronizeTo(this IStudentElectronicMail source, IStudentElectronicMail target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentElectronicMailSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.ElectronicMailType != target.ElectronicMailType)
            {
                source.ElectronicMailType = target.ElectronicMailType;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsElectronicMailAddressSupported)
                && target.ElectronicMailAddress != source.ElectronicMailAddress)
            {
                target.ElectronicMailAddress = source.ElectronicMailAddress;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPrimaryEmailAddressIndicatorSupported)
                && target.PrimaryEmailAddressIndicator != source.PrimaryEmailAddressIndicator)
            {
                target.PrimaryEmailAddressIndicator = source.PrimaryEmailAddressIndicator;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStudentElectronicMail source, IStudentElectronicMail target, Action<IStudentElectronicMail, IStudentElectronicMail> onMapped)
        {
            var sourceSynchSupport = source as IStudentElectronicMailSynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentElectronicMailSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.ElectronicMailType = source.ElectronicMailType;

            // Copy non-PK properties

            if (sourceSynchSupport.IsElectronicMailAddressSupported)
                target.ElectronicMailAddress = source.ElectronicMailAddress;
            else
                targetSynchSupport.IsElectronicMailAddressSupported = false;

            if (sourceSynchSupport.IsPrimaryEmailAddressIndicatorSupported)
                target.PrimaryEmailAddressIndicator = source.PrimaryEmailAddressIndicator;
            else
                targetSynchSupport.IsPrimaryEmailAddressIndicatorSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentElectronicMailSynchronizationSourceSupport
    {
        bool IsElectronicMailAddressSupported { get; set; }
        bool IsPrimaryEmailAddressIndicatorSupported { get; set; }
    }
 
    public static class StudentIdentificationCodeMapper 
    {
        public static bool SynchronizeTo(this IStudentIdentificationCode source, IStudentIdentificationCode target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentIdentificationCodeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AssigningOrganizationIdentificationCode != target.AssigningOrganizationIdentificationCode)
            {
                source.AssigningOrganizationIdentificationCode = target.AssigningOrganizationIdentificationCode;
            }
            if (source.StudentIdentificationSystemDescriptor != target.StudentIdentificationSystemDescriptor)
            {
                source.StudentIdentificationSystemDescriptor = target.StudentIdentificationSystemDescriptor;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsIdentificationCodeSupported)
                && target.IdentificationCode != source.IdentificationCode)
            {
                target.IdentificationCode = source.IdentificationCode;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStudentIdentificationCode source, IStudentIdentificationCode target, Action<IStudentIdentificationCode, IStudentIdentificationCode> onMapped)
        {
            var sourceSynchSupport = source as IStudentIdentificationCodeSynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentIdentificationCodeSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.AssigningOrganizationIdentificationCode = source.AssigningOrganizationIdentificationCode;
            target.StudentIdentificationSystemDescriptor = source.StudentIdentificationSystemDescriptor;

            // Copy non-PK properties

            if (sourceSynchSupport.IsIdentificationCodeSupported)
                target.IdentificationCode = source.IdentificationCode;
            else
                targetSynchSupport.IsIdentificationCodeSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentIdentificationCodeSynchronizationSourceSupport
    {
        bool IsIdentificationCodeSupported { get; set; }
    }
 
    public static class StudentIdentificationDocumentMapper 
    {
        public static bool SynchronizeTo(this IStudentIdentificationDocument source, IStudentIdentificationDocument target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentIdentificationDocumentSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.IdentificationDocumentUseType != target.IdentificationDocumentUseType)
            {
                source.IdentificationDocumentUseType = target.IdentificationDocumentUseType;
            }
            if (source.PersonalInformationVerificationType != target.PersonalInformationVerificationType)
            {
                source.PersonalInformationVerificationType = target.PersonalInformationVerificationType;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsDocumentExpirationDateSupported)
                && target.DocumentExpirationDate != source.DocumentExpirationDate)
            {
                target.DocumentExpirationDate = source.DocumentExpirationDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDocumentTitleSupported)
                && target.DocumentTitle != source.DocumentTitle)
            {
                target.DocumentTitle = source.DocumentTitle;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsIssuerCountryDescriptorSupported)
                && target.IssuerCountryDescriptor != source.IssuerCountryDescriptor)
            {
                target.IssuerCountryDescriptor = source.IssuerCountryDescriptor;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsIssuerDocumentIdentificationCodeSupported)
                && target.IssuerDocumentIdentificationCode != source.IssuerDocumentIdentificationCode)
            {
                target.IssuerDocumentIdentificationCode = source.IssuerDocumentIdentificationCode;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsIssuerNameSupported)
                && target.IssuerName != source.IssuerName)
            {
                target.IssuerName = source.IssuerName;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStudentIdentificationDocument source, IStudentIdentificationDocument target, Action<IStudentIdentificationDocument, IStudentIdentificationDocument> onMapped)
        {
            var sourceSynchSupport = source as IStudentIdentificationDocumentSynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentIdentificationDocumentSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.IdentificationDocumentUseType = source.IdentificationDocumentUseType;
            target.PersonalInformationVerificationType = source.PersonalInformationVerificationType;

            // Copy non-PK properties

            if (sourceSynchSupport.IsDocumentExpirationDateSupported)
                target.DocumentExpirationDate = source.DocumentExpirationDate;
            else
                targetSynchSupport.IsDocumentExpirationDateSupported = false;

            if (sourceSynchSupport.IsDocumentTitleSupported)
                target.DocumentTitle = source.DocumentTitle;
            else
                targetSynchSupport.IsDocumentTitleSupported = false;

            if (sourceSynchSupport.IsIssuerCountryDescriptorSupported)
                target.IssuerCountryDescriptor = source.IssuerCountryDescriptor;
            else
                targetSynchSupport.IsIssuerCountryDescriptorSupported = false;

            if (sourceSynchSupport.IsIssuerDocumentIdentificationCodeSupported)
                target.IssuerDocumentIdentificationCode = source.IssuerDocumentIdentificationCode;
            else
                targetSynchSupport.IsIssuerDocumentIdentificationCodeSupported = false;

            if (sourceSynchSupport.IsIssuerNameSupported)
                target.IssuerName = source.IssuerName;
            else
                targetSynchSupport.IsIssuerNameSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentIdentificationDocumentSynchronizationSourceSupport
    {
        bool IsDocumentExpirationDateSupported { get; set; }
        bool IsDocumentTitleSupported { get; set; }
        bool IsIssuerCountryDescriptorSupported { get; set; }
        bool IsIssuerDocumentIdentificationCodeSupported { get; set; }
        bool IsIssuerNameSupported { get; set; }
    }
 
    public static class StudentIndicatorMapper 
    {
        public static bool SynchronizeTo(this IStudentIndicator source, IStudentIndicator target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentIndicatorSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.IndicatorName != target.IndicatorName)
            {
                source.IndicatorName = target.IndicatorName;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsBeginDateSupported)
                && target.BeginDate != source.BeginDate)
            {
                target.BeginDate = source.BeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDesignatedBySupported)
                && target.DesignatedBy != source.DesignatedBy)
            {
                target.DesignatedBy = source.DesignatedBy;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEndDateSupported)
                && target.EndDate != source.EndDate)
            {
                target.EndDate = source.EndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsIndicatorSupported)
                && target.Indicator != source.Indicator)
            {
                target.Indicator = source.Indicator;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsIndicatorGroupSupported)
                && target.IndicatorGroup != source.IndicatorGroup)
            {
                target.IndicatorGroup = source.IndicatorGroup;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStudentIndicator source, IStudentIndicator target, Action<IStudentIndicator, IStudentIndicator> onMapped)
        {
            var sourceSynchSupport = source as IStudentIndicatorSynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentIndicatorSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.IndicatorName = source.IndicatorName;

            // Copy non-PK properties

            if (sourceSynchSupport.IsBeginDateSupported)
                target.BeginDate = source.BeginDate;
            else
                targetSynchSupport.IsBeginDateSupported = false;

            if (sourceSynchSupport.IsDesignatedBySupported)
                target.DesignatedBy = source.DesignatedBy;
            else
                targetSynchSupport.IsDesignatedBySupported = false;

            if (sourceSynchSupport.IsEndDateSupported)
                target.EndDate = source.EndDate;
            else
                targetSynchSupport.IsEndDateSupported = false;

            if (sourceSynchSupport.IsIndicatorSupported)
                target.Indicator = source.Indicator;
            else
                targetSynchSupport.IsIndicatorSupported = false;

            if (sourceSynchSupport.IsIndicatorGroupSupported)
                target.IndicatorGroup = source.IndicatorGroup;
            else
                targetSynchSupport.IsIndicatorGroupSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentIndicatorSynchronizationSourceSupport
    {
        bool IsBeginDateSupported { get; set; }
        bool IsDesignatedBySupported { get; set; }
        bool IsEndDateSupported { get; set; }
        bool IsIndicatorSupported { get; set; }
        bool IsIndicatorGroupSupported { get; set; }
    }
 
    public static class StudentInternationalAddressMapper 
    {
        public static bool SynchronizeTo(this IStudentInternationalAddress source, IStudentInternationalAddress target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentInternationalAddressSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AddressType != target.AddressType)
            {
                source.AddressType = target.AddressType;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsAddressLine1Supported)
                && target.AddressLine1 != source.AddressLine1)
            {
                target.AddressLine1 = source.AddressLine1;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsAddressLine2Supported)
                && target.AddressLine2 != source.AddressLine2)
            {
                target.AddressLine2 = source.AddressLine2;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsAddressLine3Supported)
                && target.AddressLine3 != source.AddressLine3)
            {
                target.AddressLine3 = source.AddressLine3;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsAddressLine4Supported)
                && target.AddressLine4 != source.AddressLine4)
            {
                target.AddressLine4 = source.AddressLine4;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsBeginDateSupported)
                && target.BeginDate != source.BeginDate)
            {
                target.BeginDate = source.BeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsCountryDescriptorSupported)
                && target.CountryDescriptor != source.CountryDescriptor)
            {
                target.CountryDescriptor = source.CountryDescriptor;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEndDateSupported)
                && target.EndDate != source.EndDate)
            {
                target.EndDate = source.EndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsLatitudeSupported)
                && target.Latitude != source.Latitude)
            {
                target.Latitude = source.Latitude;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsLongitudeSupported)
                && target.Longitude != source.Longitude)
            {
                target.Longitude = source.Longitude;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStudentInternationalAddress source, IStudentInternationalAddress target, Action<IStudentInternationalAddress, IStudentInternationalAddress> onMapped)
        {
            var sourceSynchSupport = source as IStudentInternationalAddressSynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentInternationalAddressSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.AddressType = source.AddressType;

            // Copy non-PK properties

            if (sourceSynchSupport.IsAddressLine1Supported)
                target.AddressLine1 = source.AddressLine1;
            else
                targetSynchSupport.IsAddressLine1Supported = false;

            if (sourceSynchSupport.IsAddressLine2Supported)
                target.AddressLine2 = source.AddressLine2;
            else
                targetSynchSupport.IsAddressLine2Supported = false;

            if (sourceSynchSupport.IsAddressLine3Supported)
                target.AddressLine3 = source.AddressLine3;
            else
                targetSynchSupport.IsAddressLine3Supported = false;

            if (sourceSynchSupport.IsAddressLine4Supported)
                target.AddressLine4 = source.AddressLine4;
            else
                targetSynchSupport.IsAddressLine4Supported = false;

            if (sourceSynchSupport.IsBeginDateSupported)
                target.BeginDate = source.BeginDate;
            else
                targetSynchSupport.IsBeginDateSupported = false;

            if (sourceSynchSupport.IsCountryDescriptorSupported)
                target.CountryDescriptor = source.CountryDescriptor;
            else
                targetSynchSupport.IsCountryDescriptorSupported = false;

            if (sourceSynchSupport.IsEndDateSupported)
                target.EndDate = source.EndDate;
            else
                targetSynchSupport.IsEndDateSupported = false;

            if (sourceSynchSupport.IsLatitudeSupported)
                target.Latitude = source.Latitude;
            else
                targetSynchSupport.IsLatitudeSupported = false;

            if (sourceSynchSupport.IsLongitudeSupported)
                target.Longitude = source.Longitude;
            else
                targetSynchSupport.IsLongitudeSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentInternationalAddressSynchronizationSourceSupport
    {
        bool IsAddressLine1Supported { get; set; }
        bool IsAddressLine2Supported { get; set; }
        bool IsAddressLine3Supported { get; set; }
        bool IsAddressLine4Supported { get; set; }
        bool IsBeginDateSupported { get; set; }
        bool IsCountryDescriptorSupported { get; set; }
        bool IsEndDateSupported { get; set; }
        bool IsLatitudeSupported { get; set; }
        bool IsLongitudeSupported { get; set; }
    }
 
    public static class StudentLanguageMapper 
    {
        public static bool SynchronizeTo(this IStudentLanguage source, IStudentLanguage target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentLanguageSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.LanguageDescriptor != target.LanguageDescriptor)
            {
                source.LanguageDescriptor = target.LanguageDescriptor;
            }

            // Copy non-PK properties



            // Sync lists
            if (sourceSupport == null || sourceSupport.IsStudentLanguageUsesSupported)
                isModified |= source.StudentLanguageUses.SynchronizeListTo(target.StudentLanguageUses, child => child.StudentLanguage = target,
                                sourceSupport == null ? null : sourceSupport.IsStudentLanguageUseIncluded);


            return isModified;
        }



        public static void MapTo(this IStudentLanguage source, IStudentLanguage target, Action<IStudentLanguage, IStudentLanguage> onMapped)
        {
            var sourceSynchSupport = source as IStudentLanguageSynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentLanguageSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.LanguageDescriptor = source.LanguageDescriptor;

            // Copy non-PK properties

            // Map lists

            if (sourceSynchSupport.IsStudentLanguageUsesSupported)
            {    
                targetSynchSupport.IsStudentLanguageUseIncluded = sourceSynchSupport.IsStudentLanguageUseIncluded;
                source.StudentLanguageUses.MapListTo(target.StudentLanguageUses);
            }
            else
            {
                targetSynchSupport.IsStudentLanguageUsesSupported = false;
            }

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentLanguageSynchronizationSourceSupport
    {
        bool IsStudentLanguageUsesSupported { get; set; }
        Func<IStudentLanguageUse, bool> IsStudentLanguageUseIncluded { get; set; }
    }
 
    public static class StudentLanguageUseMapper 
    {
        public static bool SynchronizeTo(this IStudentLanguageUse source, IStudentLanguageUse target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentLanguageUseSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.LanguageUseType != target.LanguageUseType)
            {
                source.LanguageUseType = target.LanguageUseType;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStudentLanguageUse source, IStudentLanguageUse target, Action<IStudentLanguageUse, IStudentLanguageUse> onMapped)
        {
            var sourceSynchSupport = source as IStudentLanguageUseSynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentLanguageUseSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.LanguageUseType = source.LanguageUseType;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentLanguageUseSynchronizationSourceSupport
    {
    }
 
    public static class StudentLearningStyleMapper 
    {
        public static bool SynchronizeTo(this IStudentLearningStyle source, IStudentLearningStyle target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentLearningStyleSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsAuditoryLearningSupported)
                && target.AuditoryLearning != source.AuditoryLearning)
            {
                target.AuditoryLearning = source.AuditoryLearning;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsTactileLearningSupported)
                && target.TactileLearning != source.TactileLearning)
            {
                target.TactileLearning = source.TactileLearning;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsVisualLearningSupported)
                && target.VisualLearning != source.VisualLearning)
            {
                target.VisualLearning = source.VisualLearning;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStudentLearningStyle source, IStudentLearningStyle target, Action<IStudentLearningStyle, IStudentLearningStyle> onMapped)
        {
            var sourceSynchSupport = source as IStudentLearningStyleSynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentLearningStyleSynchronizationSourceSupport;

            // Copy contextual primary key values

            // Copy non-PK properties

            if (sourceSynchSupport.IsAuditoryLearningSupported)
                target.AuditoryLearning = source.AuditoryLearning;
            else
                targetSynchSupport.IsAuditoryLearningSupported = false;

            if (sourceSynchSupport.IsTactileLearningSupported)
                target.TactileLearning = source.TactileLearning;
            else
                targetSynchSupport.IsTactileLearningSupported = false;

            if (sourceSynchSupport.IsVisualLearningSupported)
                target.VisualLearning = source.VisualLearning;
            else
                targetSynchSupport.IsVisualLearningSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentLearningStyleSynchronizationSourceSupport
    {
        bool IsAuditoryLearningSupported { get; set; }
        bool IsTactileLearningSupported { get; set; }
        bool IsVisualLearningSupported { get; set; }
    }
 
    public static class StudentOtherNameMapper 
    {
        public static bool SynchronizeTo(this IStudentOtherName source, IStudentOtherName target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentOtherNameSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.OtherNameType != target.OtherNameType)
            {
                source.OtherNameType = target.OtherNameType;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsFirstNameSupported)
                && target.FirstName != source.FirstName)
            {
                target.FirstName = source.FirstName;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsGenerationCodeSuffixSupported)
                && target.GenerationCodeSuffix != source.GenerationCodeSuffix)
            {
                target.GenerationCodeSuffix = source.GenerationCodeSuffix;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsLastSurnameSupported)
                && target.LastSurname != source.LastSurname)
            {
                target.LastSurname = source.LastSurname;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsMiddleNameSupported)
                && target.MiddleName != source.MiddleName)
            {
                target.MiddleName = source.MiddleName;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPersonalTitlePrefixSupported)
                && target.PersonalTitlePrefix != source.PersonalTitlePrefix)
            {
                target.PersonalTitlePrefix = source.PersonalTitlePrefix;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStudentOtherName source, IStudentOtherName target, Action<IStudentOtherName, IStudentOtherName> onMapped)
        {
            var sourceSynchSupport = source as IStudentOtherNameSynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentOtherNameSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.OtherNameType = source.OtherNameType;

            // Copy non-PK properties

            if (sourceSynchSupport.IsFirstNameSupported)
                target.FirstName = source.FirstName;
            else
                targetSynchSupport.IsFirstNameSupported = false;

            if (sourceSynchSupport.IsGenerationCodeSuffixSupported)
                target.GenerationCodeSuffix = source.GenerationCodeSuffix;
            else
                targetSynchSupport.IsGenerationCodeSuffixSupported = false;

            if (sourceSynchSupport.IsLastSurnameSupported)
                target.LastSurname = source.LastSurname;
            else
                targetSynchSupport.IsLastSurnameSupported = false;

            if (sourceSynchSupport.IsMiddleNameSupported)
                target.MiddleName = source.MiddleName;
            else
                targetSynchSupport.IsMiddleNameSupported = false;

            if (sourceSynchSupport.IsPersonalTitlePrefixSupported)
                target.PersonalTitlePrefix = source.PersonalTitlePrefix;
            else
                targetSynchSupport.IsPersonalTitlePrefixSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentOtherNameSynchronizationSourceSupport
    {
        bool IsFirstNameSupported { get; set; }
        bool IsGenerationCodeSuffixSupported { get; set; }
        bool IsLastSurnameSupported { get; set; }
        bool IsMiddleNameSupported { get; set; }
        bool IsPersonalTitlePrefixSupported { get; set; }
    }
 
    public static class StudentProgramParticipationMapper 
    {
        public static bool SynchronizeTo(this IStudentProgramParticipation source, IStudentProgramParticipation target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentProgramParticipationSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.ProgramType != target.ProgramType)
            {
                source.ProgramType = target.ProgramType;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsBeginDateSupported)
                && target.BeginDate != source.BeginDate)
            {
                target.BeginDate = source.BeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDesignatedBySupported)
                && target.DesignatedBy != source.DesignatedBy)
            {
                target.DesignatedBy = source.DesignatedBy;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEndDateSupported)
                && target.EndDate != source.EndDate)
            {
                target.EndDate = source.EndDate;
                isModified = true;
            }



            // Sync lists
            if (sourceSupport == null || sourceSupport.IsStudentProgramParticipationProgramCharacteristicsSupported)
                isModified |= source.StudentProgramParticipationProgramCharacteristics.SynchronizeListTo(target.StudentProgramParticipationProgramCharacteristics, child => child.StudentProgramParticipation = target,
                                sourceSupport == null ? null : sourceSupport.IsStudentProgramParticipationProgramCharacteristicIncluded);


            return isModified;
        }



        public static void MapTo(this IStudentProgramParticipation source, IStudentProgramParticipation target, Action<IStudentProgramParticipation, IStudentProgramParticipation> onMapped)
        {
            var sourceSynchSupport = source as IStudentProgramParticipationSynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentProgramParticipationSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.ProgramType = source.ProgramType;

            // Copy non-PK properties

            if (sourceSynchSupport.IsBeginDateSupported)
                target.BeginDate = source.BeginDate;
            else
                targetSynchSupport.IsBeginDateSupported = false;

            if (sourceSynchSupport.IsDesignatedBySupported)
                target.DesignatedBy = source.DesignatedBy;
            else
                targetSynchSupport.IsDesignatedBySupported = false;

            if (sourceSynchSupport.IsEndDateSupported)
                target.EndDate = source.EndDate;
            else
                targetSynchSupport.IsEndDateSupported = false;

            // Map lists

            if (sourceSynchSupport.IsStudentProgramParticipationProgramCharacteristicsSupported)
            {    
                targetSynchSupport.IsStudentProgramParticipationProgramCharacteristicIncluded = sourceSynchSupport.IsStudentProgramParticipationProgramCharacteristicIncluded;
                source.StudentProgramParticipationProgramCharacteristics.MapListTo(target.StudentProgramParticipationProgramCharacteristics);
            }
            else
            {
                targetSynchSupport.IsStudentProgramParticipationProgramCharacteristicsSupported = false;
            }

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentProgramParticipationSynchronizationSourceSupport
    {
        bool IsBeginDateSupported { get; set; }
        bool IsDesignatedBySupported { get; set; }
        bool IsEndDateSupported { get; set; }
        bool IsStudentProgramParticipationProgramCharacteristicsSupported { get; set; }
        Func<IStudentProgramParticipationProgramCharacteristic, bool> IsStudentProgramParticipationProgramCharacteristicIncluded { get; set; }
    }
 
    public static class StudentProgramParticipationProgramCharacteristicMapper 
    {
        public static bool SynchronizeTo(this IStudentProgramParticipationProgramCharacteristic source, IStudentProgramParticipationProgramCharacteristic target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentProgramParticipationProgramCharacteristicSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.ProgramCharacteristicDescriptor != target.ProgramCharacteristicDescriptor)
            {
                source.ProgramCharacteristicDescriptor = target.ProgramCharacteristicDescriptor;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStudentProgramParticipationProgramCharacteristic source, IStudentProgramParticipationProgramCharacteristic target, Action<IStudentProgramParticipationProgramCharacteristic, IStudentProgramParticipationProgramCharacteristic> onMapped)
        {
            var sourceSynchSupport = source as IStudentProgramParticipationProgramCharacteristicSynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentProgramParticipationProgramCharacteristicSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.ProgramCharacteristicDescriptor = source.ProgramCharacteristicDescriptor;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentProgramParticipationProgramCharacteristicSynchronizationSourceSupport
    {
    }
 
    public static class StudentRaceMapper 
    {
        public static bool SynchronizeTo(this IStudentRace source, IStudentRace target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentRaceSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.RaceType != target.RaceType)
            {
                source.RaceType = target.RaceType;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStudentRace source, IStudentRace target, Action<IStudentRace, IStudentRace> onMapped)
        {
            var sourceSynchSupport = source as IStudentRaceSynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentRaceSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.RaceType = source.RaceType;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentRaceSynchronizationSourceSupport
    {
    }
 
    public static class StudentTelephoneMapper 
    {
        public static bool SynchronizeTo(this IStudentTelephone source, IStudentTelephone target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentTelephoneSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.TelephoneNumberType != target.TelephoneNumberType)
            {
                source.TelephoneNumberType = target.TelephoneNumberType;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsOrderOfPrioritySupported)
                && target.OrderOfPriority != source.OrderOfPriority)
            {
                target.OrderOfPriority = source.OrderOfPriority;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsTelephoneNumberSupported)
                && target.TelephoneNumber != source.TelephoneNumber)
            {
                target.TelephoneNumber = source.TelephoneNumber;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsTextMessageCapabilityIndicatorSupported)
                && target.TextMessageCapabilityIndicator != source.TextMessageCapabilityIndicator)
            {
                target.TextMessageCapabilityIndicator = source.TextMessageCapabilityIndicator;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStudentTelephone source, IStudentTelephone target, Action<IStudentTelephone, IStudentTelephone> onMapped)
        {
            var sourceSynchSupport = source as IStudentTelephoneSynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentTelephoneSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.TelephoneNumberType = source.TelephoneNumberType;

            // Copy non-PK properties

            if (sourceSynchSupport.IsOrderOfPrioritySupported)
                target.OrderOfPriority = source.OrderOfPriority;
            else
                targetSynchSupport.IsOrderOfPrioritySupported = false;

            if (sourceSynchSupport.IsTelephoneNumberSupported)
                target.TelephoneNumber = source.TelephoneNumber;
            else
                targetSynchSupport.IsTelephoneNumberSupported = false;

            if (sourceSynchSupport.IsTextMessageCapabilityIndicatorSupported)
                target.TextMessageCapabilityIndicator = source.TextMessageCapabilityIndicator;
            else
                targetSynchSupport.IsTextMessageCapabilityIndicatorSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentTelephoneSynchronizationSourceSupport
    {
        bool IsOrderOfPrioritySupported { get; set; }
        bool IsTelephoneNumberSupported { get; set; }
        bool IsTextMessageCapabilityIndicatorSupported { get; set; }
    }
 
    public static class StudentVisaMapper 
    {
        public static bool SynchronizeTo(this IStudentVisa source, IStudentVisa target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentVisaSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.VisaType != target.VisaType)
            {
                source.VisaType = target.VisaType;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStudentVisa source, IStudentVisa target, Action<IStudentVisa, IStudentVisa> onMapped)
        {
            var sourceSynchSupport = source as IStudentVisaSynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentVisaSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.VisaType = source.VisaType;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentVisaSynchronizationSourceSupport
    {
    }
 
}
// Aggregate: StudentAcademicRecord

namespace EdFi.Ods.Entities.Common //.StudentAcademicRecordAggregate
{ 
    public static class StudentAcademicRecordMapper 
    {
        public static bool SynchronizeTo(this IStudentAcademicRecord source, IStudentAcademicRecord target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentAcademicRecordSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.EducationOrganizationId != target.EducationOrganizationId)
            {
                source.EducationOrganizationId = target.EducationOrganizationId;
            }
            if (source.SchoolYear != target.SchoolYear)
            {
                source.SchoolYear = target.SchoolYear;
            }
            if (source.StudentUniqueId != target.StudentUniqueId)
            {
                source.StudentUniqueId = target.StudentUniqueId;
            }
            if (source.TermDescriptor != target.TermDescriptor)
            {
                source.TermDescriptor = target.TermDescriptor;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCumulativeAttemptedCreditConversionSupported)
                && target.CumulativeAttemptedCreditConversion != source.CumulativeAttemptedCreditConversion)
            {
                target.CumulativeAttemptedCreditConversion = source.CumulativeAttemptedCreditConversion;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsCumulativeAttemptedCreditsSupported)
                && target.CumulativeAttemptedCredits != source.CumulativeAttemptedCredits)
            {
                target.CumulativeAttemptedCredits = source.CumulativeAttemptedCredits;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsCumulativeAttemptedCreditTypeSupported)
                && target.CumulativeAttemptedCreditType != source.CumulativeAttemptedCreditType)
            {
                target.CumulativeAttemptedCreditType = source.CumulativeAttemptedCreditType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsCumulativeEarnedCreditConversionSupported)
                && target.CumulativeEarnedCreditConversion != source.CumulativeEarnedCreditConversion)
            {
                target.CumulativeEarnedCreditConversion = source.CumulativeEarnedCreditConversion;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsCumulativeEarnedCreditsSupported)
                && target.CumulativeEarnedCredits != source.CumulativeEarnedCredits)
            {
                target.CumulativeEarnedCredits = source.CumulativeEarnedCredits;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsCumulativeEarnedCreditTypeSupported)
                && target.CumulativeEarnedCreditType != source.CumulativeEarnedCreditType)
            {
                target.CumulativeEarnedCreditType = source.CumulativeEarnedCreditType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsCumulativeGradePointAverageSupported)
                && target.CumulativeGradePointAverage != source.CumulativeGradePointAverage)
            {
                target.CumulativeGradePointAverage = source.CumulativeGradePointAverage;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsCumulativeGradePointsEarnedSupported)
                && target.CumulativeGradePointsEarned != source.CumulativeGradePointsEarned)
            {
                target.CumulativeGradePointsEarned = source.CumulativeGradePointsEarned;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsGradeValueQualifierSupported)
                && target.GradeValueQualifier != source.GradeValueQualifier)
            {
                target.GradeValueQualifier = source.GradeValueQualifier;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsProjectedGraduationDateSupported)
                && target.ProjectedGraduationDate != source.ProjectedGraduationDate)
            {
                target.ProjectedGraduationDate = source.ProjectedGraduationDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsSessionAttemptedCreditConversionSupported)
                && target.SessionAttemptedCreditConversion != source.SessionAttemptedCreditConversion)
            {
                target.SessionAttemptedCreditConversion = source.SessionAttemptedCreditConversion;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsSessionAttemptedCreditsSupported)
                && target.SessionAttemptedCredits != source.SessionAttemptedCredits)
            {
                target.SessionAttemptedCredits = source.SessionAttemptedCredits;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsSessionAttemptedCreditTypeSupported)
                && target.SessionAttemptedCreditType != source.SessionAttemptedCreditType)
            {
                target.SessionAttemptedCreditType = source.SessionAttemptedCreditType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsSessionEarnedCreditConversionSupported)
                && target.SessionEarnedCreditConversion != source.SessionEarnedCreditConversion)
            {
                target.SessionEarnedCreditConversion = source.SessionEarnedCreditConversion;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsSessionEarnedCreditsSupported)
                && target.SessionEarnedCredits != source.SessionEarnedCredits)
            {
                target.SessionEarnedCredits = source.SessionEarnedCredits;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsSessionEarnedCreditTypeSupported)
                && target.SessionEarnedCreditType != source.SessionEarnedCreditType)
            {
                target.SessionEarnedCreditType = source.SessionEarnedCreditType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsSessionGradePointAverageSupported)
                && target.SessionGradePointAverage != source.SessionGradePointAverage)
            {
                target.SessionGradePointAverage = source.SessionGradePointAverage;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsSessionGradePointsEarnedSupported)
                && target.SessionGradePointsEarned != source.SessionGradePointsEarned)
            {
                target.SessionGradePointsEarned = source.SessionGradePointsEarned;
                isModified = true;
            }

            // ----------------------------------            
            //   Synch One-to-one relationships
            // ----------------------------------            
            // StudentAcademicRecordClassRanking
            if (sourceSupport == null || sourceSupport.IsStudentAcademicRecordClassRankingSupported)
            {
                if (source.StudentAcademicRecordClassRanking == null)
                {
                    if (target.StudentAcademicRecordClassRanking != null)
                    {
                        target.StudentAcademicRecordClassRanking = null;
                        isModified = true;
                    }
                }
                else
                {
                    if (target.StudentAcademicRecordClassRanking == null)
                    {
                        var itemType = target.GetType().GetProperty("StudentAcademicRecordClassRanking").PropertyType;
                        var newItem = Activator.CreateInstance(itemType);
                        target.StudentAcademicRecordClassRanking = (IStudentAcademicRecordClassRanking) newItem;
                    }

                    isModified |= source.StudentAcademicRecordClassRanking.Synchronize(target.StudentAcademicRecordClassRanking);
                }
            }
            
            // -------------------------------------------------------------



            // Sync lists
            if (sourceSupport == null || sourceSupport.IsStudentAcademicRecordAcademicHonorsSupported)
                isModified |= source.StudentAcademicRecordAcademicHonors.SynchronizeListTo(target.StudentAcademicRecordAcademicHonors, child => child.StudentAcademicRecord = target,
                                sourceSupport == null ? null : sourceSupport.IsStudentAcademicRecordAcademicHonorIncluded);

            if (sourceSupport == null || sourceSupport.IsStudentAcademicRecordDiplomasSupported)
                isModified |= source.StudentAcademicRecordDiplomas.SynchronizeListTo(target.StudentAcademicRecordDiplomas, child => child.StudentAcademicRecord = target,
                                sourceSupport == null ? null : sourceSupport.IsStudentAcademicRecordDiplomaIncluded);

            if (sourceSupport == null || sourceSupport.IsStudentAcademicRecordRecognitionsSupported)
                isModified |= source.StudentAcademicRecordRecognitions.SynchronizeListTo(target.StudentAcademicRecordRecognitions, child => child.StudentAcademicRecord = target,
                                sourceSupport == null ? null : sourceSupport.IsStudentAcademicRecordRecognitionIncluded);

            if (sourceSupport == null || sourceSupport.IsStudentAcademicRecordReportCardsSupported)
                isModified |= source.StudentAcademicRecordReportCards.SynchronizeListTo(target.StudentAcademicRecordReportCards, child => child.StudentAcademicRecord = target,
                                sourceSupport == null ? null : sourceSupport.IsStudentAcademicRecordReportCardIncluded);


            return isModified;
        }



        public static void MapTo(this IStudentAcademicRecord source, IStudentAcademicRecord target, Action<IStudentAcademicRecord, IStudentAcademicRecord> onMapped)
        {
            var sourceSynchSupport = source as IStudentAcademicRecordSynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentAcademicRecordSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.EducationOrganizationId = source.EducationOrganizationId;
            target.SchoolYear = source.SchoolYear;
            target.StudentUniqueId = source.StudentUniqueId;
            target.TermDescriptor = source.TermDescriptor;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCumulativeAttemptedCreditConversionSupported)
                target.CumulativeAttemptedCreditConversion = source.CumulativeAttemptedCreditConversion;
            else
                targetSynchSupport.IsCumulativeAttemptedCreditConversionSupported = false;

            if (sourceSynchSupport.IsCumulativeAttemptedCreditsSupported)
                target.CumulativeAttemptedCredits = source.CumulativeAttemptedCredits;
            else
                targetSynchSupport.IsCumulativeAttemptedCreditsSupported = false;

            if (sourceSynchSupport.IsCumulativeAttemptedCreditTypeSupported)
                target.CumulativeAttemptedCreditType = source.CumulativeAttemptedCreditType;
            else
                targetSynchSupport.IsCumulativeAttemptedCreditTypeSupported = false;

            if (sourceSynchSupport.IsCumulativeEarnedCreditConversionSupported)
                target.CumulativeEarnedCreditConversion = source.CumulativeEarnedCreditConversion;
            else
                targetSynchSupport.IsCumulativeEarnedCreditConversionSupported = false;

            if (sourceSynchSupport.IsCumulativeEarnedCreditsSupported)
                target.CumulativeEarnedCredits = source.CumulativeEarnedCredits;
            else
                targetSynchSupport.IsCumulativeEarnedCreditsSupported = false;

            if (sourceSynchSupport.IsCumulativeEarnedCreditTypeSupported)
                target.CumulativeEarnedCreditType = source.CumulativeEarnedCreditType;
            else
                targetSynchSupport.IsCumulativeEarnedCreditTypeSupported = false;

            if (sourceSynchSupport.IsCumulativeGradePointAverageSupported)
                target.CumulativeGradePointAverage = source.CumulativeGradePointAverage;
            else
                targetSynchSupport.IsCumulativeGradePointAverageSupported = false;

            if (sourceSynchSupport.IsCumulativeGradePointsEarnedSupported)
                target.CumulativeGradePointsEarned = source.CumulativeGradePointsEarned;
            else
                targetSynchSupport.IsCumulativeGradePointsEarnedSupported = false;

            if (sourceSynchSupport.IsGradeValueQualifierSupported)
                target.GradeValueQualifier = source.GradeValueQualifier;
            else
                targetSynchSupport.IsGradeValueQualifierSupported = false;

            if (sourceSynchSupport.IsProjectedGraduationDateSupported)
                target.ProjectedGraduationDate = source.ProjectedGraduationDate;
            else
                targetSynchSupport.IsProjectedGraduationDateSupported = false;

            if (sourceSynchSupport.IsSessionAttemptedCreditConversionSupported)
                target.SessionAttemptedCreditConversion = source.SessionAttemptedCreditConversion;
            else
                targetSynchSupport.IsSessionAttemptedCreditConversionSupported = false;

            if (sourceSynchSupport.IsSessionAttemptedCreditsSupported)
                target.SessionAttemptedCredits = source.SessionAttemptedCredits;
            else
                targetSynchSupport.IsSessionAttemptedCreditsSupported = false;

            if (sourceSynchSupport.IsSessionAttemptedCreditTypeSupported)
                target.SessionAttemptedCreditType = source.SessionAttemptedCreditType;
            else
                targetSynchSupport.IsSessionAttemptedCreditTypeSupported = false;

            if (sourceSynchSupport.IsSessionEarnedCreditConversionSupported)
                target.SessionEarnedCreditConversion = source.SessionEarnedCreditConversion;
            else
                targetSynchSupport.IsSessionEarnedCreditConversionSupported = false;

            if (sourceSynchSupport.IsSessionEarnedCreditsSupported)
                target.SessionEarnedCredits = source.SessionEarnedCredits;
            else
                targetSynchSupport.IsSessionEarnedCreditsSupported = false;

            if (sourceSynchSupport.IsSessionEarnedCreditTypeSupported)
                target.SessionEarnedCreditType = source.SessionEarnedCreditType;
            else
                targetSynchSupport.IsSessionEarnedCreditTypeSupported = false;

            if (sourceSynchSupport.IsSessionGradePointAverageSupported)
                target.SessionGradePointAverage = source.SessionGradePointAverage;
            else
                targetSynchSupport.IsSessionGradePointAverageSupported = false;

            if (sourceSynchSupport.IsSessionGradePointsEarnedSupported)
                target.SessionGradePointsEarned = source.SessionGradePointsEarned;
            else
                targetSynchSupport.IsSessionGradePointsEarnedSupported = false;

            // ----------------------------------
            //   Map One-to-one relationships
            // ----------------------------------
            // StudentAcademicRecordClassRanking (Source)
            if (sourceSynchSupport.IsStudentAcademicRecordClassRankingSupported)
            {
                var itemProperty = target.GetType().GetProperty("StudentAcademicRecordClassRanking");
                
                if (itemProperty != null)
                {                    
                    if (source.StudentAcademicRecordClassRanking == null)
                    {
                        target.StudentAcademicRecordClassRanking = null;
                    }
                    else
                    {
                        var itemType = itemProperty.PropertyType;
                        object targetStudentAcademicRecordClassRanking = Activator.CreateInstance(itemType);

                        source.StudentAcademicRecordClassRanking.Map(targetStudentAcademicRecordClassRanking);
                        
                        // Update the target reference appropriately
                        target.StudentAcademicRecordClassRanking = (IStudentAcademicRecordClassRanking) targetStudentAcademicRecordClassRanking;
                    }
                }
            }
            else
            {
                targetSynchSupport.IsStudentAcademicRecordClassRankingSupported = false; 
            }
            // -------------------------------------------------------------

            // Map lists

            if (sourceSynchSupport.IsStudentAcademicRecordAcademicHonorsSupported)
            {    
                targetSynchSupport.IsStudentAcademicRecordAcademicHonorIncluded = sourceSynchSupport.IsStudentAcademicRecordAcademicHonorIncluded;
                source.StudentAcademicRecordAcademicHonors.MapListTo(target.StudentAcademicRecordAcademicHonors);
            }
            else
            {
                targetSynchSupport.IsStudentAcademicRecordAcademicHonorsSupported = false;
            }

            if (sourceSynchSupport.IsStudentAcademicRecordDiplomasSupported)
            {    
                targetSynchSupport.IsStudentAcademicRecordDiplomaIncluded = sourceSynchSupport.IsStudentAcademicRecordDiplomaIncluded;
                source.StudentAcademicRecordDiplomas.MapListTo(target.StudentAcademicRecordDiplomas);
            }
            else
            {
                targetSynchSupport.IsStudentAcademicRecordDiplomasSupported = false;
            }

            if (sourceSynchSupport.IsStudentAcademicRecordRecognitionsSupported)
            {    
                targetSynchSupport.IsStudentAcademicRecordRecognitionIncluded = sourceSynchSupport.IsStudentAcademicRecordRecognitionIncluded;
                source.StudentAcademicRecordRecognitions.MapListTo(target.StudentAcademicRecordRecognitions);
            }
            else
            {
                targetSynchSupport.IsStudentAcademicRecordRecognitionsSupported = false;
            }

            if (sourceSynchSupport.IsStudentAcademicRecordReportCardsSupported)
            {    
                targetSynchSupport.IsStudentAcademicRecordReportCardIncluded = sourceSynchSupport.IsStudentAcademicRecordReportCardIncluded;
                source.StudentAcademicRecordReportCards.MapListTo(target.StudentAcademicRecordReportCards);
            }
            else
            {
                targetSynchSupport.IsStudentAcademicRecordReportCardsSupported = false;
            }

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentAcademicRecordSynchronizationSourceSupport
    {
        bool IsCumulativeAttemptedCreditConversionSupported { get; set; }
        bool IsCumulativeAttemptedCreditsSupported { get; set; }
        bool IsCumulativeAttemptedCreditTypeSupported { get; set; }
        bool IsCumulativeEarnedCreditConversionSupported { get; set; }
        bool IsCumulativeEarnedCreditsSupported { get; set; }
        bool IsCumulativeEarnedCreditTypeSupported { get; set; }
        bool IsCumulativeGradePointAverageSupported { get; set; }
        bool IsCumulativeGradePointsEarnedSupported { get; set; }
        bool IsGradeValueQualifierSupported { get; set; }
        bool IsProjectedGraduationDateSupported { get; set; }
        bool IsSessionAttemptedCreditConversionSupported { get; set; }
        bool IsSessionAttemptedCreditsSupported { get; set; }
        bool IsSessionAttemptedCreditTypeSupported { get; set; }
        bool IsSessionEarnedCreditConversionSupported { get; set; }
        bool IsSessionEarnedCreditsSupported { get; set; }
        bool IsSessionEarnedCreditTypeSupported { get; set; }
        bool IsSessionGradePointAverageSupported { get; set; }
        bool IsSessionGradePointsEarnedSupported { get; set; }
        bool IsStudentAcademicRecordAcademicHonorsSupported { get; set; }
        bool IsStudentAcademicRecordClassRankingSupported { get; set; }
        bool IsStudentAcademicRecordDiplomasSupported { get; set; }
        bool IsStudentAcademicRecordRecognitionsSupported { get; set; }
        bool IsStudentAcademicRecordReportCardsSupported { get; set; }
        Func<IStudentAcademicRecordAcademicHonor, bool> IsStudentAcademicRecordAcademicHonorIncluded { get; set; }
        Func<IStudentAcademicRecordDiploma, bool> IsStudentAcademicRecordDiplomaIncluded { get; set; }
        Func<IStudentAcademicRecordRecognition, bool> IsStudentAcademicRecordRecognitionIncluded { get; set; }
        Func<IStudentAcademicRecordReportCard, bool> IsStudentAcademicRecordReportCardIncluded { get; set; }
    }
 
    public static class StudentAcademicRecordAcademicHonorMapper 
    {
        public static bool SynchronizeTo(this IStudentAcademicRecordAcademicHonor source, IStudentAcademicRecordAcademicHonor target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentAcademicRecordAcademicHonorSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AcademicHonorCategoryType != target.AcademicHonorCategoryType)
            {
                source.AcademicHonorCategoryType = target.AcademicHonorCategoryType;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsAchievementCategoryDescriptorSupported)
                && target.AchievementCategoryDescriptor != source.AchievementCategoryDescriptor)
            {
                target.AchievementCategoryDescriptor = source.AchievementCategoryDescriptor;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsAchievementCategorySystemSupported)
                && target.AchievementCategorySystem != source.AchievementCategorySystem)
            {
                target.AchievementCategorySystem = source.AchievementCategorySystem;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsAchievementTitleSupported)
                && target.AchievementTitle != source.AchievementTitle)
            {
                target.AchievementTitle = source.AchievementTitle;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsCriteriaSupported)
                && target.Criteria != source.Criteria)
            {
                target.Criteria = source.Criteria;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsCriteriaURLSupported)
                && target.CriteriaURL != source.CriteriaURL)
            {
                target.CriteriaURL = source.CriteriaURL;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEvidenceStatementSupported)
                && target.EvidenceStatement != source.EvidenceStatement)
            {
                target.EvidenceStatement = source.EvidenceStatement;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsHonorAwardDateSupported)
                && target.HonorAwardDate != source.HonorAwardDate)
            {
                target.HonorAwardDate = source.HonorAwardDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsHonorAwardExpiresDateSupported)
                && target.HonorAwardExpiresDate != source.HonorAwardExpiresDate)
            {
                target.HonorAwardExpiresDate = source.HonorAwardExpiresDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsHonorDescriptionSupported)
                && target.HonorDescription != source.HonorDescription)
            {
                target.HonorDescription = source.HonorDescription;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsImageURLSupported)
                && target.ImageURL != source.ImageURL)
            {
                target.ImageURL = source.ImageURL;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsIssuerNameSupported)
                && target.IssuerName != source.IssuerName)
            {
                target.IssuerName = source.IssuerName;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsIssuerOriginURLSupported)
                && target.IssuerOriginURL != source.IssuerOriginURL)
            {
                target.IssuerOriginURL = source.IssuerOriginURL;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStudentAcademicRecordAcademicHonor source, IStudentAcademicRecordAcademicHonor target, Action<IStudentAcademicRecordAcademicHonor, IStudentAcademicRecordAcademicHonor> onMapped)
        {
            var sourceSynchSupport = source as IStudentAcademicRecordAcademicHonorSynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentAcademicRecordAcademicHonorSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.AcademicHonorCategoryType = source.AcademicHonorCategoryType;

            // Copy non-PK properties

            if (sourceSynchSupport.IsAchievementCategoryDescriptorSupported)
                target.AchievementCategoryDescriptor = source.AchievementCategoryDescriptor;
            else
                targetSynchSupport.IsAchievementCategoryDescriptorSupported = false;

            if (sourceSynchSupport.IsAchievementCategorySystemSupported)
                target.AchievementCategorySystem = source.AchievementCategorySystem;
            else
                targetSynchSupport.IsAchievementCategorySystemSupported = false;

            if (sourceSynchSupport.IsAchievementTitleSupported)
                target.AchievementTitle = source.AchievementTitle;
            else
                targetSynchSupport.IsAchievementTitleSupported = false;

            if (sourceSynchSupport.IsCriteriaSupported)
                target.Criteria = source.Criteria;
            else
                targetSynchSupport.IsCriteriaSupported = false;

            if (sourceSynchSupport.IsCriteriaURLSupported)
                target.CriteriaURL = source.CriteriaURL;
            else
                targetSynchSupport.IsCriteriaURLSupported = false;

            if (sourceSynchSupport.IsEvidenceStatementSupported)
                target.EvidenceStatement = source.EvidenceStatement;
            else
                targetSynchSupport.IsEvidenceStatementSupported = false;

            if (sourceSynchSupport.IsHonorAwardDateSupported)
                target.HonorAwardDate = source.HonorAwardDate;
            else
                targetSynchSupport.IsHonorAwardDateSupported = false;

            if (sourceSynchSupport.IsHonorAwardExpiresDateSupported)
                target.HonorAwardExpiresDate = source.HonorAwardExpiresDate;
            else
                targetSynchSupport.IsHonorAwardExpiresDateSupported = false;

            if (sourceSynchSupport.IsHonorDescriptionSupported)
                target.HonorDescription = source.HonorDescription;
            else
                targetSynchSupport.IsHonorDescriptionSupported = false;

            if (sourceSynchSupport.IsImageURLSupported)
                target.ImageURL = source.ImageURL;
            else
                targetSynchSupport.IsImageURLSupported = false;

            if (sourceSynchSupport.IsIssuerNameSupported)
                target.IssuerName = source.IssuerName;
            else
                targetSynchSupport.IsIssuerNameSupported = false;

            if (sourceSynchSupport.IsIssuerOriginURLSupported)
                target.IssuerOriginURL = source.IssuerOriginURL;
            else
                targetSynchSupport.IsIssuerOriginURLSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentAcademicRecordAcademicHonorSynchronizationSourceSupport
    {
        bool IsAchievementCategoryDescriptorSupported { get; set; }
        bool IsAchievementCategorySystemSupported { get; set; }
        bool IsAchievementTitleSupported { get; set; }
        bool IsCriteriaSupported { get; set; }
        bool IsCriteriaURLSupported { get; set; }
        bool IsEvidenceStatementSupported { get; set; }
        bool IsHonorAwardDateSupported { get; set; }
        bool IsHonorAwardExpiresDateSupported { get; set; }
        bool IsHonorDescriptionSupported { get; set; }
        bool IsImageURLSupported { get; set; }
        bool IsIssuerNameSupported { get; set; }
        bool IsIssuerOriginURLSupported { get; set; }
    }
 
    public static class StudentAcademicRecordClassRankingMapper 
    {
        public static bool SynchronizeTo(this IStudentAcademicRecordClassRanking source, IStudentAcademicRecordClassRanking target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentAcademicRecordClassRankingSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsClassRankSupported)
                && target.ClassRank != source.ClassRank)
            {
                target.ClassRank = source.ClassRank;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsClassRankingDateSupported)
                && target.ClassRankingDate != source.ClassRankingDate)
            {
                target.ClassRankingDate = source.ClassRankingDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPercentageRankingSupported)
                && target.PercentageRanking != source.PercentageRanking)
            {
                target.PercentageRanking = source.PercentageRanking;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsTotalNumberInClassSupported)
                && target.TotalNumberInClass != source.TotalNumberInClass)
            {
                target.TotalNumberInClass = source.TotalNumberInClass;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStudentAcademicRecordClassRanking source, IStudentAcademicRecordClassRanking target, Action<IStudentAcademicRecordClassRanking, IStudentAcademicRecordClassRanking> onMapped)
        {
            var sourceSynchSupport = source as IStudentAcademicRecordClassRankingSynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentAcademicRecordClassRankingSynchronizationSourceSupport;

            // Copy contextual primary key values

            // Copy non-PK properties

            if (sourceSynchSupport.IsClassRankSupported)
                target.ClassRank = source.ClassRank;
            else
                targetSynchSupport.IsClassRankSupported = false;

            if (sourceSynchSupport.IsClassRankingDateSupported)
                target.ClassRankingDate = source.ClassRankingDate;
            else
                targetSynchSupport.IsClassRankingDateSupported = false;

            if (sourceSynchSupport.IsPercentageRankingSupported)
                target.PercentageRanking = source.PercentageRanking;
            else
                targetSynchSupport.IsPercentageRankingSupported = false;

            if (sourceSynchSupport.IsTotalNumberInClassSupported)
                target.TotalNumberInClass = source.TotalNumberInClass;
            else
                targetSynchSupport.IsTotalNumberInClassSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentAcademicRecordClassRankingSynchronizationSourceSupport
    {
        bool IsClassRankSupported { get; set; }
        bool IsClassRankingDateSupported { get; set; }
        bool IsPercentageRankingSupported { get; set; }
        bool IsTotalNumberInClassSupported { get; set; }
    }
 
    public static class StudentAcademicRecordDiplomaMapper 
    {
        public static bool SynchronizeTo(this IStudentAcademicRecordDiploma source, IStudentAcademicRecordDiploma target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentAcademicRecordDiplomaSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.DiplomaAwardDate != target.DiplomaAwardDate)
            {
                source.DiplomaAwardDate = target.DiplomaAwardDate;
            }
            if (source.DiplomaType != target.DiplomaType)
            {
                source.DiplomaType = target.DiplomaType;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsAchievementCategoryDescriptorSupported)
                && target.AchievementCategoryDescriptor != source.AchievementCategoryDescriptor)
            {
                target.AchievementCategoryDescriptor = source.AchievementCategoryDescriptor;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsAchievementCategorySystemSupported)
                && target.AchievementCategorySystem != source.AchievementCategorySystem)
            {
                target.AchievementCategorySystem = source.AchievementCategorySystem;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsAchievementTitleSupported)
                && target.AchievementTitle != source.AchievementTitle)
            {
                target.AchievementTitle = source.AchievementTitle;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsCriteriaSupported)
                && target.Criteria != source.Criteria)
            {
                target.Criteria = source.Criteria;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsCriteriaURLSupported)
                && target.CriteriaURL != source.CriteriaURL)
            {
                target.CriteriaURL = source.CriteriaURL;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsCTECompleterSupported)
                && target.CTECompleter != source.CTECompleter)
            {
                target.CTECompleter = source.CTECompleter;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDiplomaAwardExpiresDateSupported)
                && target.DiplomaAwardExpiresDate != source.DiplomaAwardExpiresDate)
            {
                target.DiplomaAwardExpiresDate = source.DiplomaAwardExpiresDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDiplomaDescriptionSupported)
                && target.DiplomaDescription != source.DiplomaDescription)
            {
                target.DiplomaDescription = source.DiplomaDescription;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDiplomaLevelTypeSupported)
                && target.DiplomaLevelType != source.DiplomaLevelType)
            {
                target.DiplomaLevelType = source.DiplomaLevelType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEvidenceStatementSupported)
                && target.EvidenceStatement != source.EvidenceStatement)
            {
                target.EvidenceStatement = source.EvidenceStatement;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsImageURLSupported)
                && target.ImageURL != source.ImageURL)
            {
                target.ImageURL = source.ImageURL;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsIssuerNameSupported)
                && target.IssuerName != source.IssuerName)
            {
                target.IssuerName = source.IssuerName;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsIssuerOriginURLSupported)
                && target.IssuerOriginURL != source.IssuerOriginURL)
            {
                target.IssuerOriginURL = source.IssuerOriginURL;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStudentAcademicRecordDiploma source, IStudentAcademicRecordDiploma target, Action<IStudentAcademicRecordDiploma, IStudentAcademicRecordDiploma> onMapped)
        {
            var sourceSynchSupport = source as IStudentAcademicRecordDiplomaSynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentAcademicRecordDiplomaSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.DiplomaAwardDate = source.DiplomaAwardDate;
            target.DiplomaType = source.DiplomaType;

            // Copy non-PK properties

            if (sourceSynchSupport.IsAchievementCategoryDescriptorSupported)
                target.AchievementCategoryDescriptor = source.AchievementCategoryDescriptor;
            else
                targetSynchSupport.IsAchievementCategoryDescriptorSupported = false;

            if (sourceSynchSupport.IsAchievementCategorySystemSupported)
                target.AchievementCategorySystem = source.AchievementCategorySystem;
            else
                targetSynchSupport.IsAchievementCategorySystemSupported = false;

            if (sourceSynchSupport.IsAchievementTitleSupported)
                target.AchievementTitle = source.AchievementTitle;
            else
                targetSynchSupport.IsAchievementTitleSupported = false;

            if (sourceSynchSupport.IsCriteriaSupported)
                target.Criteria = source.Criteria;
            else
                targetSynchSupport.IsCriteriaSupported = false;

            if (sourceSynchSupport.IsCriteriaURLSupported)
                target.CriteriaURL = source.CriteriaURL;
            else
                targetSynchSupport.IsCriteriaURLSupported = false;

            if (sourceSynchSupport.IsCTECompleterSupported)
                target.CTECompleter = source.CTECompleter;
            else
                targetSynchSupport.IsCTECompleterSupported = false;

            if (sourceSynchSupport.IsDiplomaAwardExpiresDateSupported)
                target.DiplomaAwardExpiresDate = source.DiplomaAwardExpiresDate;
            else
                targetSynchSupport.IsDiplomaAwardExpiresDateSupported = false;

            if (sourceSynchSupport.IsDiplomaDescriptionSupported)
                target.DiplomaDescription = source.DiplomaDescription;
            else
                targetSynchSupport.IsDiplomaDescriptionSupported = false;

            if (sourceSynchSupport.IsDiplomaLevelTypeSupported)
                target.DiplomaLevelType = source.DiplomaLevelType;
            else
                targetSynchSupport.IsDiplomaLevelTypeSupported = false;

            if (sourceSynchSupport.IsEvidenceStatementSupported)
                target.EvidenceStatement = source.EvidenceStatement;
            else
                targetSynchSupport.IsEvidenceStatementSupported = false;

            if (sourceSynchSupport.IsImageURLSupported)
                target.ImageURL = source.ImageURL;
            else
                targetSynchSupport.IsImageURLSupported = false;

            if (sourceSynchSupport.IsIssuerNameSupported)
                target.IssuerName = source.IssuerName;
            else
                targetSynchSupport.IsIssuerNameSupported = false;

            if (sourceSynchSupport.IsIssuerOriginURLSupported)
                target.IssuerOriginURL = source.IssuerOriginURL;
            else
                targetSynchSupport.IsIssuerOriginURLSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentAcademicRecordDiplomaSynchronizationSourceSupport
    {
        bool IsAchievementCategoryDescriptorSupported { get; set; }
        bool IsAchievementCategorySystemSupported { get; set; }
        bool IsAchievementTitleSupported { get; set; }
        bool IsCriteriaSupported { get; set; }
        bool IsCriteriaURLSupported { get; set; }
        bool IsCTECompleterSupported { get; set; }
        bool IsDiplomaAwardExpiresDateSupported { get; set; }
        bool IsDiplomaDescriptionSupported { get; set; }
        bool IsDiplomaLevelTypeSupported { get; set; }
        bool IsEvidenceStatementSupported { get; set; }
        bool IsImageURLSupported { get; set; }
        bool IsIssuerNameSupported { get; set; }
        bool IsIssuerOriginURLSupported { get; set; }
    }
 
    public static class StudentAcademicRecordRecognitionMapper 
    {
        public static bool SynchronizeTo(this IStudentAcademicRecordRecognition source, IStudentAcademicRecordRecognition target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentAcademicRecordRecognitionSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.RecognitionType != target.RecognitionType)
            {
                source.RecognitionType = target.RecognitionType;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsAchievementCategoryDescriptorSupported)
                && target.AchievementCategoryDescriptor != source.AchievementCategoryDescriptor)
            {
                target.AchievementCategoryDescriptor = source.AchievementCategoryDescriptor;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsAchievementCategorySystemSupported)
                && target.AchievementCategorySystem != source.AchievementCategorySystem)
            {
                target.AchievementCategorySystem = source.AchievementCategorySystem;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsAchievementTitleSupported)
                && target.AchievementTitle != source.AchievementTitle)
            {
                target.AchievementTitle = source.AchievementTitle;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsCriteriaSupported)
                && target.Criteria != source.Criteria)
            {
                target.Criteria = source.Criteria;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsCriteriaURLSupported)
                && target.CriteriaURL != source.CriteriaURL)
            {
                target.CriteriaURL = source.CriteriaURL;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEvidenceStatementSupported)
                && target.EvidenceStatement != source.EvidenceStatement)
            {
                target.EvidenceStatement = source.EvidenceStatement;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsImageURLSupported)
                && target.ImageURL != source.ImageURL)
            {
                target.ImageURL = source.ImageURL;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsIssuerNameSupported)
                && target.IssuerName != source.IssuerName)
            {
                target.IssuerName = source.IssuerName;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsIssuerOriginURLSupported)
                && target.IssuerOriginURL != source.IssuerOriginURL)
            {
                target.IssuerOriginURL = source.IssuerOriginURL;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsRecognitionAwardDateSupported)
                && target.RecognitionAwardDate != source.RecognitionAwardDate)
            {
                target.RecognitionAwardDate = source.RecognitionAwardDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsRecognitionAwardExpiresDateSupported)
                && target.RecognitionAwardExpiresDate != source.RecognitionAwardExpiresDate)
            {
                target.RecognitionAwardExpiresDate = source.RecognitionAwardExpiresDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsRecognitionDescriptionSupported)
                && target.RecognitionDescription != source.RecognitionDescription)
            {
                target.RecognitionDescription = source.RecognitionDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStudentAcademicRecordRecognition source, IStudentAcademicRecordRecognition target, Action<IStudentAcademicRecordRecognition, IStudentAcademicRecordRecognition> onMapped)
        {
            var sourceSynchSupport = source as IStudentAcademicRecordRecognitionSynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentAcademicRecordRecognitionSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.RecognitionType = source.RecognitionType;

            // Copy non-PK properties

            if (sourceSynchSupport.IsAchievementCategoryDescriptorSupported)
                target.AchievementCategoryDescriptor = source.AchievementCategoryDescriptor;
            else
                targetSynchSupport.IsAchievementCategoryDescriptorSupported = false;

            if (sourceSynchSupport.IsAchievementCategorySystemSupported)
                target.AchievementCategorySystem = source.AchievementCategorySystem;
            else
                targetSynchSupport.IsAchievementCategorySystemSupported = false;

            if (sourceSynchSupport.IsAchievementTitleSupported)
                target.AchievementTitle = source.AchievementTitle;
            else
                targetSynchSupport.IsAchievementTitleSupported = false;

            if (sourceSynchSupport.IsCriteriaSupported)
                target.Criteria = source.Criteria;
            else
                targetSynchSupport.IsCriteriaSupported = false;

            if (sourceSynchSupport.IsCriteriaURLSupported)
                target.CriteriaURL = source.CriteriaURL;
            else
                targetSynchSupport.IsCriteriaURLSupported = false;

            if (sourceSynchSupport.IsEvidenceStatementSupported)
                target.EvidenceStatement = source.EvidenceStatement;
            else
                targetSynchSupport.IsEvidenceStatementSupported = false;

            if (sourceSynchSupport.IsImageURLSupported)
                target.ImageURL = source.ImageURL;
            else
                targetSynchSupport.IsImageURLSupported = false;

            if (sourceSynchSupport.IsIssuerNameSupported)
                target.IssuerName = source.IssuerName;
            else
                targetSynchSupport.IsIssuerNameSupported = false;

            if (sourceSynchSupport.IsIssuerOriginURLSupported)
                target.IssuerOriginURL = source.IssuerOriginURL;
            else
                targetSynchSupport.IsIssuerOriginURLSupported = false;

            if (sourceSynchSupport.IsRecognitionAwardDateSupported)
                target.RecognitionAwardDate = source.RecognitionAwardDate;
            else
                targetSynchSupport.IsRecognitionAwardDateSupported = false;

            if (sourceSynchSupport.IsRecognitionAwardExpiresDateSupported)
                target.RecognitionAwardExpiresDate = source.RecognitionAwardExpiresDate;
            else
                targetSynchSupport.IsRecognitionAwardExpiresDateSupported = false;

            if (sourceSynchSupport.IsRecognitionDescriptionSupported)
                target.RecognitionDescription = source.RecognitionDescription;
            else
                targetSynchSupport.IsRecognitionDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentAcademicRecordRecognitionSynchronizationSourceSupport
    {
        bool IsAchievementCategoryDescriptorSupported { get; set; }
        bool IsAchievementCategorySystemSupported { get; set; }
        bool IsAchievementTitleSupported { get; set; }
        bool IsCriteriaSupported { get; set; }
        bool IsCriteriaURLSupported { get; set; }
        bool IsEvidenceStatementSupported { get; set; }
        bool IsImageURLSupported { get; set; }
        bool IsIssuerNameSupported { get; set; }
        bool IsIssuerOriginURLSupported { get; set; }
        bool IsRecognitionAwardDateSupported { get; set; }
        bool IsRecognitionAwardExpiresDateSupported { get; set; }
        bool IsRecognitionDescriptionSupported { get; set; }
    }
 
    public static class StudentAcademicRecordReportCardMapper 
    {
        public static bool SynchronizeTo(this IStudentAcademicRecordReportCard source, IStudentAcademicRecordReportCard target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentAcademicRecordReportCardSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.GradingPeriodBeginDate != target.GradingPeriodBeginDate)
            {
                source.GradingPeriodBeginDate = target.GradingPeriodBeginDate;
            }
            if (source.GradingPeriodDescriptor != target.GradingPeriodDescriptor)
            {
                source.GradingPeriodDescriptor = target.GradingPeriodDescriptor;
            }
            if (source.SchoolId != target.SchoolId)
            {
                source.SchoolId = target.SchoolId;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStudentAcademicRecordReportCard source, IStudentAcademicRecordReportCard target, Action<IStudentAcademicRecordReportCard, IStudentAcademicRecordReportCard> onMapped)
        {
            var sourceSynchSupport = source as IStudentAcademicRecordReportCardSynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentAcademicRecordReportCardSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.GradingPeriodBeginDate = source.GradingPeriodBeginDate;
            target.GradingPeriodDescriptor = source.GradingPeriodDescriptor;
            target.SchoolId = source.SchoolId;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentAcademicRecordReportCardSynchronizationSourceSupport
    {
    }
 
}
// Aggregate: StudentAssessment

namespace EdFi.Ods.Entities.Common //.StudentAssessmentAggregate
{ 
    public static class StudentAssessmentMapper 
    {
        public static bool SynchronizeTo(this IStudentAssessment source, IStudentAssessment target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentAssessmentSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AssessmentIdentifier != target.AssessmentIdentifier)
            {
                source.AssessmentIdentifier = target.AssessmentIdentifier;
            }
            if (source.Namespace != target.Namespace)
            {
                source.Namespace = target.Namespace;
            }
            if (source.StudentAssessmentIdentifier != target.StudentAssessmentIdentifier)
            {
                source.StudentAssessmentIdentifier = target.StudentAssessmentIdentifier;
            }
            if (source.StudentUniqueId != target.StudentUniqueId)
            {
                source.StudentUniqueId = target.StudentUniqueId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsAdministrationDateSupported)
                && target.AdministrationDate != source.AdministrationDate)
            {
                target.AdministrationDate = source.AdministrationDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsAdministrationEndDateSupported)
                && target.AdministrationEndDate != source.AdministrationEndDate)
            {
                target.AdministrationEndDate = source.AdministrationEndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsAdministrationEnvironmentTypeSupported)
                && target.AdministrationEnvironmentType != source.AdministrationEnvironmentType)
            {
                target.AdministrationEnvironmentType = source.AdministrationEnvironmentType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsAdministrationLanguageDescriptorSupported)
                && target.AdministrationLanguageDescriptor != source.AdministrationLanguageDescriptor)
            {
                target.AdministrationLanguageDescriptor = source.AdministrationLanguageDescriptor;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEventCircumstanceTypeSupported)
                && target.EventCircumstanceType != source.EventCircumstanceType)
            {
                target.EventCircumstanceType = source.EventCircumstanceType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEventDescriptionSupported)
                && target.EventDescription != source.EventDescription)
            {
                target.EventDescription = source.EventDescription;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsReasonNotTestedTypeSupported)
                && target.ReasonNotTestedType != source.ReasonNotTestedType)
            {
                target.ReasonNotTestedType = source.ReasonNotTestedType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsRetestIndicatorTypeSupported)
                && target.RetestIndicatorType != source.RetestIndicatorType)
            {
                target.RetestIndicatorType = source.RetestIndicatorType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsSerialNumberSupported)
                && target.SerialNumber != source.SerialNumber)
            {
                target.SerialNumber = source.SerialNumber;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsWhenAssessedGradeLevelDescriptorSupported)
                && target.WhenAssessedGradeLevelDescriptor != source.WhenAssessedGradeLevelDescriptor)
            {
                target.WhenAssessedGradeLevelDescriptor = source.WhenAssessedGradeLevelDescriptor;
                isModified = true;
            }



            // Sync lists
            if (sourceSupport == null || sourceSupport.IsStudentAssessmentAccommodationsSupported)
                isModified |= source.StudentAssessmentAccommodations.SynchronizeListTo(target.StudentAssessmentAccommodations, child => child.StudentAssessment = target,
                                sourceSupport == null ? null : sourceSupport.IsStudentAssessmentAccommodationIncluded);

            if (sourceSupport == null || sourceSupport.IsStudentAssessmentItemsSupported)
                isModified |= source.StudentAssessmentItems.SynchronizeListTo(target.StudentAssessmentItems, child => child.StudentAssessment = target,
                                sourceSupport == null ? null : sourceSupport.IsStudentAssessmentItemIncluded);

            if (sourceSupport == null || sourceSupport.IsStudentAssessmentPerformanceLevelsSupported)
                isModified |= source.StudentAssessmentPerformanceLevels.SynchronizeListTo(target.StudentAssessmentPerformanceLevels, child => child.StudentAssessment = target,
                                sourceSupport == null ? null : sourceSupport.IsStudentAssessmentPerformanceLevelIncluded);

            if (sourceSupport == null || sourceSupport.IsStudentAssessmentScoreResultsSupported)
                isModified |= source.StudentAssessmentScoreResults.SynchronizeListTo(target.StudentAssessmentScoreResults, child => child.StudentAssessment = target,
                                sourceSupport == null ? null : sourceSupport.IsStudentAssessmentScoreResultIncluded);

            if (sourceSupport == null || sourceSupport.IsStudentAssessmentStudentObjectiveAssessmentsSupported)
                isModified |= source.StudentAssessmentStudentObjectiveAssessments.SynchronizeListTo(target.StudentAssessmentStudentObjectiveAssessments, child => child.StudentAssessment = target,
                                sourceSupport == null ? null : sourceSupport.IsStudentAssessmentStudentObjectiveAssessmentIncluded);


            return isModified;
        }



        public static void MapTo(this IStudentAssessment source, IStudentAssessment target, Action<IStudentAssessment, IStudentAssessment> onMapped)
        {
            var sourceSynchSupport = source as IStudentAssessmentSynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentAssessmentSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.AssessmentIdentifier = source.AssessmentIdentifier;
            target.Namespace = source.Namespace;
            target.StudentAssessmentIdentifier = source.StudentAssessmentIdentifier;
            target.StudentUniqueId = source.StudentUniqueId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsAdministrationDateSupported)
                target.AdministrationDate = source.AdministrationDate;
            else
                targetSynchSupport.IsAdministrationDateSupported = false;

            if (sourceSynchSupport.IsAdministrationEndDateSupported)
                target.AdministrationEndDate = source.AdministrationEndDate;
            else
                targetSynchSupport.IsAdministrationEndDateSupported = false;

            if (sourceSynchSupport.IsAdministrationEnvironmentTypeSupported)
                target.AdministrationEnvironmentType = source.AdministrationEnvironmentType;
            else
                targetSynchSupport.IsAdministrationEnvironmentTypeSupported = false;

            if (sourceSynchSupport.IsAdministrationLanguageDescriptorSupported)
                target.AdministrationLanguageDescriptor = source.AdministrationLanguageDescriptor;
            else
                targetSynchSupport.IsAdministrationLanguageDescriptorSupported = false;

            if (sourceSynchSupport.IsEventCircumstanceTypeSupported)
                target.EventCircumstanceType = source.EventCircumstanceType;
            else
                targetSynchSupport.IsEventCircumstanceTypeSupported = false;

            if (sourceSynchSupport.IsEventDescriptionSupported)
                target.EventDescription = source.EventDescription;
            else
                targetSynchSupport.IsEventDescriptionSupported = false;

            if (sourceSynchSupport.IsReasonNotTestedTypeSupported)
                target.ReasonNotTestedType = source.ReasonNotTestedType;
            else
                targetSynchSupport.IsReasonNotTestedTypeSupported = false;

            if (sourceSynchSupport.IsRetestIndicatorTypeSupported)
                target.RetestIndicatorType = source.RetestIndicatorType;
            else
                targetSynchSupport.IsRetestIndicatorTypeSupported = false;

            if (sourceSynchSupport.IsSerialNumberSupported)
                target.SerialNumber = source.SerialNumber;
            else
                targetSynchSupport.IsSerialNumberSupported = false;

            if (sourceSynchSupport.IsWhenAssessedGradeLevelDescriptorSupported)
                target.WhenAssessedGradeLevelDescriptor = source.WhenAssessedGradeLevelDescriptor;
            else
                targetSynchSupport.IsWhenAssessedGradeLevelDescriptorSupported = false;

            // Map lists

            if (sourceSynchSupport.IsStudentAssessmentAccommodationsSupported)
            {    
                targetSynchSupport.IsStudentAssessmentAccommodationIncluded = sourceSynchSupport.IsStudentAssessmentAccommodationIncluded;
                source.StudentAssessmentAccommodations.MapListTo(target.StudentAssessmentAccommodations);
            }
            else
            {
                targetSynchSupport.IsStudentAssessmentAccommodationsSupported = false;
            }

            if (sourceSynchSupport.IsStudentAssessmentItemsSupported)
            {    
                targetSynchSupport.IsStudentAssessmentItemIncluded = sourceSynchSupport.IsStudentAssessmentItemIncluded;
                source.StudentAssessmentItems.MapListTo(target.StudentAssessmentItems);
            }
            else
            {
                targetSynchSupport.IsStudentAssessmentItemsSupported = false;
            }

            if (sourceSynchSupport.IsStudentAssessmentPerformanceLevelsSupported)
            {    
                targetSynchSupport.IsStudentAssessmentPerformanceLevelIncluded = sourceSynchSupport.IsStudentAssessmentPerformanceLevelIncluded;
                source.StudentAssessmentPerformanceLevels.MapListTo(target.StudentAssessmentPerformanceLevels);
            }
            else
            {
                targetSynchSupport.IsStudentAssessmentPerformanceLevelsSupported = false;
            }

            if (sourceSynchSupport.IsStudentAssessmentScoreResultsSupported)
            {    
                targetSynchSupport.IsStudentAssessmentScoreResultIncluded = sourceSynchSupport.IsStudentAssessmentScoreResultIncluded;
                source.StudentAssessmentScoreResults.MapListTo(target.StudentAssessmentScoreResults);
            }
            else
            {
                targetSynchSupport.IsStudentAssessmentScoreResultsSupported = false;
            }

            if (sourceSynchSupport.IsStudentAssessmentStudentObjectiveAssessmentsSupported)
            {    
                targetSynchSupport.IsStudentAssessmentStudentObjectiveAssessmentIncluded = sourceSynchSupport.IsStudentAssessmentStudentObjectiveAssessmentIncluded;
                source.StudentAssessmentStudentObjectiveAssessments.MapListTo(target.StudentAssessmentStudentObjectiveAssessments);
            }
            else
            {
                targetSynchSupport.IsStudentAssessmentStudentObjectiveAssessmentsSupported = false;
            }

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentAssessmentSynchronizationSourceSupport
    {
        bool IsAdministrationDateSupported { get; set; }
        bool IsAdministrationEndDateSupported { get; set; }
        bool IsAdministrationEnvironmentTypeSupported { get; set; }
        bool IsAdministrationLanguageDescriptorSupported { get; set; }
        bool IsEventCircumstanceTypeSupported { get; set; }
        bool IsEventDescriptionSupported { get; set; }
        bool IsReasonNotTestedTypeSupported { get; set; }
        bool IsRetestIndicatorTypeSupported { get; set; }
        bool IsSerialNumberSupported { get; set; }
        bool IsStudentAssessmentAccommodationsSupported { get; set; }
        bool IsStudentAssessmentItemsSupported { get; set; }
        bool IsStudentAssessmentPerformanceLevelsSupported { get; set; }
        bool IsStudentAssessmentScoreResultsSupported { get; set; }
        bool IsStudentAssessmentStudentObjectiveAssessmentsSupported { get; set; }
        bool IsWhenAssessedGradeLevelDescriptorSupported { get; set; }
        Func<IStudentAssessmentAccommodation, bool> IsStudentAssessmentAccommodationIncluded { get; set; }
        Func<IStudentAssessmentItem, bool> IsStudentAssessmentItemIncluded { get; set; }
        Func<IStudentAssessmentPerformanceLevel, bool> IsStudentAssessmentPerformanceLevelIncluded { get; set; }
        Func<IStudentAssessmentScoreResult, bool> IsStudentAssessmentScoreResultIncluded { get; set; }
        Func<IStudentAssessmentStudentObjectiveAssessment, bool> IsStudentAssessmentStudentObjectiveAssessmentIncluded { get; set; }
    }
 
    public static class StudentAssessmentAccommodationMapper 
    {
        public static bool SynchronizeTo(this IStudentAssessmentAccommodation source, IStudentAssessmentAccommodation target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentAssessmentAccommodationSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AccommodationDescriptor != target.AccommodationDescriptor)
            {
                source.AccommodationDescriptor = target.AccommodationDescriptor;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStudentAssessmentAccommodation source, IStudentAssessmentAccommodation target, Action<IStudentAssessmentAccommodation, IStudentAssessmentAccommodation> onMapped)
        {
            var sourceSynchSupport = source as IStudentAssessmentAccommodationSynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentAssessmentAccommodationSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.AccommodationDescriptor = source.AccommodationDescriptor;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentAssessmentAccommodationSynchronizationSourceSupport
    {
    }
 
    public static class StudentAssessmentItemMapper 
    {
        public static bool SynchronizeTo(this IStudentAssessmentItem source, IStudentAssessmentItem target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentAssessmentItemSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.IdentificationCode != target.IdentificationCode)
            {
                source.IdentificationCode = target.IdentificationCode;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsAssessmentItemResultTypeSupported)
                && target.AssessmentItemResultType != source.AssessmentItemResultType)
            {
                target.AssessmentItemResultType = source.AssessmentItemResultType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsAssessmentResponseSupported)
                && target.AssessmentResponse != source.AssessmentResponse)
            {
                target.AssessmentResponse = source.AssessmentResponse;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptiveFeedbackSupported)
                && target.DescriptiveFeedback != source.DescriptiveFeedback)
            {
                target.DescriptiveFeedback = source.DescriptiveFeedback;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsRawScoreResultSupported)
                && target.RawScoreResult != source.RawScoreResult)
            {
                target.RawScoreResult = source.RawScoreResult;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsResponseIndicatorTypeSupported)
                && target.ResponseIndicatorType != source.ResponseIndicatorType)
            {
                target.ResponseIndicatorType = source.ResponseIndicatorType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsTimeAssessedSupported)
                && target.TimeAssessed != source.TimeAssessed)
            {
                target.TimeAssessed = source.TimeAssessed;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStudentAssessmentItem source, IStudentAssessmentItem target, Action<IStudentAssessmentItem, IStudentAssessmentItem> onMapped)
        {
            var sourceSynchSupport = source as IStudentAssessmentItemSynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentAssessmentItemSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.IdentificationCode = source.IdentificationCode;

            // Copy non-PK properties

            if (sourceSynchSupport.IsAssessmentItemResultTypeSupported)
                target.AssessmentItemResultType = source.AssessmentItemResultType;
            else
                targetSynchSupport.IsAssessmentItemResultTypeSupported = false;

            if (sourceSynchSupport.IsAssessmentResponseSupported)
                target.AssessmentResponse = source.AssessmentResponse;
            else
                targetSynchSupport.IsAssessmentResponseSupported = false;

            if (sourceSynchSupport.IsDescriptiveFeedbackSupported)
                target.DescriptiveFeedback = source.DescriptiveFeedback;
            else
                targetSynchSupport.IsDescriptiveFeedbackSupported = false;

            if (sourceSynchSupport.IsRawScoreResultSupported)
                target.RawScoreResult = source.RawScoreResult;
            else
                targetSynchSupport.IsRawScoreResultSupported = false;

            if (sourceSynchSupport.IsResponseIndicatorTypeSupported)
                target.ResponseIndicatorType = source.ResponseIndicatorType;
            else
                targetSynchSupport.IsResponseIndicatorTypeSupported = false;

            if (sourceSynchSupport.IsTimeAssessedSupported)
                target.TimeAssessed = source.TimeAssessed;
            else
                targetSynchSupport.IsTimeAssessedSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentAssessmentItemSynchronizationSourceSupport
    {
        bool IsAssessmentItemResultTypeSupported { get; set; }
        bool IsAssessmentResponseSupported { get; set; }
        bool IsDescriptiveFeedbackSupported { get; set; }
        bool IsRawScoreResultSupported { get; set; }
        bool IsResponseIndicatorTypeSupported { get; set; }
        bool IsTimeAssessedSupported { get; set; }
    }
 
    public static class StudentAssessmentPerformanceLevelMapper 
    {
        public static bool SynchronizeTo(this IStudentAssessmentPerformanceLevel source, IStudentAssessmentPerformanceLevel target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentAssessmentPerformanceLevelSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AssessmentReportingMethodType != target.AssessmentReportingMethodType)
            {
                source.AssessmentReportingMethodType = target.AssessmentReportingMethodType;
            }
            if (source.PerformanceLevelDescriptor != target.PerformanceLevelDescriptor)
            {
                source.PerformanceLevelDescriptor = target.PerformanceLevelDescriptor;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsPerformanceLevelMetSupported)
                && target.PerformanceLevelMet != source.PerformanceLevelMet)
            {
                target.PerformanceLevelMet = source.PerformanceLevelMet;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStudentAssessmentPerformanceLevel source, IStudentAssessmentPerformanceLevel target, Action<IStudentAssessmentPerformanceLevel, IStudentAssessmentPerformanceLevel> onMapped)
        {
            var sourceSynchSupport = source as IStudentAssessmentPerformanceLevelSynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentAssessmentPerformanceLevelSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.AssessmentReportingMethodType = source.AssessmentReportingMethodType;
            target.PerformanceLevelDescriptor = source.PerformanceLevelDescriptor;

            // Copy non-PK properties

            if (sourceSynchSupport.IsPerformanceLevelMetSupported)
                target.PerformanceLevelMet = source.PerformanceLevelMet;
            else
                targetSynchSupport.IsPerformanceLevelMetSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentAssessmentPerformanceLevelSynchronizationSourceSupport
    {
        bool IsPerformanceLevelMetSupported { get; set; }
    }
 
    public static class StudentAssessmentScoreResultMapper 
    {
        public static bool SynchronizeTo(this IStudentAssessmentScoreResult source, IStudentAssessmentScoreResult target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentAssessmentScoreResultSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AssessmentReportingMethodType != target.AssessmentReportingMethodType)
            {
                source.AssessmentReportingMethodType = target.AssessmentReportingMethodType;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsResultSupported)
                && target.Result != source.Result)
            {
                target.Result = source.Result;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsResultDatatypeTypeSupported)
                && target.ResultDatatypeType != source.ResultDatatypeType)
            {
                target.ResultDatatypeType = source.ResultDatatypeType;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStudentAssessmentScoreResult source, IStudentAssessmentScoreResult target, Action<IStudentAssessmentScoreResult, IStudentAssessmentScoreResult> onMapped)
        {
            var sourceSynchSupport = source as IStudentAssessmentScoreResultSynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentAssessmentScoreResultSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.AssessmentReportingMethodType = source.AssessmentReportingMethodType;

            // Copy non-PK properties

            if (sourceSynchSupport.IsResultSupported)
                target.Result = source.Result;
            else
                targetSynchSupport.IsResultSupported = false;

            if (sourceSynchSupport.IsResultDatatypeTypeSupported)
                target.ResultDatatypeType = source.ResultDatatypeType;
            else
                targetSynchSupport.IsResultDatatypeTypeSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentAssessmentScoreResultSynchronizationSourceSupport
    {
        bool IsResultSupported { get; set; }
        bool IsResultDatatypeTypeSupported { get; set; }
    }
 
    public static class StudentAssessmentStudentObjectiveAssessmentMapper 
    {
        public static bool SynchronizeTo(this IStudentAssessmentStudentObjectiveAssessment source, IStudentAssessmentStudentObjectiveAssessment target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentAssessmentStudentObjectiveAssessmentSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.IdentificationCode != target.IdentificationCode)
            {
                source.IdentificationCode = target.IdentificationCode;
            }

            // Copy non-PK properties



            // Sync lists
            if (sourceSupport == null || sourceSupport.IsStudentAssessmentStudentObjectiveAssessmentPerformanceLevelsSupported)
                isModified |= source.StudentAssessmentStudentObjectiveAssessmentPerformanceLevels.SynchronizeListTo(target.StudentAssessmentStudentObjectiveAssessmentPerformanceLevels, child => child.StudentAssessmentStudentObjectiveAssessment = target,
                                sourceSupport == null ? null : sourceSupport.IsStudentAssessmentStudentObjectiveAssessmentPerformanceLevelIncluded);

            if (sourceSupport == null || sourceSupport.IsStudentAssessmentStudentObjectiveAssessmentScoreResultsSupported)
                isModified |= source.StudentAssessmentStudentObjectiveAssessmentScoreResults.SynchronizeListTo(target.StudentAssessmentStudentObjectiveAssessmentScoreResults, child => child.StudentAssessmentStudentObjectiveAssessment = target,
                                sourceSupport == null ? null : sourceSupport.IsStudentAssessmentStudentObjectiveAssessmentScoreResultIncluded);


            return isModified;
        }



        public static void MapTo(this IStudentAssessmentStudentObjectiveAssessment source, IStudentAssessmentStudentObjectiveAssessment target, Action<IStudentAssessmentStudentObjectiveAssessment, IStudentAssessmentStudentObjectiveAssessment> onMapped)
        {
            var sourceSynchSupport = source as IStudentAssessmentStudentObjectiveAssessmentSynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentAssessmentStudentObjectiveAssessmentSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.IdentificationCode = source.IdentificationCode;

            // Copy non-PK properties

            // Map lists

            if (sourceSynchSupport.IsStudentAssessmentStudentObjectiveAssessmentPerformanceLevelsSupported)
            {    
                targetSynchSupport.IsStudentAssessmentStudentObjectiveAssessmentPerformanceLevelIncluded = sourceSynchSupport.IsStudentAssessmentStudentObjectiveAssessmentPerformanceLevelIncluded;
                source.StudentAssessmentStudentObjectiveAssessmentPerformanceLevels.MapListTo(target.StudentAssessmentStudentObjectiveAssessmentPerformanceLevels);
            }
            else
            {
                targetSynchSupport.IsStudentAssessmentStudentObjectiveAssessmentPerformanceLevelsSupported = false;
            }

            if (sourceSynchSupport.IsStudentAssessmentStudentObjectiveAssessmentScoreResultsSupported)
            {    
                targetSynchSupport.IsStudentAssessmentStudentObjectiveAssessmentScoreResultIncluded = sourceSynchSupport.IsStudentAssessmentStudentObjectiveAssessmentScoreResultIncluded;
                source.StudentAssessmentStudentObjectiveAssessmentScoreResults.MapListTo(target.StudentAssessmentStudentObjectiveAssessmentScoreResults);
            }
            else
            {
                targetSynchSupport.IsStudentAssessmentStudentObjectiveAssessmentScoreResultsSupported = false;
            }

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentAssessmentStudentObjectiveAssessmentSynchronizationSourceSupport
    {
        bool IsStudentAssessmentStudentObjectiveAssessmentPerformanceLevelsSupported { get; set; }
        bool IsStudentAssessmentStudentObjectiveAssessmentScoreResultsSupported { get; set; }
        Func<IStudentAssessmentStudentObjectiveAssessmentPerformanceLevel, bool> IsStudentAssessmentStudentObjectiveAssessmentPerformanceLevelIncluded { get; set; }
        Func<IStudentAssessmentStudentObjectiveAssessmentScoreResult, bool> IsStudentAssessmentStudentObjectiveAssessmentScoreResultIncluded { get; set; }
    }
 
    public static class StudentAssessmentStudentObjectiveAssessmentPerformanceLevelMapper 
    {
        public static bool SynchronizeTo(this IStudentAssessmentStudentObjectiveAssessmentPerformanceLevel source, IStudentAssessmentStudentObjectiveAssessmentPerformanceLevel target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentAssessmentStudentObjectiveAssessmentPerformanceLevelSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AssessmentReportingMethodType != target.AssessmentReportingMethodType)
            {
                source.AssessmentReportingMethodType = target.AssessmentReportingMethodType;
            }
            if (source.PerformanceLevelDescriptor != target.PerformanceLevelDescriptor)
            {
                source.PerformanceLevelDescriptor = target.PerformanceLevelDescriptor;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsPerformanceLevelMetSupported)
                && target.PerformanceLevelMet != source.PerformanceLevelMet)
            {
                target.PerformanceLevelMet = source.PerformanceLevelMet;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStudentAssessmentStudentObjectiveAssessmentPerformanceLevel source, IStudentAssessmentStudentObjectiveAssessmentPerformanceLevel target, Action<IStudentAssessmentStudentObjectiveAssessmentPerformanceLevel, IStudentAssessmentStudentObjectiveAssessmentPerformanceLevel> onMapped)
        {
            var sourceSynchSupport = source as IStudentAssessmentStudentObjectiveAssessmentPerformanceLevelSynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentAssessmentStudentObjectiveAssessmentPerformanceLevelSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.AssessmentReportingMethodType = source.AssessmentReportingMethodType;
            target.PerformanceLevelDescriptor = source.PerformanceLevelDescriptor;

            // Copy non-PK properties

            if (sourceSynchSupport.IsPerformanceLevelMetSupported)
                target.PerformanceLevelMet = source.PerformanceLevelMet;
            else
                targetSynchSupport.IsPerformanceLevelMetSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentAssessmentStudentObjectiveAssessmentPerformanceLevelSynchronizationSourceSupport
    {
        bool IsPerformanceLevelMetSupported { get; set; }
    }
 
    public static class StudentAssessmentStudentObjectiveAssessmentScoreResultMapper 
    {
        public static bool SynchronizeTo(this IStudentAssessmentStudentObjectiveAssessmentScoreResult source, IStudentAssessmentStudentObjectiveAssessmentScoreResult target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentAssessmentStudentObjectiveAssessmentScoreResultSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AssessmentReportingMethodType != target.AssessmentReportingMethodType)
            {
                source.AssessmentReportingMethodType = target.AssessmentReportingMethodType;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsResultSupported)
                && target.Result != source.Result)
            {
                target.Result = source.Result;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsResultDatatypeTypeSupported)
                && target.ResultDatatypeType != source.ResultDatatypeType)
            {
                target.ResultDatatypeType = source.ResultDatatypeType;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStudentAssessmentStudentObjectiveAssessmentScoreResult source, IStudentAssessmentStudentObjectiveAssessmentScoreResult target, Action<IStudentAssessmentStudentObjectiveAssessmentScoreResult, IStudentAssessmentStudentObjectiveAssessmentScoreResult> onMapped)
        {
            var sourceSynchSupport = source as IStudentAssessmentStudentObjectiveAssessmentScoreResultSynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentAssessmentStudentObjectiveAssessmentScoreResultSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.AssessmentReportingMethodType = source.AssessmentReportingMethodType;

            // Copy non-PK properties

            if (sourceSynchSupport.IsResultSupported)
                target.Result = source.Result;
            else
                targetSynchSupport.IsResultSupported = false;

            if (sourceSynchSupport.IsResultDatatypeTypeSupported)
                target.ResultDatatypeType = source.ResultDatatypeType;
            else
                targetSynchSupport.IsResultDatatypeTypeSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentAssessmentStudentObjectiveAssessmentScoreResultSynchronizationSourceSupport
    {
        bool IsResultSupported { get; set; }
        bool IsResultDatatypeTypeSupported { get; set; }
    }
 
}
// Aggregate: StudentCharacteristicDescriptor

namespace EdFi.Ods.Entities.Common //.StudentCharacteristicDescriptorAggregate
{ 
    public static class StudentCharacteristicDescriptorMapper 
    {
        public static bool SynchronizeTo(this IStudentCharacteristicDescriptor source, IStudentCharacteristicDescriptor target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentCharacteristicDescriptorSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.StudentCharacteristicDescriptorId != target.StudentCharacteristicDescriptorId)
            {
                source.StudentCharacteristicDescriptorId = target.StudentCharacteristicDescriptorId;
            }

            // Copy inherited non-PK properties


            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveBeginDateSupported)
                && target.EffectiveBeginDate != source.EffectiveBeginDate)
            {
                target.EffectiveBeginDate = source.EffectiveBeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveEndDateSupported)
                && target.EffectiveEndDate != source.EffectiveEndDate)
            {
                target.EffectiveEndDate = source.EffectiveEndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNamespaceSupported)
                && target.Namespace != source.Namespace)
            {
                target.Namespace = source.Namespace;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPriorDescriptorIdSupported)
                && target.PriorDescriptorId != source.PriorDescriptorId)
            {
                target.PriorDescriptorId = source.PriorDescriptorId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsStudentCharacteristicTypeSupported)
                && target.StudentCharacteristicType != source.StudentCharacteristicType)
            {
                target.StudentCharacteristicType = source.StudentCharacteristicType;
                isModified = true;
            }

            // Synch inherited lists


            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStudentCharacteristicDescriptor source, IStudentCharacteristicDescriptor target, Action<IStudentCharacteristicDescriptor, IStudentCharacteristicDescriptor> onMapped)
        {
            var sourceSynchSupport = source as IStudentCharacteristicDescriptorSynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentCharacteristicDescriptorSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.StudentCharacteristicDescriptorId = source.StudentCharacteristicDescriptorId;

            // Copy inherited non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsEffectiveBeginDateSupported)
                target.EffectiveBeginDate = source.EffectiveBeginDate;
            else
                targetSynchSupport.IsEffectiveBeginDateSupported = false;

            if (sourceSynchSupport.IsEffectiveEndDateSupported)
                target.EffectiveEndDate = source.EffectiveEndDate;
            else
                targetSynchSupport.IsEffectiveEndDateSupported = false;

            if (sourceSynchSupport.IsNamespaceSupported)
                target.Namespace = source.Namespace;
            else
                targetSynchSupport.IsNamespaceSupported = false;

            if (sourceSynchSupport.IsPriorDescriptorIdSupported)
                target.PriorDescriptorId = source.PriorDescriptorId;
            else
                targetSynchSupport.IsPriorDescriptorIdSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Copy non-PK properties

            if (sourceSynchSupport.IsStudentCharacteristicTypeSupported)
                target.StudentCharacteristicType = source.StudentCharacteristicType;
            else
                targetSynchSupport.IsStudentCharacteristicTypeSupported = false;

            // Map inherited lists

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentCharacteristicDescriptorSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsEffectiveBeginDateSupported { get; set; }
        bool IsEffectiveEndDateSupported { get; set; }
        bool IsNamespaceSupported { get; set; }
        bool IsPriorDescriptorIdSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
        bool IsStudentCharacteristicTypeSupported { get; set; }
    }
 
}
// Aggregate: StudentCharacteristicType

namespace EdFi.Ods.Entities.Common //.StudentCharacteristicTypeAggregate
{ 
    public static class StudentCharacteristicTypeMapper 
    {
        public static bool SynchronizeTo(this IStudentCharacteristicType source, IStudentCharacteristicType target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentCharacteristicTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.StudentCharacteristicTypeId != target.StudentCharacteristicTypeId)
            {
                source.StudentCharacteristicTypeId = target.StudentCharacteristicTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStudentCharacteristicType source, IStudentCharacteristicType target, Action<IStudentCharacteristicType, IStudentCharacteristicType> onMapped)
        {
            var sourceSynchSupport = source as IStudentCharacteristicTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentCharacteristicTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.StudentCharacteristicTypeId = source.StudentCharacteristicTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentCharacteristicTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: StudentCohortAssociation

namespace EdFi.Ods.Entities.Common //.StudentCohortAssociationAggregate
{ 
    public static class StudentCohortAssociationMapper 
    {
        public static bool SynchronizeTo(this IStudentCohortAssociation source, IStudentCohortAssociation target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentCohortAssociationSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.BeginDate != target.BeginDate)
            {
                source.BeginDate = target.BeginDate;
            }
            if (source.CohortIdentifier != target.CohortIdentifier)
            {
                source.CohortIdentifier = target.CohortIdentifier;
            }
            if (source.EducationOrganizationId != target.EducationOrganizationId)
            {
                source.EducationOrganizationId = target.EducationOrganizationId;
            }
            if (source.StudentUniqueId != target.StudentUniqueId)
            {
                source.StudentUniqueId = target.StudentUniqueId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsEndDateSupported)
                && target.EndDate != source.EndDate)
            {
                target.EndDate = source.EndDate;
                isModified = true;
            }



            // Sync lists
            if (sourceSupport == null || sourceSupport.IsStudentCohortAssociationSectionsSupported)
                isModified |= source.StudentCohortAssociationSections.SynchronizeListTo(target.StudentCohortAssociationSections, child => child.StudentCohortAssociation = target,
                                sourceSupport == null ? null : sourceSupport.IsStudentCohortAssociationSectionIncluded);


            return isModified;
        }



        public static void MapTo(this IStudentCohortAssociation source, IStudentCohortAssociation target, Action<IStudentCohortAssociation, IStudentCohortAssociation> onMapped)
        {
            var sourceSynchSupport = source as IStudentCohortAssociationSynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentCohortAssociationSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.BeginDate = source.BeginDate;
            target.CohortIdentifier = source.CohortIdentifier;
            target.EducationOrganizationId = source.EducationOrganizationId;
            target.StudentUniqueId = source.StudentUniqueId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsEndDateSupported)
                target.EndDate = source.EndDate;
            else
                targetSynchSupport.IsEndDateSupported = false;

            // Map lists

            if (sourceSynchSupport.IsStudentCohortAssociationSectionsSupported)
            {    
                targetSynchSupport.IsStudentCohortAssociationSectionIncluded = sourceSynchSupport.IsStudentCohortAssociationSectionIncluded;
                source.StudentCohortAssociationSections.MapListTo(target.StudentCohortAssociationSections);
            }
            else
            {
                targetSynchSupport.IsStudentCohortAssociationSectionsSupported = false;
            }

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentCohortAssociationSynchronizationSourceSupport
    {
        bool IsEndDateSupported { get; set; }
        bool IsStudentCohortAssociationSectionsSupported { get; set; }
        Func<IStudentCohortAssociationSection, bool> IsStudentCohortAssociationSectionIncluded { get; set; }
    }
 
    public static class StudentCohortAssociationSectionMapper 
    {
        public static bool SynchronizeTo(this IStudentCohortAssociationSection source, IStudentCohortAssociationSection target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentCohortAssociationSectionSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.ClassPeriodName != target.ClassPeriodName)
            {
                source.ClassPeriodName = target.ClassPeriodName;
            }
            if (source.ClassroomIdentificationCode != target.ClassroomIdentificationCode)
            {
                source.ClassroomIdentificationCode = target.ClassroomIdentificationCode;
            }
            if (source.LocalCourseCode != target.LocalCourseCode)
            {
                source.LocalCourseCode = target.LocalCourseCode;
            }
            if (source.SchoolId != target.SchoolId)
            {
                source.SchoolId = target.SchoolId;
            }
            if (source.SchoolYear != target.SchoolYear)
            {
                source.SchoolYear = target.SchoolYear;
            }
            if (source.SequenceOfCourse != target.SequenceOfCourse)
            {
                source.SequenceOfCourse = target.SequenceOfCourse;
            }
            if (source.TermDescriptor != target.TermDescriptor)
            {
                source.TermDescriptor = target.TermDescriptor;
            }
            if (source.UniqueSectionCode != target.UniqueSectionCode)
            {
                source.UniqueSectionCode = target.UniqueSectionCode;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStudentCohortAssociationSection source, IStudentCohortAssociationSection target, Action<IStudentCohortAssociationSection, IStudentCohortAssociationSection> onMapped)
        {
            var sourceSynchSupport = source as IStudentCohortAssociationSectionSynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentCohortAssociationSectionSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.ClassPeriodName = source.ClassPeriodName;
            target.ClassroomIdentificationCode = source.ClassroomIdentificationCode;
            target.LocalCourseCode = source.LocalCourseCode;
            target.SchoolId = source.SchoolId;
            target.SchoolYear = source.SchoolYear;
            target.SequenceOfCourse = source.SequenceOfCourse;
            target.TermDescriptor = source.TermDescriptor;
            target.UniqueSectionCode = source.UniqueSectionCode;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentCohortAssociationSectionSynchronizationSourceSupport
    {
    }
 
}
// Aggregate: StudentCompetencyObjective

namespace EdFi.Ods.Entities.Common //.StudentCompetencyObjectiveAggregate
{ 
    public static class StudentCompetencyObjectiveMapper 
    {
        public static bool SynchronizeTo(this IStudentCompetencyObjective source, IStudentCompetencyObjective target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentCompetencyObjectiveSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.GradingPeriodBeginDate != target.GradingPeriodBeginDate)
            {
                source.GradingPeriodBeginDate = target.GradingPeriodBeginDate;
            }
            if (source.GradingPeriodDescriptor != target.GradingPeriodDescriptor)
            {
                source.GradingPeriodDescriptor = target.GradingPeriodDescriptor;
            }
            if (source.Objective != target.Objective)
            {
                source.Objective = target.Objective;
            }
            if (source.ObjectiveEducationOrganizationId != target.ObjectiveEducationOrganizationId)
            {
                source.ObjectiveEducationOrganizationId = target.ObjectiveEducationOrganizationId;
            }
            if (source.ObjectiveGradeLevelDescriptor != target.ObjectiveGradeLevelDescriptor)
            {
                source.ObjectiveGradeLevelDescriptor = target.ObjectiveGradeLevelDescriptor;
            }
            if (source.SchoolId != target.SchoolId)
            {
                source.SchoolId = target.SchoolId;
            }
            if (source.StudentUniqueId != target.StudentUniqueId)
            {
                source.StudentUniqueId = target.StudentUniqueId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsBeginDateSupported)
                && target.BeginDate != source.BeginDate)
            {
                target.BeginDate = source.BeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsClassPeriodNameSupported)
                && target.ClassPeriodName != source.ClassPeriodName)
            {
                target.ClassPeriodName = source.ClassPeriodName;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsClassroomIdentificationCodeSupported)
                && target.ClassroomIdentificationCode != source.ClassroomIdentificationCode)
            {
                target.ClassroomIdentificationCode = source.ClassroomIdentificationCode;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsCompetencyLevelDescriptorSupported)
                && target.CompetencyLevelDescriptor != source.CompetencyLevelDescriptor)
            {
                target.CompetencyLevelDescriptor = source.CompetencyLevelDescriptor;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDiagnosticStatementSupported)
                && target.DiagnosticStatement != source.DiagnosticStatement)
            {
                target.DiagnosticStatement = source.DiagnosticStatement;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEducationOrganizationIdSupported)
                && target.EducationOrganizationId != source.EducationOrganizationId)
            {
                target.EducationOrganizationId = source.EducationOrganizationId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsLocalCourseCodeSupported)
                && target.LocalCourseCode != source.LocalCourseCode)
            {
                target.LocalCourseCode = source.LocalCourseCode;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsProgramEducationOrganizationIdSupported)
                && target.ProgramEducationOrganizationId != source.ProgramEducationOrganizationId)
            {
                target.ProgramEducationOrganizationId = source.ProgramEducationOrganizationId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsProgramNameSupported)
                && target.ProgramName != source.ProgramName)
            {
                target.ProgramName = source.ProgramName;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsProgramTypeSupported)
                && target.ProgramType != source.ProgramType)
            {
                target.ProgramType = source.ProgramType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsSchoolYearSupported)
                && target.SchoolYear != source.SchoolYear)
            {
                target.SchoolYear = source.SchoolYear;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsSequenceOfCourseSupported)
                && target.SequenceOfCourse != source.SequenceOfCourse)
            {
                target.SequenceOfCourse = source.SequenceOfCourse;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsTermDescriptorSupported)
                && target.TermDescriptor != source.TermDescriptor)
            {
                target.TermDescriptor = source.TermDescriptor;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsUniqueSectionCodeSupported)
                && target.UniqueSectionCode != source.UniqueSectionCode)
            {
                target.UniqueSectionCode = source.UniqueSectionCode;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStudentCompetencyObjective source, IStudentCompetencyObjective target, Action<IStudentCompetencyObjective, IStudentCompetencyObjective> onMapped)
        {
            var sourceSynchSupport = source as IStudentCompetencyObjectiveSynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentCompetencyObjectiveSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.GradingPeriodBeginDate = source.GradingPeriodBeginDate;
            target.GradingPeriodDescriptor = source.GradingPeriodDescriptor;
            target.Objective = source.Objective;
            target.ObjectiveEducationOrganizationId = source.ObjectiveEducationOrganizationId;
            target.ObjectiveGradeLevelDescriptor = source.ObjectiveGradeLevelDescriptor;
            target.SchoolId = source.SchoolId;
            target.StudentUniqueId = source.StudentUniqueId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsBeginDateSupported)
                target.BeginDate = source.BeginDate;
            else
                targetSynchSupport.IsBeginDateSupported = false;

            if (sourceSynchSupport.IsClassPeriodNameSupported)
                target.ClassPeriodName = source.ClassPeriodName;
            else
                targetSynchSupport.IsClassPeriodNameSupported = false;

            if (sourceSynchSupport.IsClassroomIdentificationCodeSupported)
                target.ClassroomIdentificationCode = source.ClassroomIdentificationCode;
            else
                targetSynchSupport.IsClassroomIdentificationCodeSupported = false;

            if (sourceSynchSupport.IsCompetencyLevelDescriptorSupported)
                target.CompetencyLevelDescriptor = source.CompetencyLevelDescriptor;
            else
                targetSynchSupport.IsCompetencyLevelDescriptorSupported = false;

            if (sourceSynchSupport.IsDiagnosticStatementSupported)
                target.DiagnosticStatement = source.DiagnosticStatement;
            else
                targetSynchSupport.IsDiagnosticStatementSupported = false;

            if (sourceSynchSupport.IsEducationOrganizationIdSupported)
                target.EducationOrganizationId = source.EducationOrganizationId;
            else
                targetSynchSupport.IsEducationOrganizationIdSupported = false;

            if (sourceSynchSupport.IsLocalCourseCodeSupported)
                target.LocalCourseCode = source.LocalCourseCode;
            else
                targetSynchSupport.IsLocalCourseCodeSupported = false;

            if (sourceSynchSupport.IsProgramEducationOrganizationIdSupported)
                target.ProgramEducationOrganizationId = source.ProgramEducationOrganizationId;
            else
                targetSynchSupport.IsProgramEducationOrganizationIdSupported = false;

            if (sourceSynchSupport.IsProgramNameSupported)
                target.ProgramName = source.ProgramName;
            else
                targetSynchSupport.IsProgramNameSupported = false;

            if (sourceSynchSupport.IsProgramTypeSupported)
                target.ProgramType = source.ProgramType;
            else
                targetSynchSupport.IsProgramTypeSupported = false;

            if (sourceSynchSupport.IsSchoolYearSupported)
                target.SchoolYear = source.SchoolYear;
            else
                targetSynchSupport.IsSchoolYearSupported = false;

            if (sourceSynchSupport.IsSequenceOfCourseSupported)
                target.SequenceOfCourse = source.SequenceOfCourse;
            else
                targetSynchSupport.IsSequenceOfCourseSupported = false;

            if (sourceSynchSupport.IsTermDescriptorSupported)
                target.TermDescriptor = source.TermDescriptor;
            else
                targetSynchSupport.IsTermDescriptorSupported = false;

            if (sourceSynchSupport.IsUniqueSectionCodeSupported)
                target.UniqueSectionCode = source.UniqueSectionCode;
            else
                targetSynchSupport.IsUniqueSectionCodeSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentCompetencyObjectiveSynchronizationSourceSupport
    {
        bool IsBeginDateSupported { get; set; }
        bool IsClassPeriodNameSupported { get; set; }
        bool IsClassroomIdentificationCodeSupported { get; set; }
        bool IsCompetencyLevelDescriptorSupported { get; set; }
        bool IsDiagnosticStatementSupported { get; set; }
        bool IsEducationOrganizationIdSupported { get; set; }
        bool IsLocalCourseCodeSupported { get; set; }
        bool IsProgramEducationOrganizationIdSupported { get; set; }
        bool IsProgramNameSupported { get; set; }
        bool IsProgramTypeSupported { get; set; }
        bool IsSchoolYearSupported { get; set; }
        bool IsSequenceOfCourseSupported { get; set; }
        bool IsTermDescriptorSupported { get; set; }
        bool IsUniqueSectionCodeSupported { get; set; }
    }
 
}
// Aggregate: StudentCTEProgramAssociation

namespace EdFi.Ods.Entities.Common //.StudentCTEProgramAssociationAggregate
{ 
    public static class StudentCTEProgramAssociationMapper 
    {
        public static bool SynchronizeTo(this IStudentCTEProgramAssociation source, IStudentCTEProgramAssociation target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentCTEProgramAssociationSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.BeginDate != target.BeginDate)
            {
                source.BeginDate = target.BeginDate;
            }
            if (source.EducationOrganizationId != target.EducationOrganizationId)
            {
                source.EducationOrganizationId = target.EducationOrganizationId;
            }
            if (source.ProgramEducationOrganizationId != target.ProgramEducationOrganizationId)
            {
                source.ProgramEducationOrganizationId = target.ProgramEducationOrganizationId;
            }
            if (source.ProgramName != target.ProgramName)
            {
                source.ProgramName = target.ProgramName;
            }
            if (source.ProgramType != target.ProgramType)
            {
                source.ProgramType = target.ProgramType;
            }
            if (source.StudentUniqueId != target.StudentUniqueId)
            {
                source.StudentUniqueId = target.StudentUniqueId;
            }

            // Copy inherited non-PK properties


            if ((sourceSupport == null || sourceSupport.IsEndDateSupported)
                && target.EndDate != source.EndDate)
            {
                target.EndDate = source.EndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsReasonExitedDescriptorSupported)
                && target.ReasonExitedDescriptor != source.ReasonExitedDescriptor)
            {
                target.ReasonExitedDescriptor = source.ReasonExitedDescriptor;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsServedOutsideOfRegularSessionSupported)
                && target.ServedOutsideOfRegularSession != source.ServedOutsideOfRegularSession)
            {
                target.ServedOutsideOfRegularSession = source.ServedOutsideOfRegularSession;
                isModified = true;
            }

            // Copy non-PK properties

            // Synch inherited lists
            if (sourceSupport == null || sourceSupport.IsStudentProgramAssociationServicesSupported)
                isModified |= source.StudentProgramAssociationServices.SynchronizeListTo(target.StudentProgramAssociationServices, child => child.StudentProgramAssociation = target,
                                sourceSupport == null ? null : sourceSupport.IsStudentProgramAssociationServiceIncluded);



            // Sync lists
            if (sourceSupport == null || sourceSupport.IsStudentCTEProgramAssociationCTEProgramsSupported)
                isModified |= source.StudentCTEProgramAssociationCTEPrograms.SynchronizeListTo(target.StudentCTEProgramAssociationCTEPrograms, child => child.StudentCTEProgramAssociation = target,
                                sourceSupport == null ? null : sourceSupport.IsStudentCTEProgramAssociationCTEProgramIncluded);


            return isModified;
        }



        internal static void MapDerivedTo(this IStudentCTEProgramAssociation source, IStudentCTEProgramAssociation target, Action<IStudentCTEProgramAssociation, IStudentCTEProgramAssociation> onMapped)
        {
            var sourceSynchSupport = source as IStudentCTEProgramAssociationSynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentCTEProgramAssociationSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.BeginDate = source.BeginDate;
            target.EducationOrganizationId = source.EducationOrganizationId;
            target.ProgramEducationOrganizationId = source.ProgramEducationOrganizationId;
            target.ProgramName = source.ProgramName;
            target.ProgramType = source.ProgramType;
            target.StudentUniqueId = source.StudentUniqueId;

            // Copy inherited non-PK properties

            if (sourceSynchSupport.IsEndDateSupported)
                target.EndDate = source.EndDate;
            else
                targetSynchSupport.IsEndDateSupported = false;

            if (sourceSynchSupport.IsReasonExitedDescriptorSupported)
                target.ReasonExitedDescriptor = source.ReasonExitedDescriptor;
            else
                targetSynchSupport.IsReasonExitedDescriptorSupported = false;

            if (sourceSynchSupport.IsServedOutsideOfRegularSessionSupported)
                target.ServedOutsideOfRegularSession = source.ServedOutsideOfRegularSession;
            else
                targetSynchSupport.IsServedOutsideOfRegularSessionSupported = false;

            // Copy non-PK properties

            // Map inherited lists

            if (sourceSynchSupport.IsStudentProgramAssociationServicesSupported)
            {
                targetSynchSupport.IsStudentProgramAssociationServiceIncluded = sourceSynchSupport.IsStudentProgramAssociationServiceIncluded;
                source.StudentProgramAssociationServices.MapListTo(target.StudentProgramAssociationServices);
            }
            else
            {
                targetSynchSupport.IsStudentProgramAssociationServicesSupported = false;
            }

            // Map lists

            if (sourceSynchSupport.IsStudentCTEProgramAssociationCTEProgramsSupported)
            {    
                targetSynchSupport.IsStudentCTEProgramAssociationCTEProgramIncluded = sourceSynchSupport.IsStudentCTEProgramAssociationCTEProgramIncluded;
                source.StudentCTEProgramAssociationCTEPrograms.MapListTo(target.StudentCTEProgramAssociationCTEPrograms);
            }
            else
            {
                targetSynchSupport.IsStudentCTEProgramAssociationCTEProgramsSupported = false;
            }

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentCTEProgramAssociationSynchronizationSourceSupport
    {
        bool IsEndDateSupported { get; set; }
        bool IsReasonExitedDescriptorSupported { get; set; }
        bool IsServedOutsideOfRegularSessionSupported { get; set; }
        bool IsStudentCTEProgramAssociationCTEProgramsSupported { get; set; }
        bool IsStudentProgramAssociationServicesSupported { get; set; }
        Func<IStudentCTEProgramAssociationCTEProgram, bool> IsStudentCTEProgramAssociationCTEProgramIncluded { get; set; }
        Func<IStudentProgramAssociationService, bool> IsStudentProgramAssociationServiceIncluded { get; set; }
    }
 
    public static class StudentCTEProgramAssociationCTEProgramMapper 
    {
        public static bool SynchronizeTo(this IStudentCTEProgramAssociationCTEProgram source, IStudentCTEProgramAssociationCTEProgram target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentCTEProgramAssociationCTEProgramSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.CareerPathwayType != target.CareerPathwayType)
            {
                source.CareerPathwayType = target.CareerPathwayType;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCIPCodeSupported)
                && target.CIPCode != source.CIPCode)
            {
                target.CIPCode = source.CIPCode;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsCTEProgramCompletionIndicatorSupported)
                && target.CTEProgramCompletionIndicator != source.CTEProgramCompletionIndicator)
            {
                target.CTEProgramCompletionIndicator = source.CTEProgramCompletionIndicator;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPrimaryCTEProgramIndicatorSupported)
                && target.PrimaryCTEProgramIndicator != source.PrimaryCTEProgramIndicator)
            {
                target.PrimaryCTEProgramIndicator = source.PrimaryCTEProgramIndicator;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStudentCTEProgramAssociationCTEProgram source, IStudentCTEProgramAssociationCTEProgram target, Action<IStudentCTEProgramAssociationCTEProgram, IStudentCTEProgramAssociationCTEProgram> onMapped)
        {
            var sourceSynchSupport = source as IStudentCTEProgramAssociationCTEProgramSynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentCTEProgramAssociationCTEProgramSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.CareerPathwayType = source.CareerPathwayType;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCIPCodeSupported)
                target.CIPCode = source.CIPCode;
            else
                targetSynchSupport.IsCIPCodeSupported = false;

            if (sourceSynchSupport.IsCTEProgramCompletionIndicatorSupported)
                target.CTEProgramCompletionIndicator = source.CTEProgramCompletionIndicator;
            else
                targetSynchSupport.IsCTEProgramCompletionIndicatorSupported = false;

            if (sourceSynchSupport.IsPrimaryCTEProgramIndicatorSupported)
                target.PrimaryCTEProgramIndicator = source.PrimaryCTEProgramIndicator;
            else
                targetSynchSupport.IsPrimaryCTEProgramIndicatorSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentCTEProgramAssociationCTEProgramSynchronizationSourceSupport
    {
        bool IsCIPCodeSupported { get; set; }
        bool IsCTEProgramCompletionIndicatorSupported { get; set; }
        bool IsPrimaryCTEProgramIndicatorSupported { get; set; }
    }
 
}
// Aggregate: StudentDisciplineIncidentAssociation

namespace EdFi.Ods.Entities.Common //.StudentDisciplineIncidentAssociationAggregate
{ 
    public static class StudentDisciplineIncidentAssociationMapper 
    {
        public static bool SynchronizeTo(this IStudentDisciplineIncidentAssociation source, IStudentDisciplineIncidentAssociation target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentDisciplineIncidentAssociationSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.IncidentIdentifier != target.IncidentIdentifier)
            {
                source.IncidentIdentifier = target.IncidentIdentifier;
            }
            if (source.SchoolId != target.SchoolId)
            {
                source.SchoolId = target.SchoolId;
            }
            if (source.StudentUniqueId != target.StudentUniqueId)
            {
                source.StudentUniqueId = target.StudentUniqueId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsStudentParticipationCodeTypeSupported)
                && target.StudentParticipationCodeType != source.StudentParticipationCodeType)
            {
                target.StudentParticipationCodeType = source.StudentParticipationCodeType;
                isModified = true;
            }



            // Sync lists
            if (sourceSupport == null || sourceSupport.IsStudentDisciplineIncidentAssociationBehaviorsSupported)
                isModified |= source.StudentDisciplineIncidentAssociationBehaviors.SynchronizeListTo(target.StudentDisciplineIncidentAssociationBehaviors, child => child.StudentDisciplineIncidentAssociation = target,
                                sourceSupport == null ? null : sourceSupport.IsStudentDisciplineIncidentAssociationBehaviorIncluded);


            return isModified;
        }



        public static void MapTo(this IStudentDisciplineIncidentAssociation source, IStudentDisciplineIncidentAssociation target, Action<IStudentDisciplineIncidentAssociation, IStudentDisciplineIncidentAssociation> onMapped)
        {
            var sourceSynchSupport = source as IStudentDisciplineIncidentAssociationSynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentDisciplineIncidentAssociationSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.IncidentIdentifier = source.IncidentIdentifier;
            target.SchoolId = source.SchoolId;
            target.StudentUniqueId = source.StudentUniqueId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsStudentParticipationCodeTypeSupported)
                target.StudentParticipationCodeType = source.StudentParticipationCodeType;
            else
                targetSynchSupport.IsStudentParticipationCodeTypeSupported = false;

            // Map lists

            if (sourceSynchSupport.IsStudentDisciplineIncidentAssociationBehaviorsSupported)
            {    
                targetSynchSupport.IsStudentDisciplineIncidentAssociationBehaviorIncluded = sourceSynchSupport.IsStudentDisciplineIncidentAssociationBehaviorIncluded;
                source.StudentDisciplineIncidentAssociationBehaviors.MapListTo(target.StudentDisciplineIncidentAssociationBehaviors);
            }
            else
            {
                targetSynchSupport.IsStudentDisciplineIncidentAssociationBehaviorsSupported = false;
            }

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentDisciplineIncidentAssociationSynchronizationSourceSupport
    {
        bool IsStudentDisciplineIncidentAssociationBehaviorsSupported { get; set; }
        bool IsStudentParticipationCodeTypeSupported { get; set; }
        Func<IStudentDisciplineIncidentAssociationBehavior, bool> IsStudentDisciplineIncidentAssociationBehaviorIncluded { get; set; }
    }
 
    public static class StudentDisciplineIncidentAssociationBehaviorMapper 
    {
        public static bool SynchronizeTo(this IStudentDisciplineIncidentAssociationBehavior source, IStudentDisciplineIncidentAssociationBehavior target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentDisciplineIncidentAssociationBehaviorSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.BehaviorDescriptor != target.BehaviorDescriptor)
            {
                source.BehaviorDescriptor = target.BehaviorDescriptor;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsBehaviorDetailedDescriptionSupported)
                && target.BehaviorDetailedDescription != source.BehaviorDetailedDescription)
            {
                target.BehaviorDetailedDescription = source.BehaviorDetailedDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStudentDisciplineIncidentAssociationBehavior source, IStudentDisciplineIncidentAssociationBehavior target, Action<IStudentDisciplineIncidentAssociationBehavior, IStudentDisciplineIncidentAssociationBehavior> onMapped)
        {
            var sourceSynchSupport = source as IStudentDisciplineIncidentAssociationBehaviorSynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentDisciplineIncidentAssociationBehaviorSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.BehaviorDescriptor = source.BehaviorDescriptor;

            // Copy non-PK properties

            if (sourceSynchSupport.IsBehaviorDetailedDescriptionSupported)
                target.BehaviorDetailedDescription = source.BehaviorDetailedDescription;
            else
                targetSynchSupport.IsBehaviorDetailedDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentDisciplineIncidentAssociationBehaviorSynchronizationSourceSupport
    {
        bool IsBehaviorDetailedDescriptionSupported { get; set; }
    }
 
}
// Aggregate: StudentEducationOrganizationAssociation

namespace EdFi.Ods.Entities.Common //.StudentEducationOrganizationAssociationAggregate
{ 
    public static class StudentEducationOrganizationAssociationMapper 
    {
        public static bool SynchronizeTo(this IStudentEducationOrganizationAssociation source, IStudentEducationOrganizationAssociation target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentEducationOrganizationAssociationSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.EducationOrganizationId != target.EducationOrganizationId)
            {
                source.EducationOrganizationId = target.EducationOrganizationId;
            }
            if (source.ResponsibilityDescriptor != target.ResponsibilityDescriptor)
            {
                source.ResponsibilityDescriptor = target.ResponsibilityDescriptor;
            }
            if (source.StudentUniqueId != target.StudentUniqueId)
            {
                source.StudentUniqueId = target.StudentUniqueId;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStudentEducationOrganizationAssociation source, IStudentEducationOrganizationAssociation target, Action<IStudentEducationOrganizationAssociation, IStudentEducationOrganizationAssociation> onMapped)
        {
            var sourceSynchSupport = source as IStudentEducationOrganizationAssociationSynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentEducationOrganizationAssociationSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.EducationOrganizationId = source.EducationOrganizationId;
            target.ResponsibilityDescriptor = source.ResponsibilityDescriptor;
            target.StudentUniqueId = source.StudentUniqueId;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentEducationOrganizationAssociationSynchronizationSourceSupport
    {
    }
 
}
// Aggregate: StudentGradebookEntry

namespace EdFi.Ods.Entities.Common //.StudentGradebookEntryAggregate
{ 
    public static class StudentGradebookEntryMapper 
    {
        public static bool SynchronizeTo(this IStudentGradebookEntry source, IStudentGradebookEntry target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentGradebookEntrySynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.BeginDate != target.BeginDate)
            {
                source.BeginDate = target.BeginDate;
            }
            if (source.ClassPeriodName != target.ClassPeriodName)
            {
                source.ClassPeriodName = target.ClassPeriodName;
            }
            if (source.ClassroomIdentificationCode != target.ClassroomIdentificationCode)
            {
                source.ClassroomIdentificationCode = target.ClassroomIdentificationCode;
            }
            if (source.DateAssigned != target.DateAssigned)
            {
                source.DateAssigned = target.DateAssigned;
            }
            if (source.GradebookEntryTitle != target.GradebookEntryTitle)
            {
                source.GradebookEntryTitle = target.GradebookEntryTitle;
            }
            if (source.LocalCourseCode != target.LocalCourseCode)
            {
                source.LocalCourseCode = target.LocalCourseCode;
            }
            if (source.SchoolId != target.SchoolId)
            {
                source.SchoolId = target.SchoolId;
            }
            if (source.SchoolYear != target.SchoolYear)
            {
                source.SchoolYear = target.SchoolYear;
            }
            if (source.SequenceOfCourse != target.SequenceOfCourse)
            {
                source.SequenceOfCourse = target.SequenceOfCourse;
            }
            if (source.StudentUniqueId != target.StudentUniqueId)
            {
                source.StudentUniqueId = target.StudentUniqueId;
            }
            if (source.TermDescriptor != target.TermDescriptor)
            {
                source.TermDescriptor = target.TermDescriptor;
            }
            if (source.UniqueSectionCode != target.UniqueSectionCode)
            {
                source.UniqueSectionCode = target.UniqueSectionCode;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCompetencyLevelDescriptorSupported)
                && target.CompetencyLevelDescriptor != source.CompetencyLevelDescriptor)
            {
                target.CompetencyLevelDescriptor = source.CompetencyLevelDescriptor;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDateFulfilledSupported)
                && target.DateFulfilled != source.DateFulfilled)
            {
                target.DateFulfilled = source.DateFulfilled;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDiagnosticStatementSupported)
                && target.DiagnosticStatement != source.DiagnosticStatement)
            {
                target.DiagnosticStatement = source.DiagnosticStatement;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsLetterGradeEarnedSupported)
                && target.LetterGradeEarned != source.LetterGradeEarned)
            {
                target.LetterGradeEarned = source.LetterGradeEarned;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNumericGradeEarnedSupported)
                && target.NumericGradeEarned != source.NumericGradeEarned)
            {
                target.NumericGradeEarned = source.NumericGradeEarned;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStudentGradebookEntry source, IStudentGradebookEntry target, Action<IStudentGradebookEntry, IStudentGradebookEntry> onMapped)
        {
            var sourceSynchSupport = source as IStudentGradebookEntrySynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentGradebookEntrySynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.BeginDate = source.BeginDate;
            target.ClassPeriodName = source.ClassPeriodName;
            target.ClassroomIdentificationCode = source.ClassroomIdentificationCode;
            target.DateAssigned = source.DateAssigned;
            target.GradebookEntryTitle = source.GradebookEntryTitle;
            target.LocalCourseCode = source.LocalCourseCode;
            target.SchoolId = source.SchoolId;
            target.SchoolYear = source.SchoolYear;
            target.SequenceOfCourse = source.SequenceOfCourse;
            target.StudentUniqueId = source.StudentUniqueId;
            target.TermDescriptor = source.TermDescriptor;
            target.UniqueSectionCode = source.UniqueSectionCode;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCompetencyLevelDescriptorSupported)
                target.CompetencyLevelDescriptor = source.CompetencyLevelDescriptor;
            else
                targetSynchSupport.IsCompetencyLevelDescriptorSupported = false;

            if (sourceSynchSupport.IsDateFulfilledSupported)
                target.DateFulfilled = source.DateFulfilled;
            else
                targetSynchSupport.IsDateFulfilledSupported = false;

            if (sourceSynchSupport.IsDiagnosticStatementSupported)
                target.DiagnosticStatement = source.DiagnosticStatement;
            else
                targetSynchSupport.IsDiagnosticStatementSupported = false;

            if (sourceSynchSupport.IsLetterGradeEarnedSupported)
                target.LetterGradeEarned = source.LetterGradeEarned;
            else
                targetSynchSupport.IsLetterGradeEarnedSupported = false;

            if (sourceSynchSupport.IsNumericGradeEarnedSupported)
                target.NumericGradeEarned = source.NumericGradeEarned;
            else
                targetSynchSupport.IsNumericGradeEarnedSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentGradebookEntrySynchronizationSourceSupport
    {
        bool IsCompetencyLevelDescriptorSupported { get; set; }
        bool IsDateFulfilledSupported { get; set; }
        bool IsDiagnosticStatementSupported { get; set; }
        bool IsLetterGradeEarnedSupported { get; set; }
        bool IsNumericGradeEarnedSupported { get; set; }
    }
 
}
// Aggregate: StudentIdentificationSystemDescriptor

namespace EdFi.Ods.Entities.Common //.StudentIdentificationSystemDescriptorAggregate
{ 
    public static class StudentIdentificationSystemDescriptorMapper 
    {
        public static bool SynchronizeTo(this IStudentIdentificationSystemDescriptor source, IStudentIdentificationSystemDescriptor target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentIdentificationSystemDescriptorSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.StudentIdentificationSystemDescriptorId != target.StudentIdentificationSystemDescriptorId)
            {
                source.StudentIdentificationSystemDescriptorId = target.StudentIdentificationSystemDescriptorId;
            }

            // Copy inherited non-PK properties


            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveBeginDateSupported)
                && target.EffectiveBeginDate != source.EffectiveBeginDate)
            {
                target.EffectiveBeginDate = source.EffectiveBeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveEndDateSupported)
                && target.EffectiveEndDate != source.EffectiveEndDate)
            {
                target.EffectiveEndDate = source.EffectiveEndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNamespaceSupported)
                && target.Namespace != source.Namespace)
            {
                target.Namespace = source.Namespace;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPriorDescriptorIdSupported)
                && target.PriorDescriptorId != source.PriorDescriptorId)
            {
                target.PriorDescriptorId = source.PriorDescriptorId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsStudentIdentificationSystemTypeSupported)
                && target.StudentIdentificationSystemType != source.StudentIdentificationSystemType)
            {
                target.StudentIdentificationSystemType = source.StudentIdentificationSystemType;
                isModified = true;
            }

            // Synch inherited lists


            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStudentIdentificationSystemDescriptor source, IStudentIdentificationSystemDescriptor target, Action<IStudentIdentificationSystemDescriptor, IStudentIdentificationSystemDescriptor> onMapped)
        {
            var sourceSynchSupport = source as IStudentIdentificationSystemDescriptorSynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentIdentificationSystemDescriptorSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.StudentIdentificationSystemDescriptorId = source.StudentIdentificationSystemDescriptorId;

            // Copy inherited non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsEffectiveBeginDateSupported)
                target.EffectiveBeginDate = source.EffectiveBeginDate;
            else
                targetSynchSupport.IsEffectiveBeginDateSupported = false;

            if (sourceSynchSupport.IsEffectiveEndDateSupported)
                target.EffectiveEndDate = source.EffectiveEndDate;
            else
                targetSynchSupport.IsEffectiveEndDateSupported = false;

            if (sourceSynchSupport.IsNamespaceSupported)
                target.Namespace = source.Namespace;
            else
                targetSynchSupport.IsNamespaceSupported = false;

            if (sourceSynchSupport.IsPriorDescriptorIdSupported)
                target.PriorDescriptorId = source.PriorDescriptorId;
            else
                targetSynchSupport.IsPriorDescriptorIdSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Copy non-PK properties

            if (sourceSynchSupport.IsStudentIdentificationSystemTypeSupported)
                target.StudentIdentificationSystemType = source.StudentIdentificationSystemType;
            else
                targetSynchSupport.IsStudentIdentificationSystemTypeSupported = false;

            // Map inherited lists

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentIdentificationSystemDescriptorSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsEffectiveBeginDateSupported { get; set; }
        bool IsEffectiveEndDateSupported { get; set; }
        bool IsNamespaceSupported { get; set; }
        bool IsPriorDescriptorIdSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
        bool IsStudentIdentificationSystemTypeSupported { get; set; }
    }
 
}
// Aggregate: StudentIdentificationSystemType

namespace EdFi.Ods.Entities.Common //.StudentIdentificationSystemTypeAggregate
{ 
    public static class StudentIdentificationSystemTypeMapper 
    {
        public static bool SynchronizeTo(this IStudentIdentificationSystemType source, IStudentIdentificationSystemType target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentIdentificationSystemTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.StudentIdentificationSystemTypeId != target.StudentIdentificationSystemTypeId)
            {
                source.StudentIdentificationSystemTypeId = target.StudentIdentificationSystemTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStudentIdentificationSystemType source, IStudentIdentificationSystemType target, Action<IStudentIdentificationSystemType, IStudentIdentificationSystemType> onMapped)
        {
            var sourceSynchSupport = source as IStudentIdentificationSystemTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentIdentificationSystemTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.StudentIdentificationSystemTypeId = source.StudentIdentificationSystemTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentIdentificationSystemTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: StudentInterventionAssociation

namespace EdFi.Ods.Entities.Common //.StudentInterventionAssociationAggregate
{ 
    public static class StudentInterventionAssociationMapper 
    {
        public static bool SynchronizeTo(this IStudentInterventionAssociation source, IStudentInterventionAssociation target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentInterventionAssociationSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.EducationOrganizationId != target.EducationOrganizationId)
            {
                source.EducationOrganizationId = target.EducationOrganizationId;
            }
            if (source.InterventionIdentificationCode != target.InterventionIdentificationCode)
            {
                source.InterventionIdentificationCode = target.InterventionIdentificationCode;
            }
            if (source.StudentUniqueId != target.StudentUniqueId)
            {
                source.StudentUniqueId = target.StudentUniqueId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCohortEducationOrganizationIdSupported)
                && target.CohortEducationOrganizationId != source.CohortEducationOrganizationId)
            {
                target.CohortEducationOrganizationId = source.CohortEducationOrganizationId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsCohortIdentifierSupported)
                && target.CohortIdentifier != source.CohortIdentifier)
            {
                target.CohortIdentifier = source.CohortIdentifier;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDiagnosticStatementSupported)
                && target.DiagnosticStatement != source.DiagnosticStatement)
            {
                target.DiagnosticStatement = source.DiagnosticStatement;
                isModified = true;
            }



            // Sync lists
            if (sourceSupport == null || sourceSupport.IsStudentInterventionAssociationInterventionEffectivenessesSupported)
                isModified |= source.StudentInterventionAssociationInterventionEffectivenesses.SynchronizeListTo(target.StudentInterventionAssociationInterventionEffectivenesses, child => child.StudentInterventionAssociation = target,
                                sourceSupport == null ? null : sourceSupport.IsStudentInterventionAssociationInterventionEffectivenessIncluded);


            return isModified;
        }



        public static void MapTo(this IStudentInterventionAssociation source, IStudentInterventionAssociation target, Action<IStudentInterventionAssociation, IStudentInterventionAssociation> onMapped)
        {
            var sourceSynchSupport = source as IStudentInterventionAssociationSynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentInterventionAssociationSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.EducationOrganizationId = source.EducationOrganizationId;
            target.InterventionIdentificationCode = source.InterventionIdentificationCode;
            target.StudentUniqueId = source.StudentUniqueId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCohortEducationOrganizationIdSupported)
                target.CohortEducationOrganizationId = source.CohortEducationOrganizationId;
            else
                targetSynchSupport.IsCohortEducationOrganizationIdSupported = false;

            if (sourceSynchSupport.IsCohortIdentifierSupported)
                target.CohortIdentifier = source.CohortIdentifier;
            else
                targetSynchSupport.IsCohortIdentifierSupported = false;

            if (sourceSynchSupport.IsDiagnosticStatementSupported)
                target.DiagnosticStatement = source.DiagnosticStatement;
            else
                targetSynchSupport.IsDiagnosticStatementSupported = false;

            // Map lists

            if (sourceSynchSupport.IsStudentInterventionAssociationInterventionEffectivenessesSupported)
            {    
                targetSynchSupport.IsStudentInterventionAssociationInterventionEffectivenessIncluded = sourceSynchSupport.IsStudentInterventionAssociationInterventionEffectivenessIncluded;
                source.StudentInterventionAssociationInterventionEffectivenesses.MapListTo(target.StudentInterventionAssociationInterventionEffectivenesses);
            }
            else
            {
                targetSynchSupport.IsStudentInterventionAssociationInterventionEffectivenessesSupported = false;
            }

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentInterventionAssociationSynchronizationSourceSupport
    {
        bool IsCohortEducationOrganizationIdSupported { get; set; }
        bool IsCohortIdentifierSupported { get; set; }
        bool IsDiagnosticStatementSupported { get; set; }
        bool IsStudentInterventionAssociationInterventionEffectivenessesSupported { get; set; }
        Func<IStudentInterventionAssociationInterventionEffectiveness, bool> IsStudentInterventionAssociationInterventionEffectivenessIncluded { get; set; }
    }
 
    public static class StudentInterventionAssociationInterventionEffectivenessMapper 
    {
        public static bool SynchronizeTo(this IStudentInterventionAssociationInterventionEffectiveness source, IStudentInterventionAssociationInterventionEffectiveness target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentInterventionAssociationInterventionEffectivenessSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.DiagnosisDescriptor != target.DiagnosisDescriptor)
            {
                source.DiagnosisDescriptor = target.DiagnosisDescriptor;
            }
            if (source.GradeLevelDescriptor != target.GradeLevelDescriptor)
            {
                source.GradeLevelDescriptor = target.GradeLevelDescriptor;
            }
            if (source.PopulationServedType != target.PopulationServedType)
            {
                source.PopulationServedType = target.PopulationServedType;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsImprovementIndexSupported)
                && target.ImprovementIndex != source.ImprovementIndex)
            {
                target.ImprovementIndex = source.ImprovementIndex;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsInterventionEffectivenessRatingTypeSupported)
                && target.InterventionEffectivenessRatingType != source.InterventionEffectivenessRatingType)
            {
                target.InterventionEffectivenessRatingType = source.InterventionEffectivenessRatingType;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStudentInterventionAssociationInterventionEffectiveness source, IStudentInterventionAssociationInterventionEffectiveness target, Action<IStudentInterventionAssociationInterventionEffectiveness, IStudentInterventionAssociationInterventionEffectiveness> onMapped)
        {
            var sourceSynchSupport = source as IStudentInterventionAssociationInterventionEffectivenessSynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentInterventionAssociationInterventionEffectivenessSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.DiagnosisDescriptor = source.DiagnosisDescriptor;
            target.GradeLevelDescriptor = source.GradeLevelDescriptor;
            target.PopulationServedType = source.PopulationServedType;

            // Copy non-PK properties

            if (sourceSynchSupport.IsImprovementIndexSupported)
                target.ImprovementIndex = source.ImprovementIndex;
            else
                targetSynchSupport.IsImprovementIndexSupported = false;

            if (sourceSynchSupport.IsInterventionEffectivenessRatingTypeSupported)
                target.InterventionEffectivenessRatingType = source.InterventionEffectivenessRatingType;
            else
                targetSynchSupport.IsInterventionEffectivenessRatingTypeSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentInterventionAssociationInterventionEffectivenessSynchronizationSourceSupport
    {
        bool IsImprovementIndexSupported { get; set; }
        bool IsInterventionEffectivenessRatingTypeSupported { get; set; }
    }
 
}
// Aggregate: StudentInterventionAttendanceEvent

namespace EdFi.Ods.Entities.Common //.StudentInterventionAttendanceEventAggregate
{ 
    public static class StudentInterventionAttendanceEventMapper 
    {
        public static bool SynchronizeTo(this IStudentInterventionAttendanceEvent source, IStudentInterventionAttendanceEvent target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentInterventionAttendanceEventSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AttendanceEventCategoryDescriptor != target.AttendanceEventCategoryDescriptor)
            {
                source.AttendanceEventCategoryDescriptor = target.AttendanceEventCategoryDescriptor;
            }
            if (source.EducationOrganizationId != target.EducationOrganizationId)
            {
                source.EducationOrganizationId = target.EducationOrganizationId;
            }
            if (source.EventDate != target.EventDate)
            {
                source.EventDate = target.EventDate;
            }
            if (source.InterventionIdentificationCode != target.InterventionIdentificationCode)
            {
                source.InterventionIdentificationCode = target.InterventionIdentificationCode;
            }
            if (source.StudentUniqueId != target.StudentUniqueId)
            {
                source.StudentUniqueId = target.StudentUniqueId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsAttendanceEventReasonSupported)
                && target.AttendanceEventReason != source.AttendanceEventReason)
            {
                target.AttendanceEventReason = source.AttendanceEventReason;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEducationalEnvironmentTypeSupported)
                && target.EducationalEnvironmentType != source.EducationalEnvironmentType)
            {
                target.EducationalEnvironmentType = source.EducationalEnvironmentType;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStudentInterventionAttendanceEvent source, IStudentInterventionAttendanceEvent target, Action<IStudentInterventionAttendanceEvent, IStudentInterventionAttendanceEvent> onMapped)
        {
            var sourceSynchSupport = source as IStudentInterventionAttendanceEventSynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentInterventionAttendanceEventSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.AttendanceEventCategoryDescriptor = source.AttendanceEventCategoryDescriptor;
            target.EducationOrganizationId = source.EducationOrganizationId;
            target.EventDate = source.EventDate;
            target.InterventionIdentificationCode = source.InterventionIdentificationCode;
            target.StudentUniqueId = source.StudentUniqueId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsAttendanceEventReasonSupported)
                target.AttendanceEventReason = source.AttendanceEventReason;
            else
                targetSynchSupport.IsAttendanceEventReasonSupported = false;

            if (sourceSynchSupport.IsEducationalEnvironmentTypeSupported)
                target.EducationalEnvironmentType = source.EducationalEnvironmentType;
            else
                targetSynchSupport.IsEducationalEnvironmentTypeSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentInterventionAttendanceEventSynchronizationSourceSupport
    {
        bool IsAttendanceEventReasonSupported { get; set; }
        bool IsEducationalEnvironmentTypeSupported { get; set; }
    }
 
}
// Aggregate: StudentLearningObjective

namespace EdFi.Ods.Entities.Common //.StudentLearningObjectiveAggregate
{ 
    public static class StudentLearningObjectiveMapper 
    {
        public static bool SynchronizeTo(this IStudentLearningObjective source, IStudentLearningObjective target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentLearningObjectiveSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.GradingPeriodBeginDate != target.GradingPeriodBeginDate)
            {
                source.GradingPeriodBeginDate = target.GradingPeriodBeginDate;
            }
            if (source.GradingPeriodDescriptor != target.GradingPeriodDescriptor)
            {
                source.GradingPeriodDescriptor = target.GradingPeriodDescriptor;
            }
            if (source.LearningObjectiveId != target.LearningObjectiveId)
            {
                source.LearningObjectiveId = target.LearningObjectiveId;
            }
            if (source.Namespace != target.Namespace)
            {
                source.Namespace = target.Namespace;
            }
            if (source.SchoolId != target.SchoolId)
            {
                source.SchoolId = target.SchoolId;
            }
            if (source.StudentUniqueId != target.StudentUniqueId)
            {
                source.StudentUniqueId = target.StudentUniqueId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsBeginDateSupported)
                && target.BeginDate != source.BeginDate)
            {
                target.BeginDate = source.BeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsClassPeriodNameSupported)
                && target.ClassPeriodName != source.ClassPeriodName)
            {
                target.ClassPeriodName = source.ClassPeriodName;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsClassroomIdentificationCodeSupported)
                && target.ClassroomIdentificationCode != source.ClassroomIdentificationCode)
            {
                target.ClassroomIdentificationCode = source.ClassroomIdentificationCode;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsCompetencyLevelDescriptorSupported)
                && target.CompetencyLevelDescriptor != source.CompetencyLevelDescriptor)
            {
                target.CompetencyLevelDescriptor = source.CompetencyLevelDescriptor;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDiagnosticStatementSupported)
                && target.DiagnosticStatement != source.DiagnosticStatement)
            {
                target.DiagnosticStatement = source.DiagnosticStatement;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEducationOrganizationIdSupported)
                && target.EducationOrganizationId != source.EducationOrganizationId)
            {
                target.EducationOrganizationId = source.EducationOrganizationId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsLocalCourseCodeSupported)
                && target.LocalCourseCode != source.LocalCourseCode)
            {
                target.LocalCourseCode = source.LocalCourseCode;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsProgramEducationOrganizationIdSupported)
                && target.ProgramEducationOrganizationId != source.ProgramEducationOrganizationId)
            {
                target.ProgramEducationOrganizationId = source.ProgramEducationOrganizationId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsProgramNameSupported)
                && target.ProgramName != source.ProgramName)
            {
                target.ProgramName = source.ProgramName;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsProgramTypeSupported)
                && target.ProgramType != source.ProgramType)
            {
                target.ProgramType = source.ProgramType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsSchoolYearSupported)
                && target.SchoolYear != source.SchoolYear)
            {
                target.SchoolYear = source.SchoolYear;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsSequenceOfCourseSupported)
                && target.SequenceOfCourse != source.SequenceOfCourse)
            {
                target.SequenceOfCourse = source.SequenceOfCourse;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsStudentSectionAssociationBeginDateSupported)
                && target.StudentSectionAssociationBeginDate != source.StudentSectionAssociationBeginDate)
            {
                target.StudentSectionAssociationBeginDate = source.StudentSectionAssociationBeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsTermDescriptorSupported)
                && target.TermDescriptor != source.TermDescriptor)
            {
                target.TermDescriptor = source.TermDescriptor;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsUniqueSectionCodeSupported)
                && target.UniqueSectionCode != source.UniqueSectionCode)
            {
                target.UniqueSectionCode = source.UniqueSectionCode;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStudentLearningObjective source, IStudentLearningObjective target, Action<IStudentLearningObjective, IStudentLearningObjective> onMapped)
        {
            var sourceSynchSupport = source as IStudentLearningObjectiveSynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentLearningObjectiveSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.GradingPeriodBeginDate = source.GradingPeriodBeginDate;
            target.GradingPeriodDescriptor = source.GradingPeriodDescriptor;
            target.LearningObjectiveId = source.LearningObjectiveId;
            target.Namespace = source.Namespace;
            target.SchoolId = source.SchoolId;
            target.StudentUniqueId = source.StudentUniqueId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsBeginDateSupported)
                target.BeginDate = source.BeginDate;
            else
                targetSynchSupport.IsBeginDateSupported = false;

            if (sourceSynchSupport.IsClassPeriodNameSupported)
                target.ClassPeriodName = source.ClassPeriodName;
            else
                targetSynchSupport.IsClassPeriodNameSupported = false;

            if (sourceSynchSupport.IsClassroomIdentificationCodeSupported)
                target.ClassroomIdentificationCode = source.ClassroomIdentificationCode;
            else
                targetSynchSupport.IsClassroomIdentificationCodeSupported = false;

            if (sourceSynchSupport.IsCompetencyLevelDescriptorSupported)
                target.CompetencyLevelDescriptor = source.CompetencyLevelDescriptor;
            else
                targetSynchSupport.IsCompetencyLevelDescriptorSupported = false;

            if (sourceSynchSupport.IsDiagnosticStatementSupported)
                target.DiagnosticStatement = source.DiagnosticStatement;
            else
                targetSynchSupport.IsDiagnosticStatementSupported = false;

            if (sourceSynchSupport.IsEducationOrganizationIdSupported)
                target.EducationOrganizationId = source.EducationOrganizationId;
            else
                targetSynchSupport.IsEducationOrganizationIdSupported = false;

            if (sourceSynchSupport.IsLocalCourseCodeSupported)
                target.LocalCourseCode = source.LocalCourseCode;
            else
                targetSynchSupport.IsLocalCourseCodeSupported = false;

            if (sourceSynchSupport.IsProgramEducationOrganizationIdSupported)
                target.ProgramEducationOrganizationId = source.ProgramEducationOrganizationId;
            else
                targetSynchSupport.IsProgramEducationOrganizationIdSupported = false;

            if (sourceSynchSupport.IsProgramNameSupported)
                target.ProgramName = source.ProgramName;
            else
                targetSynchSupport.IsProgramNameSupported = false;

            if (sourceSynchSupport.IsProgramTypeSupported)
                target.ProgramType = source.ProgramType;
            else
                targetSynchSupport.IsProgramTypeSupported = false;

            if (sourceSynchSupport.IsSchoolYearSupported)
                target.SchoolYear = source.SchoolYear;
            else
                targetSynchSupport.IsSchoolYearSupported = false;

            if (sourceSynchSupport.IsSequenceOfCourseSupported)
                target.SequenceOfCourse = source.SequenceOfCourse;
            else
                targetSynchSupport.IsSequenceOfCourseSupported = false;

            if (sourceSynchSupport.IsStudentSectionAssociationBeginDateSupported)
                target.StudentSectionAssociationBeginDate = source.StudentSectionAssociationBeginDate;
            else
                targetSynchSupport.IsStudentSectionAssociationBeginDateSupported = false;

            if (sourceSynchSupport.IsTermDescriptorSupported)
                target.TermDescriptor = source.TermDescriptor;
            else
                targetSynchSupport.IsTermDescriptorSupported = false;

            if (sourceSynchSupport.IsUniqueSectionCodeSupported)
                target.UniqueSectionCode = source.UniqueSectionCode;
            else
                targetSynchSupport.IsUniqueSectionCodeSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentLearningObjectiveSynchronizationSourceSupport
    {
        bool IsBeginDateSupported { get; set; }
        bool IsClassPeriodNameSupported { get; set; }
        bool IsClassroomIdentificationCodeSupported { get; set; }
        bool IsCompetencyLevelDescriptorSupported { get; set; }
        bool IsDiagnosticStatementSupported { get; set; }
        bool IsEducationOrganizationIdSupported { get; set; }
        bool IsLocalCourseCodeSupported { get; set; }
        bool IsProgramEducationOrganizationIdSupported { get; set; }
        bool IsProgramNameSupported { get; set; }
        bool IsProgramTypeSupported { get; set; }
        bool IsSchoolYearSupported { get; set; }
        bool IsSequenceOfCourseSupported { get; set; }
        bool IsStudentSectionAssociationBeginDateSupported { get; set; }
        bool IsTermDescriptorSupported { get; set; }
        bool IsUniqueSectionCodeSupported { get; set; }
    }
 
}
// Aggregate: StudentMigrantEducationProgramAssociation

namespace EdFi.Ods.Entities.Common //.StudentMigrantEducationProgramAssociationAggregate
{ 
    public static class StudentMigrantEducationProgramAssociationMapper 
    {
        public static bool SynchronizeTo(this IStudentMigrantEducationProgramAssociation source, IStudentMigrantEducationProgramAssociation target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentMigrantEducationProgramAssociationSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.BeginDate != target.BeginDate)
            {
                source.BeginDate = target.BeginDate;
            }
            if (source.EducationOrganizationId != target.EducationOrganizationId)
            {
                source.EducationOrganizationId = target.EducationOrganizationId;
            }
            if (source.ProgramEducationOrganizationId != target.ProgramEducationOrganizationId)
            {
                source.ProgramEducationOrganizationId = target.ProgramEducationOrganizationId;
            }
            if (source.ProgramName != target.ProgramName)
            {
                source.ProgramName = target.ProgramName;
            }
            if (source.ProgramType != target.ProgramType)
            {
                source.ProgramType = target.ProgramType;
            }
            if (source.StudentUniqueId != target.StudentUniqueId)
            {
                source.StudentUniqueId = target.StudentUniqueId;
            }

            // Copy inherited non-PK properties


            if ((sourceSupport == null || sourceSupport.IsEndDateSupported)
                && target.EndDate != source.EndDate)
            {
                target.EndDate = source.EndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsReasonExitedDescriptorSupported)
                && target.ReasonExitedDescriptor != source.ReasonExitedDescriptor)
            {
                target.ReasonExitedDescriptor = source.ReasonExitedDescriptor;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsServedOutsideOfRegularSessionSupported)
                && target.ServedOutsideOfRegularSession != source.ServedOutsideOfRegularSession)
            {
                target.ServedOutsideOfRegularSession = source.ServedOutsideOfRegularSession;
                isModified = true;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsContinuationOfServicesReasonDescriptorSupported)
                && target.ContinuationOfServicesReasonDescriptor != source.ContinuationOfServicesReasonDescriptor)
            {
                target.ContinuationOfServicesReasonDescriptor = source.ContinuationOfServicesReasonDescriptor;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsLastQualifyingMoveSupported)
                && target.LastQualifyingMove != source.LastQualifyingMove)
            {
                target.LastQualifyingMove = source.LastQualifyingMove;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPriorityForServicesSupported)
                && target.PriorityForServices != source.PriorityForServices)
            {
                target.PriorityForServices = source.PriorityForServices;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsUSInitialEntrySupported)
                && target.USInitialEntry != source.USInitialEntry)
            {
                target.USInitialEntry = source.USInitialEntry;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsUSInitialSchoolEntrySupported)
                && target.USInitialSchoolEntry != source.USInitialSchoolEntry)
            {
                target.USInitialSchoolEntry = source.USInitialSchoolEntry;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsUSMostRecentEntrySupported)
                && target.USMostRecentEntry != source.USMostRecentEntry)
            {
                target.USMostRecentEntry = source.USMostRecentEntry;
                isModified = true;
            }

            // Synch inherited lists
            if (sourceSupport == null || sourceSupport.IsStudentProgramAssociationServicesSupported)
                isModified |= source.StudentProgramAssociationServices.SynchronizeListTo(target.StudentProgramAssociationServices, child => child.StudentProgramAssociation = target,
                                sourceSupport == null ? null : sourceSupport.IsStudentProgramAssociationServiceIncluded);



            // Sync lists

            return isModified;
        }



        internal static void MapDerivedTo(this IStudentMigrantEducationProgramAssociation source, IStudentMigrantEducationProgramAssociation target, Action<IStudentMigrantEducationProgramAssociation, IStudentMigrantEducationProgramAssociation> onMapped)
        {
            var sourceSynchSupport = source as IStudentMigrantEducationProgramAssociationSynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentMigrantEducationProgramAssociationSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.BeginDate = source.BeginDate;
            target.EducationOrganizationId = source.EducationOrganizationId;
            target.ProgramEducationOrganizationId = source.ProgramEducationOrganizationId;
            target.ProgramName = source.ProgramName;
            target.ProgramType = source.ProgramType;
            target.StudentUniqueId = source.StudentUniqueId;

            // Copy inherited non-PK properties

            if (sourceSynchSupport.IsEndDateSupported)
                target.EndDate = source.EndDate;
            else
                targetSynchSupport.IsEndDateSupported = false;

            if (sourceSynchSupport.IsReasonExitedDescriptorSupported)
                target.ReasonExitedDescriptor = source.ReasonExitedDescriptor;
            else
                targetSynchSupport.IsReasonExitedDescriptorSupported = false;

            if (sourceSynchSupport.IsServedOutsideOfRegularSessionSupported)
                target.ServedOutsideOfRegularSession = source.ServedOutsideOfRegularSession;
            else
                targetSynchSupport.IsServedOutsideOfRegularSessionSupported = false;

            // Copy non-PK properties

            if (sourceSynchSupport.IsContinuationOfServicesReasonDescriptorSupported)
                target.ContinuationOfServicesReasonDescriptor = source.ContinuationOfServicesReasonDescriptor;
            else
                targetSynchSupport.IsContinuationOfServicesReasonDescriptorSupported = false;

            if (sourceSynchSupport.IsLastQualifyingMoveSupported)
                target.LastQualifyingMove = source.LastQualifyingMove;
            else
                targetSynchSupport.IsLastQualifyingMoveSupported = false;

            if (sourceSynchSupport.IsPriorityForServicesSupported)
                target.PriorityForServices = source.PriorityForServices;
            else
                targetSynchSupport.IsPriorityForServicesSupported = false;

            if (sourceSynchSupport.IsUSInitialEntrySupported)
                target.USInitialEntry = source.USInitialEntry;
            else
                targetSynchSupport.IsUSInitialEntrySupported = false;

            if (sourceSynchSupport.IsUSInitialSchoolEntrySupported)
                target.USInitialSchoolEntry = source.USInitialSchoolEntry;
            else
                targetSynchSupport.IsUSInitialSchoolEntrySupported = false;

            if (sourceSynchSupport.IsUSMostRecentEntrySupported)
                target.USMostRecentEntry = source.USMostRecentEntry;
            else
                targetSynchSupport.IsUSMostRecentEntrySupported = false;

            // Map inherited lists

            if (sourceSynchSupport.IsStudentProgramAssociationServicesSupported)
            {
                targetSynchSupport.IsStudentProgramAssociationServiceIncluded = sourceSynchSupport.IsStudentProgramAssociationServiceIncluded;
                source.StudentProgramAssociationServices.MapListTo(target.StudentProgramAssociationServices);
            }
            else
            {
                targetSynchSupport.IsStudentProgramAssociationServicesSupported = false;
            }

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentMigrantEducationProgramAssociationSynchronizationSourceSupport
    {
        bool IsContinuationOfServicesReasonDescriptorSupported { get; set; }
        bool IsEndDateSupported { get; set; }
        bool IsLastQualifyingMoveSupported { get; set; }
        bool IsPriorityForServicesSupported { get; set; }
        bool IsReasonExitedDescriptorSupported { get; set; }
        bool IsServedOutsideOfRegularSessionSupported { get; set; }
        bool IsStudentProgramAssociationServicesSupported { get; set; }
        bool IsUSInitialEntrySupported { get; set; }
        bool IsUSInitialSchoolEntrySupported { get; set; }
        bool IsUSMostRecentEntrySupported { get; set; }
        Func<IStudentProgramAssociationService, bool> IsStudentProgramAssociationServiceIncluded { get; set; }
    }
 
}
// Aggregate: StudentParentAssociation

namespace EdFi.Ods.Entities.Common //.StudentParentAssociationAggregate
{ 
    public static class StudentParentAssociationMapper 
    {
        public static bool SynchronizeTo(this IStudentParentAssociation source, IStudentParentAssociation target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentParentAssociationSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.ParentUniqueId != target.ParentUniqueId)
            {
                source.ParentUniqueId = target.ParentUniqueId;
            }
            if (source.StudentUniqueId != target.StudentUniqueId)
            {
                source.StudentUniqueId = target.StudentUniqueId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsContactPrioritySupported)
                && target.ContactPriority != source.ContactPriority)
            {
                target.ContactPriority = source.ContactPriority;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsContactRestrictionsSupported)
                && target.ContactRestrictions != source.ContactRestrictions)
            {
                target.ContactRestrictions = source.ContactRestrictions;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEmergencyContactStatusSupported)
                && target.EmergencyContactStatus != source.EmergencyContactStatus)
            {
                target.EmergencyContactStatus = source.EmergencyContactStatus;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsLivesWithSupported)
                && target.LivesWith != source.LivesWith)
            {
                target.LivesWith = source.LivesWith;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPrimaryContactStatusSupported)
                && target.PrimaryContactStatus != source.PrimaryContactStatus)
            {
                target.PrimaryContactStatus = source.PrimaryContactStatus;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsRelationTypeSupported)
                && target.RelationType != source.RelationType)
            {
                target.RelationType = source.RelationType;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStudentParentAssociation source, IStudentParentAssociation target, Action<IStudentParentAssociation, IStudentParentAssociation> onMapped)
        {
            var sourceSynchSupport = source as IStudentParentAssociationSynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentParentAssociationSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.ParentUniqueId = source.ParentUniqueId;
            target.StudentUniqueId = source.StudentUniqueId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsContactPrioritySupported)
                target.ContactPriority = source.ContactPriority;
            else
                targetSynchSupport.IsContactPrioritySupported = false;

            if (sourceSynchSupport.IsContactRestrictionsSupported)
                target.ContactRestrictions = source.ContactRestrictions;
            else
                targetSynchSupport.IsContactRestrictionsSupported = false;

            if (sourceSynchSupport.IsEmergencyContactStatusSupported)
                target.EmergencyContactStatus = source.EmergencyContactStatus;
            else
                targetSynchSupport.IsEmergencyContactStatusSupported = false;

            if (sourceSynchSupport.IsLivesWithSupported)
                target.LivesWith = source.LivesWith;
            else
                targetSynchSupport.IsLivesWithSupported = false;

            if (sourceSynchSupport.IsPrimaryContactStatusSupported)
                target.PrimaryContactStatus = source.PrimaryContactStatus;
            else
                targetSynchSupport.IsPrimaryContactStatusSupported = false;

            if (sourceSynchSupport.IsRelationTypeSupported)
                target.RelationType = source.RelationType;
            else
                targetSynchSupport.IsRelationTypeSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentParentAssociationSynchronizationSourceSupport
    {
        bool IsContactPrioritySupported { get; set; }
        bool IsContactRestrictionsSupported { get; set; }
        bool IsEmergencyContactStatusSupported { get; set; }
        bool IsLivesWithSupported { get; set; }
        bool IsPrimaryContactStatusSupported { get; set; }
        bool IsRelationTypeSupported { get; set; }
    }
 
}
// Aggregate: StudentParticipationCodeType

namespace EdFi.Ods.Entities.Common //.StudentParticipationCodeTypeAggregate
{ 
    public static class StudentParticipationCodeTypeMapper 
    {
        public static bool SynchronizeTo(this IStudentParticipationCodeType source, IStudentParticipationCodeType target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentParticipationCodeTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.StudentParticipationCodeTypeId != target.StudentParticipationCodeTypeId)
            {
                source.StudentParticipationCodeTypeId = target.StudentParticipationCodeTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStudentParticipationCodeType source, IStudentParticipationCodeType target, Action<IStudentParticipationCodeType, IStudentParticipationCodeType> onMapped)
        {
            var sourceSynchSupport = source as IStudentParticipationCodeTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentParticipationCodeTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.StudentParticipationCodeTypeId = source.StudentParticipationCodeTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentParticipationCodeTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: StudentProgramAssociation

namespace EdFi.Ods.Entities.Common //.StudentProgramAssociationAggregate
{ 
    public static class StudentProgramAssociationMapper 
    {
        public static bool SynchronizeTo(this IStudentProgramAssociation source, IStudentProgramAssociation target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentProgramAssociationSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.BeginDate != target.BeginDate)
            {
                source.BeginDate = target.BeginDate;
            }
            if (source.EducationOrganizationId != target.EducationOrganizationId)
            {
                source.EducationOrganizationId = target.EducationOrganizationId;
            }
            if (source.ProgramEducationOrganizationId != target.ProgramEducationOrganizationId)
            {
                source.ProgramEducationOrganizationId = target.ProgramEducationOrganizationId;
            }
            if (source.ProgramName != target.ProgramName)
            {
                source.ProgramName = target.ProgramName;
            }
            if (source.ProgramType != target.ProgramType)
            {
                source.ProgramType = target.ProgramType;
            }
            if (source.StudentUniqueId != target.StudentUniqueId)
            {
                source.StudentUniqueId = target.StudentUniqueId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsEndDateSupported)
                && target.EndDate != source.EndDate)
            {
                target.EndDate = source.EndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsReasonExitedDescriptorSupported)
                && target.ReasonExitedDescriptor != source.ReasonExitedDescriptor)
            {
                target.ReasonExitedDescriptor = source.ReasonExitedDescriptor;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsServedOutsideOfRegularSessionSupported)
                && target.ServedOutsideOfRegularSession != source.ServedOutsideOfRegularSession)
            {
                target.ServedOutsideOfRegularSession = source.ServedOutsideOfRegularSession;
                isModified = true;
            }



            // Sync lists
            if (sourceSupport == null || sourceSupport.IsStudentProgramAssociationServicesSupported)
                isModified |= source.StudentProgramAssociationServices.SynchronizeListTo(target.StudentProgramAssociationServices, child => child.StudentProgramAssociation = target,
                                sourceSupport == null ? null : sourceSupport.IsStudentProgramAssociationServiceIncluded);


            return isModified;
        }



        public static void MapTo(this IStudentProgramAssociation source, IStudentProgramAssociation target, Action<IStudentProgramAssociation, IStudentProgramAssociation> onMapped)
        {
            var sourceSynchSupport = source as IStudentProgramAssociationSynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentProgramAssociationSynchronizationSourceSupport;

            // =======================================================================================
            // Detect and map derived types (compiler is unable to correctly link to appropriate 
            //      mapping methods when there are base/derived interfaces and a concrete base class)
            // ---------------------------------------------------------------------------------------
            // Map derived type StudentCTEProgramAssociation
            var sourceStudentCTEProgramAssociation = source as IStudentCTEProgramAssociation;

            if (sourceStudentCTEProgramAssociation != null)
            {
                sourceStudentCTEProgramAssociation.MapDerivedTo((IStudentCTEProgramAssociation) target, onMapped);
                return;
            }
            // Map derived type StudentMigrantEducationProgramAssociation
            var sourceStudentMigrantEducationProgramAssociation = source as IStudentMigrantEducationProgramAssociation;

            if (sourceStudentMigrantEducationProgramAssociation != null)
            {
                sourceStudentMigrantEducationProgramAssociation.MapDerivedTo((IStudentMigrantEducationProgramAssociation) target, onMapped);
                return;
            }
            // Map derived type StudentSpecialEducationProgramAssociation
            var sourceStudentSpecialEducationProgramAssociation = source as IStudentSpecialEducationProgramAssociation;

            if (sourceStudentSpecialEducationProgramAssociation != null)
            {
                sourceStudentSpecialEducationProgramAssociation.MapDerivedTo((IStudentSpecialEducationProgramAssociation) target, onMapped);
                return;
            }
            // Map derived type StudentTitleIPartAProgramAssociation
            var sourceStudentTitleIPartAProgramAssociation = source as IStudentTitleIPartAProgramAssociation;

            if (sourceStudentTitleIPartAProgramAssociation != null)
            {
                sourceStudentTitleIPartAProgramAssociation.MapDerivedTo((IStudentTitleIPartAProgramAssociation) target, onMapped);
                return;
            }
            // =======================================================================================

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.BeginDate = source.BeginDate;
            target.EducationOrganizationId = source.EducationOrganizationId;
            target.ProgramEducationOrganizationId = source.ProgramEducationOrganizationId;
            target.ProgramName = source.ProgramName;
            target.ProgramType = source.ProgramType;
            target.StudentUniqueId = source.StudentUniqueId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsEndDateSupported)
                target.EndDate = source.EndDate;
            else
                targetSynchSupport.IsEndDateSupported = false;

            if (sourceSynchSupport.IsReasonExitedDescriptorSupported)
                target.ReasonExitedDescriptor = source.ReasonExitedDescriptor;
            else
                targetSynchSupport.IsReasonExitedDescriptorSupported = false;

            if (sourceSynchSupport.IsServedOutsideOfRegularSessionSupported)
                target.ServedOutsideOfRegularSession = source.ServedOutsideOfRegularSession;
            else
                targetSynchSupport.IsServedOutsideOfRegularSessionSupported = false;

            // Map lists

            if (sourceSynchSupport.IsStudentProgramAssociationServicesSupported)
            {    
                targetSynchSupport.IsStudentProgramAssociationServiceIncluded = sourceSynchSupport.IsStudentProgramAssociationServiceIncluded;
                source.StudentProgramAssociationServices.MapListTo(target.StudentProgramAssociationServices);
            }
            else
            {
                targetSynchSupport.IsStudentProgramAssociationServicesSupported = false;
            }

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentProgramAssociationSynchronizationSourceSupport
    {
        bool IsEndDateSupported { get; set; }
        bool IsReasonExitedDescriptorSupported { get; set; }
        bool IsServedOutsideOfRegularSessionSupported { get; set; }
        bool IsStudentProgramAssociationServicesSupported { get; set; }
        Func<IStudentProgramAssociationService, bool> IsStudentProgramAssociationServiceIncluded { get; set; }
    }
 
    public static class StudentProgramAssociationServiceMapper 
    {
        public static bool SynchronizeTo(this IStudentProgramAssociationService source, IStudentProgramAssociationService target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentProgramAssociationServiceSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.ServiceDescriptor != target.ServiceDescriptor)
            {
                source.ServiceDescriptor = target.ServiceDescriptor;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsPrimaryIndicatorSupported)
                && target.PrimaryIndicator != source.PrimaryIndicator)
            {
                target.PrimaryIndicator = source.PrimaryIndicator;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsServiceBeginDateSupported)
                && target.ServiceBeginDate != source.ServiceBeginDate)
            {
                target.ServiceBeginDate = source.ServiceBeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsServiceEndDateSupported)
                && target.ServiceEndDate != source.ServiceEndDate)
            {
                target.ServiceEndDate = source.ServiceEndDate;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStudentProgramAssociationService source, IStudentProgramAssociationService target, Action<IStudentProgramAssociationService, IStudentProgramAssociationService> onMapped)
        {
            var sourceSynchSupport = source as IStudentProgramAssociationServiceSynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentProgramAssociationServiceSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.ServiceDescriptor = source.ServiceDescriptor;

            // Copy non-PK properties

            if (sourceSynchSupport.IsPrimaryIndicatorSupported)
                target.PrimaryIndicator = source.PrimaryIndicator;
            else
                targetSynchSupport.IsPrimaryIndicatorSupported = false;

            if (sourceSynchSupport.IsServiceBeginDateSupported)
                target.ServiceBeginDate = source.ServiceBeginDate;
            else
                targetSynchSupport.IsServiceBeginDateSupported = false;

            if (sourceSynchSupport.IsServiceEndDateSupported)
                target.ServiceEndDate = source.ServiceEndDate;
            else
                targetSynchSupport.IsServiceEndDateSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentProgramAssociationServiceSynchronizationSourceSupport
    {
        bool IsPrimaryIndicatorSupported { get; set; }
        bool IsServiceBeginDateSupported { get; set; }
        bool IsServiceEndDateSupported { get; set; }
    }
 
}
// Aggregate: StudentProgramAttendanceEvent

namespace EdFi.Ods.Entities.Common //.StudentProgramAttendanceEventAggregate
{ 
    public static class StudentProgramAttendanceEventMapper 
    {
        public static bool SynchronizeTo(this IStudentProgramAttendanceEvent source, IStudentProgramAttendanceEvent target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentProgramAttendanceEventSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AttendanceEventCategoryDescriptor != target.AttendanceEventCategoryDescriptor)
            {
                source.AttendanceEventCategoryDescriptor = target.AttendanceEventCategoryDescriptor;
            }
            if (source.EducationOrganizationId != target.EducationOrganizationId)
            {
                source.EducationOrganizationId = target.EducationOrganizationId;
            }
            if (source.EventDate != target.EventDate)
            {
                source.EventDate = target.EventDate;
            }
            if (source.ProgramEducationOrganizationId != target.ProgramEducationOrganizationId)
            {
                source.ProgramEducationOrganizationId = target.ProgramEducationOrganizationId;
            }
            if (source.ProgramName != target.ProgramName)
            {
                source.ProgramName = target.ProgramName;
            }
            if (source.ProgramType != target.ProgramType)
            {
                source.ProgramType = target.ProgramType;
            }
            if (source.StudentUniqueId != target.StudentUniqueId)
            {
                source.StudentUniqueId = target.StudentUniqueId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsAttendanceEventReasonSupported)
                && target.AttendanceEventReason != source.AttendanceEventReason)
            {
                target.AttendanceEventReason = source.AttendanceEventReason;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEducationalEnvironmentTypeSupported)
                && target.EducationalEnvironmentType != source.EducationalEnvironmentType)
            {
                target.EducationalEnvironmentType = source.EducationalEnvironmentType;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStudentProgramAttendanceEvent source, IStudentProgramAttendanceEvent target, Action<IStudentProgramAttendanceEvent, IStudentProgramAttendanceEvent> onMapped)
        {
            var sourceSynchSupport = source as IStudentProgramAttendanceEventSynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentProgramAttendanceEventSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.AttendanceEventCategoryDescriptor = source.AttendanceEventCategoryDescriptor;
            target.EducationOrganizationId = source.EducationOrganizationId;
            target.EventDate = source.EventDate;
            target.ProgramEducationOrganizationId = source.ProgramEducationOrganizationId;
            target.ProgramName = source.ProgramName;
            target.ProgramType = source.ProgramType;
            target.StudentUniqueId = source.StudentUniqueId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsAttendanceEventReasonSupported)
                target.AttendanceEventReason = source.AttendanceEventReason;
            else
                targetSynchSupport.IsAttendanceEventReasonSupported = false;

            if (sourceSynchSupport.IsEducationalEnvironmentTypeSupported)
                target.EducationalEnvironmentType = source.EducationalEnvironmentType;
            else
                targetSynchSupport.IsEducationalEnvironmentTypeSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentProgramAttendanceEventSynchronizationSourceSupport
    {
        bool IsAttendanceEventReasonSupported { get; set; }
        bool IsEducationalEnvironmentTypeSupported { get; set; }
    }
 
}
// Aggregate: StudentSchoolAssociation

namespace EdFi.Ods.Entities.Common //.StudentSchoolAssociationAggregate
{ 
    public static class StudentSchoolAssociationMapper 
    {
        public static bool SynchronizeTo(this IStudentSchoolAssociation source, IStudentSchoolAssociation target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentSchoolAssociationSynchronizationSourceSupport;

            // Allow PK column updates on StudentSchoolAssociation
            if (
                 (target.EntryDate != source.EntryDate)
                || (target.SchoolId != source.SchoolId)
                || (target.StudentUniqueId != source.StudentUniqueId))
            {            
                isModified = true;

                var sourceWithPrimaryKeyValues = (source as IHasPrimaryKeyValues);

                if (sourceWithPrimaryKeyValues != null)
                {
                    var targetWithNewKeyValues = target as IHasCascadableKeyValues;

                    if (targetWithNewKeyValues != null)
                        targetWithNewKeyValues.NewKeyValues = sourceWithPrimaryKeyValues.GetPrimaryKeyValues();
                }
            }

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.EntryDate != target.EntryDate)
            {
                source.EntryDate = target.EntryDate;
            }
            if (source.SchoolId != target.SchoolId)
            {
                source.SchoolId = target.SchoolId;
            }
            if (source.StudentUniqueId != target.StudentUniqueId)
            {
                source.StudentUniqueId = target.StudentUniqueId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsClassOfSchoolYearSupported)
                && target.ClassOfSchoolYear != source.ClassOfSchoolYear)
            {
                target.ClassOfSchoolYear = source.ClassOfSchoolYear;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEducationOrganizationIdSupported)
                && target.EducationOrganizationId != source.EducationOrganizationId)
            {
                target.EducationOrganizationId = source.EducationOrganizationId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEmployedWhileEnrolledSupported)
                && target.EmployedWhileEnrolled != source.EmployedWhileEnrolled)
            {
                target.EmployedWhileEnrolled = source.EmployedWhileEnrolled;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEntryGradeLevelDescriptorSupported)
                && target.EntryGradeLevelDescriptor != source.EntryGradeLevelDescriptor)
            {
                target.EntryGradeLevelDescriptor = source.EntryGradeLevelDescriptor;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEntryGradeLevelReasonTypeSupported)
                && target.EntryGradeLevelReasonType != source.EntryGradeLevelReasonType)
            {
                target.EntryGradeLevelReasonType = source.EntryGradeLevelReasonType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEntryTypeDescriptorSupported)
                && target.EntryTypeDescriptor != source.EntryTypeDescriptor)
            {
                target.EntryTypeDescriptor = source.EntryTypeDescriptor;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsExitWithdrawDateSupported)
                && target.ExitWithdrawDate != source.ExitWithdrawDate)
            {
                target.ExitWithdrawDate = source.ExitWithdrawDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsExitWithdrawTypeDescriptorSupported)
                && target.ExitWithdrawTypeDescriptor != source.ExitWithdrawTypeDescriptor)
            {
                target.ExitWithdrawTypeDescriptor = source.ExitWithdrawTypeDescriptor;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsGraduationPlanTypeDescriptorSupported)
                && target.GraduationPlanTypeDescriptor != source.GraduationPlanTypeDescriptor)
            {
                target.GraduationPlanTypeDescriptor = source.GraduationPlanTypeDescriptor;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsGraduationSchoolYearSupported)
                && target.GraduationSchoolYear != source.GraduationSchoolYear)
            {
                target.GraduationSchoolYear = source.GraduationSchoolYear;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPrimarySchoolSupported)
                && target.PrimarySchool != source.PrimarySchool)
            {
                target.PrimarySchool = source.PrimarySchool;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsRepeatGradeIndicatorSupported)
                && target.RepeatGradeIndicator != source.RepeatGradeIndicator)
            {
                target.RepeatGradeIndicator = source.RepeatGradeIndicator;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsResidencyStatusDescriptorSupported)
                && target.ResidencyStatusDescriptor != source.ResidencyStatusDescriptor)
            {
                target.ResidencyStatusDescriptor = source.ResidencyStatusDescriptor;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsSchoolChoiceTransferSupported)
                && target.SchoolChoiceTransfer != source.SchoolChoiceTransfer)
            {
                target.SchoolChoiceTransfer = source.SchoolChoiceTransfer;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsSchoolYearSupported)
                && target.SchoolYear != source.SchoolYear)
            {
                target.SchoolYear = source.SchoolYear;
                isModified = true;
            }



            // Sync lists
            if (sourceSupport == null || sourceSupport.IsStudentSchoolAssociationEducationPlansSupported)
                isModified |= source.StudentSchoolAssociationEducationPlans.SynchronizeListTo(target.StudentSchoolAssociationEducationPlans, child => child.StudentSchoolAssociation = target,
                                sourceSupport == null ? null : sourceSupport.IsStudentSchoolAssociationEducationPlanIncluded);


            return isModified;
        }



        public static void MapTo(this IStudentSchoolAssociation source, IStudentSchoolAssociation target, Action<IStudentSchoolAssociation, IStudentSchoolAssociation> onMapped)
        {
            var sourceSynchSupport = source as IStudentSchoolAssociationSynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentSchoolAssociationSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.EntryDate = source.EntryDate;
            target.SchoolId = source.SchoolId;
            target.StudentUniqueId = source.StudentUniqueId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsClassOfSchoolYearSupported)
                target.ClassOfSchoolYear = source.ClassOfSchoolYear;
            else
                targetSynchSupport.IsClassOfSchoolYearSupported = false;

            if (sourceSynchSupport.IsEducationOrganizationIdSupported)
                target.EducationOrganizationId = source.EducationOrganizationId;
            else
                targetSynchSupport.IsEducationOrganizationIdSupported = false;

            if (sourceSynchSupport.IsEmployedWhileEnrolledSupported)
                target.EmployedWhileEnrolled = source.EmployedWhileEnrolled;
            else
                targetSynchSupport.IsEmployedWhileEnrolledSupported = false;

            if (sourceSynchSupport.IsEntryGradeLevelDescriptorSupported)
                target.EntryGradeLevelDescriptor = source.EntryGradeLevelDescriptor;
            else
                targetSynchSupport.IsEntryGradeLevelDescriptorSupported = false;

            if (sourceSynchSupport.IsEntryGradeLevelReasonTypeSupported)
                target.EntryGradeLevelReasonType = source.EntryGradeLevelReasonType;
            else
                targetSynchSupport.IsEntryGradeLevelReasonTypeSupported = false;

            if (sourceSynchSupport.IsEntryTypeDescriptorSupported)
                target.EntryTypeDescriptor = source.EntryTypeDescriptor;
            else
                targetSynchSupport.IsEntryTypeDescriptorSupported = false;

            if (sourceSynchSupport.IsExitWithdrawDateSupported)
                target.ExitWithdrawDate = source.ExitWithdrawDate;
            else
                targetSynchSupport.IsExitWithdrawDateSupported = false;

            if (sourceSynchSupport.IsExitWithdrawTypeDescriptorSupported)
                target.ExitWithdrawTypeDescriptor = source.ExitWithdrawTypeDescriptor;
            else
                targetSynchSupport.IsExitWithdrawTypeDescriptorSupported = false;

            if (sourceSynchSupport.IsGraduationPlanTypeDescriptorSupported)
                target.GraduationPlanTypeDescriptor = source.GraduationPlanTypeDescriptor;
            else
                targetSynchSupport.IsGraduationPlanTypeDescriptorSupported = false;

            if (sourceSynchSupport.IsGraduationSchoolYearSupported)
                target.GraduationSchoolYear = source.GraduationSchoolYear;
            else
                targetSynchSupport.IsGraduationSchoolYearSupported = false;

            if (sourceSynchSupport.IsPrimarySchoolSupported)
                target.PrimarySchool = source.PrimarySchool;
            else
                targetSynchSupport.IsPrimarySchoolSupported = false;

            if (sourceSynchSupport.IsRepeatGradeIndicatorSupported)
                target.RepeatGradeIndicator = source.RepeatGradeIndicator;
            else
                targetSynchSupport.IsRepeatGradeIndicatorSupported = false;

            if (sourceSynchSupport.IsResidencyStatusDescriptorSupported)
                target.ResidencyStatusDescriptor = source.ResidencyStatusDescriptor;
            else
                targetSynchSupport.IsResidencyStatusDescriptorSupported = false;

            if (sourceSynchSupport.IsSchoolChoiceTransferSupported)
                target.SchoolChoiceTransfer = source.SchoolChoiceTransfer;
            else
                targetSynchSupport.IsSchoolChoiceTransferSupported = false;

            if (sourceSynchSupport.IsSchoolYearSupported)
                target.SchoolYear = source.SchoolYear;
            else
                targetSynchSupport.IsSchoolYearSupported = false;

            // Map lists

            if (sourceSynchSupport.IsStudentSchoolAssociationEducationPlansSupported)
            {    
                targetSynchSupport.IsStudentSchoolAssociationEducationPlanIncluded = sourceSynchSupport.IsStudentSchoolAssociationEducationPlanIncluded;
                source.StudentSchoolAssociationEducationPlans.MapListTo(target.StudentSchoolAssociationEducationPlans);
            }
            else
            {
                targetSynchSupport.IsStudentSchoolAssociationEducationPlansSupported = false;
            }

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentSchoolAssociationSynchronizationSourceSupport
    {
        bool IsClassOfSchoolYearSupported { get; set; }
        bool IsEducationOrganizationIdSupported { get; set; }
        bool IsEmployedWhileEnrolledSupported { get; set; }
        bool IsEntryGradeLevelDescriptorSupported { get; set; }
        bool IsEntryGradeLevelReasonTypeSupported { get; set; }
        bool IsEntryTypeDescriptorSupported { get; set; }
        bool IsExitWithdrawDateSupported { get; set; }
        bool IsExitWithdrawTypeDescriptorSupported { get; set; }
        bool IsGraduationPlanTypeDescriptorSupported { get; set; }
        bool IsGraduationSchoolYearSupported { get; set; }
        bool IsPrimarySchoolSupported { get; set; }
        bool IsRepeatGradeIndicatorSupported { get; set; }
        bool IsResidencyStatusDescriptorSupported { get; set; }
        bool IsSchoolChoiceTransferSupported { get; set; }
        bool IsSchoolYearSupported { get; set; }
        bool IsStudentSchoolAssociationEducationPlansSupported { get; set; }
        Func<IStudentSchoolAssociationEducationPlan, bool> IsStudentSchoolAssociationEducationPlanIncluded { get; set; }
    }
 
    public static class StudentSchoolAssociationEducationPlanMapper 
    {
        public static bool SynchronizeTo(this IStudentSchoolAssociationEducationPlan source, IStudentSchoolAssociationEducationPlan target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentSchoolAssociationEducationPlanSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.EducationPlanType != target.EducationPlanType)
            {
                source.EducationPlanType = target.EducationPlanType;
            }

            // Copy non-PK properties



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStudentSchoolAssociationEducationPlan source, IStudentSchoolAssociationEducationPlan target, Action<IStudentSchoolAssociationEducationPlan, IStudentSchoolAssociationEducationPlan> onMapped)
        {
            var sourceSynchSupport = source as IStudentSchoolAssociationEducationPlanSynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentSchoolAssociationEducationPlanSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.EducationPlanType = source.EducationPlanType;

            // Copy non-PK properties

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentSchoolAssociationEducationPlanSynchronizationSourceSupport
    {
    }
 
}
// Aggregate: StudentSchoolAttendanceEvent

namespace EdFi.Ods.Entities.Common //.StudentSchoolAttendanceEventAggregate
{ 
    public static class StudentSchoolAttendanceEventMapper 
    {
        public static bool SynchronizeTo(this IStudentSchoolAttendanceEvent source, IStudentSchoolAttendanceEvent target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentSchoolAttendanceEventSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AttendanceEventCategoryDescriptor != target.AttendanceEventCategoryDescriptor)
            {
                source.AttendanceEventCategoryDescriptor = target.AttendanceEventCategoryDescriptor;
            }
            if (source.EventDate != target.EventDate)
            {
                source.EventDate = target.EventDate;
            }
            if (source.SchoolId != target.SchoolId)
            {
                source.SchoolId = target.SchoolId;
            }
            if (source.SchoolYear != target.SchoolYear)
            {
                source.SchoolYear = target.SchoolYear;
            }
            if (source.StudentUniqueId != target.StudentUniqueId)
            {
                source.StudentUniqueId = target.StudentUniqueId;
            }
            if (source.TermDescriptor != target.TermDescriptor)
            {
                source.TermDescriptor = target.TermDescriptor;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsAttendanceEventReasonSupported)
                && target.AttendanceEventReason != source.AttendanceEventReason)
            {
                target.AttendanceEventReason = source.AttendanceEventReason;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEducationalEnvironmentTypeSupported)
                && target.EducationalEnvironmentType != source.EducationalEnvironmentType)
            {
                target.EducationalEnvironmentType = source.EducationalEnvironmentType;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStudentSchoolAttendanceEvent source, IStudentSchoolAttendanceEvent target, Action<IStudentSchoolAttendanceEvent, IStudentSchoolAttendanceEvent> onMapped)
        {
            var sourceSynchSupport = source as IStudentSchoolAttendanceEventSynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentSchoolAttendanceEventSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.AttendanceEventCategoryDescriptor = source.AttendanceEventCategoryDescriptor;
            target.EventDate = source.EventDate;
            target.SchoolId = source.SchoolId;
            target.SchoolYear = source.SchoolYear;
            target.StudentUniqueId = source.StudentUniqueId;
            target.TermDescriptor = source.TermDescriptor;

            // Copy non-PK properties

            if (sourceSynchSupport.IsAttendanceEventReasonSupported)
                target.AttendanceEventReason = source.AttendanceEventReason;
            else
                targetSynchSupport.IsAttendanceEventReasonSupported = false;

            if (sourceSynchSupport.IsEducationalEnvironmentTypeSupported)
                target.EducationalEnvironmentType = source.EducationalEnvironmentType;
            else
                targetSynchSupport.IsEducationalEnvironmentTypeSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentSchoolAttendanceEventSynchronizationSourceSupport
    {
        bool IsAttendanceEventReasonSupported { get; set; }
        bool IsEducationalEnvironmentTypeSupported { get; set; }
    }
 
}
// Aggregate: StudentSectionAssociation

namespace EdFi.Ods.Entities.Common //.StudentSectionAssociationAggregate
{ 
    public static class StudentSectionAssociationMapper 
    {
        public static bool SynchronizeTo(this IStudentSectionAssociation source, IStudentSectionAssociation target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentSectionAssociationSynchronizationSourceSupport;

            // Allow PK column updates on StudentSectionAssociation
            if (
                 (target.BeginDate != source.BeginDate)
                || (target.ClassPeriodName != source.ClassPeriodName)
                || (target.ClassroomIdentificationCode != source.ClassroomIdentificationCode)
                || (target.LocalCourseCode != source.LocalCourseCode)
                || (target.SchoolId != source.SchoolId)
                || (target.SchoolYear != source.SchoolYear)
                || (target.SequenceOfCourse != source.SequenceOfCourse)
                || (target.StudentUniqueId != source.StudentUniqueId)
                || (target.TermDescriptor != source.TermDescriptor)
                || (target.UniqueSectionCode != source.UniqueSectionCode))
            {            
                isModified = true;

                var sourceWithPrimaryKeyValues = (source as IHasPrimaryKeyValues);

                if (sourceWithPrimaryKeyValues != null)
                {
                    var targetWithNewKeyValues = target as IHasCascadableKeyValues;

                    if (targetWithNewKeyValues != null)
                        targetWithNewKeyValues.NewKeyValues = sourceWithPrimaryKeyValues.GetPrimaryKeyValues();
                }
            }

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.BeginDate != target.BeginDate)
            {
                source.BeginDate = target.BeginDate;
            }
            if (source.ClassPeriodName != target.ClassPeriodName)
            {
                source.ClassPeriodName = target.ClassPeriodName;
            }
            if (source.ClassroomIdentificationCode != target.ClassroomIdentificationCode)
            {
                source.ClassroomIdentificationCode = target.ClassroomIdentificationCode;
            }
            if (source.LocalCourseCode != target.LocalCourseCode)
            {
                source.LocalCourseCode = target.LocalCourseCode;
            }
            if (source.SchoolId != target.SchoolId)
            {
                source.SchoolId = target.SchoolId;
            }
            if (source.SchoolYear != target.SchoolYear)
            {
                source.SchoolYear = target.SchoolYear;
            }
            if (source.SequenceOfCourse != target.SequenceOfCourse)
            {
                source.SequenceOfCourse = target.SequenceOfCourse;
            }
            if (source.StudentUniqueId != target.StudentUniqueId)
            {
                source.StudentUniqueId = target.StudentUniqueId;
            }
            if (source.TermDescriptor != target.TermDescriptor)
            {
                source.TermDescriptor = target.TermDescriptor;
            }
            if (source.UniqueSectionCode != target.UniqueSectionCode)
            {
                source.UniqueSectionCode = target.UniqueSectionCode;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsEndDateSupported)
                && target.EndDate != source.EndDate)
            {
                target.EndDate = source.EndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsHomeroomIndicatorSupported)
                && target.HomeroomIndicator != source.HomeroomIndicator)
            {
                target.HomeroomIndicator = source.HomeroomIndicator;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsRepeatIdentifierTypeSupported)
                && target.RepeatIdentifierType != source.RepeatIdentifierType)
            {
                target.RepeatIdentifierType = source.RepeatIdentifierType;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsTeacherStudentDataLinkExclusionSupported)
                && target.TeacherStudentDataLinkExclusion != source.TeacherStudentDataLinkExclusion)
            {
                target.TeacherStudentDataLinkExclusion = source.TeacherStudentDataLinkExclusion;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStudentSectionAssociation source, IStudentSectionAssociation target, Action<IStudentSectionAssociation, IStudentSectionAssociation> onMapped)
        {
            var sourceSynchSupport = source as IStudentSectionAssociationSynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentSectionAssociationSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.BeginDate = source.BeginDate;
            target.ClassPeriodName = source.ClassPeriodName;
            target.ClassroomIdentificationCode = source.ClassroomIdentificationCode;
            target.LocalCourseCode = source.LocalCourseCode;
            target.SchoolId = source.SchoolId;
            target.SchoolYear = source.SchoolYear;
            target.SequenceOfCourse = source.SequenceOfCourse;
            target.StudentUniqueId = source.StudentUniqueId;
            target.TermDescriptor = source.TermDescriptor;
            target.UniqueSectionCode = source.UniqueSectionCode;

            // Copy non-PK properties

            if (sourceSynchSupport.IsEndDateSupported)
                target.EndDate = source.EndDate;
            else
                targetSynchSupport.IsEndDateSupported = false;

            if (sourceSynchSupport.IsHomeroomIndicatorSupported)
                target.HomeroomIndicator = source.HomeroomIndicator;
            else
                targetSynchSupport.IsHomeroomIndicatorSupported = false;

            if (sourceSynchSupport.IsRepeatIdentifierTypeSupported)
                target.RepeatIdentifierType = source.RepeatIdentifierType;
            else
                targetSynchSupport.IsRepeatIdentifierTypeSupported = false;

            if (sourceSynchSupport.IsTeacherStudentDataLinkExclusionSupported)
                target.TeacherStudentDataLinkExclusion = source.TeacherStudentDataLinkExclusion;
            else
                targetSynchSupport.IsTeacherStudentDataLinkExclusionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentSectionAssociationSynchronizationSourceSupport
    {
        bool IsEndDateSupported { get; set; }
        bool IsHomeroomIndicatorSupported { get; set; }
        bool IsRepeatIdentifierTypeSupported { get; set; }
        bool IsTeacherStudentDataLinkExclusionSupported { get; set; }
    }
 
}
// Aggregate: StudentSectionAttendanceEvent

namespace EdFi.Ods.Entities.Common //.StudentSectionAttendanceEventAggregate
{ 
    public static class StudentSectionAttendanceEventMapper 
    {
        public static bool SynchronizeTo(this IStudentSectionAttendanceEvent source, IStudentSectionAttendanceEvent target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentSectionAttendanceEventSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.AttendanceEventCategoryDescriptor != target.AttendanceEventCategoryDescriptor)
            {
                source.AttendanceEventCategoryDescriptor = target.AttendanceEventCategoryDescriptor;
            }
            if (source.ClassPeriodName != target.ClassPeriodName)
            {
                source.ClassPeriodName = target.ClassPeriodName;
            }
            if (source.ClassroomIdentificationCode != target.ClassroomIdentificationCode)
            {
                source.ClassroomIdentificationCode = target.ClassroomIdentificationCode;
            }
            if (source.EventDate != target.EventDate)
            {
                source.EventDate = target.EventDate;
            }
            if (source.LocalCourseCode != target.LocalCourseCode)
            {
                source.LocalCourseCode = target.LocalCourseCode;
            }
            if (source.SchoolId != target.SchoolId)
            {
                source.SchoolId = target.SchoolId;
            }
            if (source.SchoolYear != target.SchoolYear)
            {
                source.SchoolYear = target.SchoolYear;
            }
            if (source.SequenceOfCourse != target.SequenceOfCourse)
            {
                source.SequenceOfCourse = target.SequenceOfCourse;
            }
            if (source.StudentUniqueId != target.StudentUniqueId)
            {
                source.StudentUniqueId = target.StudentUniqueId;
            }
            if (source.TermDescriptor != target.TermDescriptor)
            {
                source.TermDescriptor = target.TermDescriptor;
            }
            if (source.UniqueSectionCode != target.UniqueSectionCode)
            {
                source.UniqueSectionCode = target.UniqueSectionCode;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsAttendanceEventReasonSupported)
                && target.AttendanceEventReason != source.AttendanceEventReason)
            {
                target.AttendanceEventReason = source.AttendanceEventReason;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEducationalEnvironmentTypeSupported)
                && target.EducationalEnvironmentType != source.EducationalEnvironmentType)
            {
                target.EducationalEnvironmentType = source.EducationalEnvironmentType;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStudentSectionAttendanceEvent source, IStudentSectionAttendanceEvent target, Action<IStudentSectionAttendanceEvent, IStudentSectionAttendanceEvent> onMapped)
        {
            var sourceSynchSupport = source as IStudentSectionAttendanceEventSynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentSectionAttendanceEventSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.AttendanceEventCategoryDescriptor = source.AttendanceEventCategoryDescriptor;
            target.ClassPeriodName = source.ClassPeriodName;
            target.ClassroomIdentificationCode = source.ClassroomIdentificationCode;
            target.EventDate = source.EventDate;
            target.LocalCourseCode = source.LocalCourseCode;
            target.SchoolId = source.SchoolId;
            target.SchoolYear = source.SchoolYear;
            target.SequenceOfCourse = source.SequenceOfCourse;
            target.StudentUniqueId = source.StudentUniqueId;
            target.TermDescriptor = source.TermDescriptor;
            target.UniqueSectionCode = source.UniqueSectionCode;

            // Copy non-PK properties

            if (sourceSynchSupport.IsAttendanceEventReasonSupported)
                target.AttendanceEventReason = source.AttendanceEventReason;
            else
                targetSynchSupport.IsAttendanceEventReasonSupported = false;

            if (sourceSynchSupport.IsEducationalEnvironmentTypeSupported)
                target.EducationalEnvironmentType = source.EducationalEnvironmentType;
            else
                targetSynchSupport.IsEducationalEnvironmentTypeSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentSectionAttendanceEventSynchronizationSourceSupport
    {
        bool IsAttendanceEventReasonSupported { get; set; }
        bool IsEducationalEnvironmentTypeSupported { get; set; }
    }
 
}
// Aggregate: StudentSpecialEducationProgramAssociation

namespace EdFi.Ods.Entities.Common //.StudentSpecialEducationProgramAssociationAggregate
{ 
    public static class StudentSpecialEducationProgramAssociationMapper 
    {
        public static bool SynchronizeTo(this IStudentSpecialEducationProgramAssociation source, IStudentSpecialEducationProgramAssociation target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentSpecialEducationProgramAssociationSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.BeginDate != target.BeginDate)
            {
                source.BeginDate = target.BeginDate;
            }
            if (source.EducationOrganizationId != target.EducationOrganizationId)
            {
                source.EducationOrganizationId = target.EducationOrganizationId;
            }
            if (source.ProgramEducationOrganizationId != target.ProgramEducationOrganizationId)
            {
                source.ProgramEducationOrganizationId = target.ProgramEducationOrganizationId;
            }
            if (source.ProgramName != target.ProgramName)
            {
                source.ProgramName = target.ProgramName;
            }
            if (source.ProgramType != target.ProgramType)
            {
                source.ProgramType = target.ProgramType;
            }
            if (source.StudentUniqueId != target.StudentUniqueId)
            {
                source.StudentUniqueId = target.StudentUniqueId;
            }

            // Copy inherited non-PK properties


            if ((sourceSupport == null || sourceSupport.IsEndDateSupported)
                && target.EndDate != source.EndDate)
            {
                target.EndDate = source.EndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsReasonExitedDescriptorSupported)
                && target.ReasonExitedDescriptor != source.ReasonExitedDescriptor)
            {
                target.ReasonExitedDescriptor = source.ReasonExitedDescriptor;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsServedOutsideOfRegularSessionSupported)
                && target.ServedOutsideOfRegularSession != source.ServedOutsideOfRegularSession)
            {
                target.ServedOutsideOfRegularSession = source.ServedOutsideOfRegularSession;
                isModified = true;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsIdeaEligibilitySupported)
                && target.IdeaEligibility != source.IdeaEligibility)
            {
                target.IdeaEligibility = source.IdeaEligibility;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsIEPBeginDateSupported)
                && target.IEPBeginDate != source.IEPBeginDate)
            {
                target.IEPBeginDate = source.IEPBeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsIEPEndDateSupported)
                && target.IEPEndDate != source.IEPEndDate)
            {
                target.IEPEndDate = source.IEPEndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsIEPReviewDateSupported)
                && target.IEPReviewDate != source.IEPReviewDate)
            {
                target.IEPReviewDate = source.IEPReviewDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsLastEvaluationDateSupported)
                && target.LastEvaluationDate != source.LastEvaluationDate)
            {
                target.LastEvaluationDate = source.LastEvaluationDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsMedicallyFragileSupported)
                && target.MedicallyFragile != source.MedicallyFragile)
            {
                target.MedicallyFragile = source.MedicallyFragile;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsMultiplyDisabledSupported)
                && target.MultiplyDisabled != source.MultiplyDisabled)
            {
                target.MultiplyDisabled = source.MultiplyDisabled;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsSchoolHoursPerWeekSupported)
                && target.SchoolHoursPerWeek != source.SchoolHoursPerWeek)
            {
                target.SchoolHoursPerWeek = source.SchoolHoursPerWeek;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsSpecialEducationHoursPerWeekSupported)
                && target.SpecialEducationHoursPerWeek != source.SpecialEducationHoursPerWeek)
            {
                target.SpecialEducationHoursPerWeek = source.SpecialEducationHoursPerWeek;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsSpecialEducationSettingDescriptorSupported)
                && target.SpecialEducationSettingDescriptor != source.SpecialEducationSettingDescriptor)
            {
                target.SpecialEducationSettingDescriptor = source.SpecialEducationSettingDescriptor;
                isModified = true;
            }

            // Synch inherited lists
            if (sourceSupport == null || sourceSupport.IsStudentProgramAssociationServicesSupported)
                isModified |= source.StudentProgramAssociationServices.SynchronizeListTo(target.StudentProgramAssociationServices, child => child.StudentProgramAssociation = target,
                                sourceSupport == null ? null : sourceSupport.IsStudentProgramAssociationServiceIncluded);



            // Sync lists
            if (sourceSupport == null || sourceSupport.IsStudentSpecialEducationProgramAssociationServiceProvidersSupported)
                isModified |= source.StudentSpecialEducationProgramAssociationServiceProviders.SynchronizeListTo(target.StudentSpecialEducationProgramAssociationServiceProviders, child => child.StudentSpecialEducationProgramAssociation = target,
                                sourceSupport == null ? null : sourceSupport.IsStudentSpecialEducationProgramAssociationServiceProviderIncluded);


            return isModified;
        }



        internal static void MapDerivedTo(this IStudentSpecialEducationProgramAssociation source, IStudentSpecialEducationProgramAssociation target, Action<IStudentSpecialEducationProgramAssociation, IStudentSpecialEducationProgramAssociation> onMapped)
        {
            var sourceSynchSupport = source as IStudentSpecialEducationProgramAssociationSynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentSpecialEducationProgramAssociationSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.BeginDate = source.BeginDate;
            target.EducationOrganizationId = source.EducationOrganizationId;
            target.ProgramEducationOrganizationId = source.ProgramEducationOrganizationId;
            target.ProgramName = source.ProgramName;
            target.ProgramType = source.ProgramType;
            target.StudentUniqueId = source.StudentUniqueId;

            // Copy inherited non-PK properties

            if (sourceSynchSupport.IsEndDateSupported)
                target.EndDate = source.EndDate;
            else
                targetSynchSupport.IsEndDateSupported = false;

            if (sourceSynchSupport.IsReasonExitedDescriptorSupported)
                target.ReasonExitedDescriptor = source.ReasonExitedDescriptor;
            else
                targetSynchSupport.IsReasonExitedDescriptorSupported = false;

            if (sourceSynchSupport.IsServedOutsideOfRegularSessionSupported)
                target.ServedOutsideOfRegularSession = source.ServedOutsideOfRegularSession;
            else
                targetSynchSupport.IsServedOutsideOfRegularSessionSupported = false;

            // Copy non-PK properties

            if (sourceSynchSupport.IsIdeaEligibilitySupported)
                target.IdeaEligibility = source.IdeaEligibility;
            else
                targetSynchSupport.IsIdeaEligibilitySupported = false;

            if (sourceSynchSupport.IsIEPBeginDateSupported)
                target.IEPBeginDate = source.IEPBeginDate;
            else
                targetSynchSupport.IsIEPBeginDateSupported = false;

            if (sourceSynchSupport.IsIEPEndDateSupported)
                target.IEPEndDate = source.IEPEndDate;
            else
                targetSynchSupport.IsIEPEndDateSupported = false;

            if (sourceSynchSupport.IsIEPReviewDateSupported)
                target.IEPReviewDate = source.IEPReviewDate;
            else
                targetSynchSupport.IsIEPReviewDateSupported = false;

            if (sourceSynchSupport.IsLastEvaluationDateSupported)
                target.LastEvaluationDate = source.LastEvaluationDate;
            else
                targetSynchSupport.IsLastEvaluationDateSupported = false;

            if (sourceSynchSupport.IsMedicallyFragileSupported)
                target.MedicallyFragile = source.MedicallyFragile;
            else
                targetSynchSupport.IsMedicallyFragileSupported = false;

            if (sourceSynchSupport.IsMultiplyDisabledSupported)
                target.MultiplyDisabled = source.MultiplyDisabled;
            else
                targetSynchSupport.IsMultiplyDisabledSupported = false;

            if (sourceSynchSupport.IsSchoolHoursPerWeekSupported)
                target.SchoolHoursPerWeek = source.SchoolHoursPerWeek;
            else
                targetSynchSupport.IsSchoolHoursPerWeekSupported = false;

            if (sourceSynchSupport.IsSpecialEducationHoursPerWeekSupported)
                target.SpecialEducationHoursPerWeek = source.SpecialEducationHoursPerWeek;
            else
                targetSynchSupport.IsSpecialEducationHoursPerWeekSupported = false;

            if (sourceSynchSupport.IsSpecialEducationSettingDescriptorSupported)
                target.SpecialEducationSettingDescriptor = source.SpecialEducationSettingDescriptor;
            else
                targetSynchSupport.IsSpecialEducationSettingDescriptorSupported = false;

            // Map inherited lists

            if (sourceSynchSupport.IsStudentProgramAssociationServicesSupported)
            {
                targetSynchSupport.IsStudentProgramAssociationServiceIncluded = sourceSynchSupport.IsStudentProgramAssociationServiceIncluded;
                source.StudentProgramAssociationServices.MapListTo(target.StudentProgramAssociationServices);
            }
            else
            {
                targetSynchSupport.IsStudentProgramAssociationServicesSupported = false;
            }

            // Map lists

            if (sourceSynchSupport.IsStudentSpecialEducationProgramAssociationServiceProvidersSupported)
            {    
                targetSynchSupport.IsStudentSpecialEducationProgramAssociationServiceProviderIncluded = sourceSynchSupport.IsStudentSpecialEducationProgramAssociationServiceProviderIncluded;
                source.StudentSpecialEducationProgramAssociationServiceProviders.MapListTo(target.StudentSpecialEducationProgramAssociationServiceProviders);
            }
            else
            {
                targetSynchSupport.IsStudentSpecialEducationProgramAssociationServiceProvidersSupported = false;
            }

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentSpecialEducationProgramAssociationSynchronizationSourceSupport
    {
        bool IsEndDateSupported { get; set; }
        bool IsIdeaEligibilitySupported { get; set; }
        bool IsIEPBeginDateSupported { get; set; }
        bool IsIEPEndDateSupported { get; set; }
        bool IsIEPReviewDateSupported { get; set; }
        bool IsLastEvaluationDateSupported { get; set; }
        bool IsMedicallyFragileSupported { get; set; }
        bool IsMultiplyDisabledSupported { get; set; }
        bool IsReasonExitedDescriptorSupported { get; set; }
        bool IsSchoolHoursPerWeekSupported { get; set; }
        bool IsServedOutsideOfRegularSessionSupported { get; set; }
        bool IsSpecialEducationHoursPerWeekSupported { get; set; }
        bool IsSpecialEducationSettingDescriptorSupported { get; set; }
        bool IsStudentProgramAssociationServicesSupported { get; set; }
        bool IsStudentSpecialEducationProgramAssociationServiceProvidersSupported { get; set; }
        Func<IStudentProgramAssociationService, bool> IsStudentProgramAssociationServiceIncluded { get; set; }
        Func<IStudentSpecialEducationProgramAssociationServiceProvider, bool> IsStudentSpecialEducationProgramAssociationServiceProviderIncluded { get; set; }
    }
 
    public static class StudentSpecialEducationProgramAssociationServiceProviderMapper 
    {
        public static bool SynchronizeTo(this IStudentSpecialEducationProgramAssociationServiceProvider source, IStudentSpecialEducationProgramAssociationServiceProvider target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentSpecialEducationProgramAssociationServiceProviderSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.StaffUniqueId != target.StaffUniqueId)
            {
                source.StaffUniqueId = target.StaffUniqueId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsPrimaryProviderSupported)
                && target.PrimaryProvider != source.PrimaryProvider)
            {
                target.PrimaryProvider = source.PrimaryProvider;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IStudentSpecialEducationProgramAssociationServiceProvider source, IStudentSpecialEducationProgramAssociationServiceProvider target, Action<IStudentSpecialEducationProgramAssociationServiceProvider, IStudentSpecialEducationProgramAssociationServiceProvider> onMapped)
        {
            var sourceSynchSupport = source as IStudentSpecialEducationProgramAssociationServiceProviderSynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentSpecialEducationProgramAssociationServiceProviderSynchronizationSourceSupport;

            // Copy contextual primary key values
            target.StaffUniqueId = source.StaffUniqueId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsPrimaryProviderSupported)
                target.PrimaryProvider = source.PrimaryProvider;
            else
                targetSynchSupport.IsPrimaryProviderSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentSpecialEducationProgramAssociationServiceProviderSynchronizationSourceSupport
    {
        bool IsPrimaryProviderSupported { get; set; }
    }
 
}
// Aggregate: StudentTitleIPartAProgramAssociation

namespace EdFi.Ods.Entities.Common //.StudentTitleIPartAProgramAssociationAggregate
{ 
    public static class StudentTitleIPartAProgramAssociationMapper 
    {
        public static bool SynchronizeTo(this IStudentTitleIPartAProgramAssociation source, IStudentTitleIPartAProgramAssociation target)
        {
            bool isModified = false;

            var sourceSupport = source as IStudentTitleIPartAProgramAssociationSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.BeginDate != target.BeginDate)
            {
                source.BeginDate = target.BeginDate;
            }
            if (source.EducationOrganizationId != target.EducationOrganizationId)
            {
                source.EducationOrganizationId = target.EducationOrganizationId;
            }
            if (source.ProgramEducationOrganizationId != target.ProgramEducationOrganizationId)
            {
                source.ProgramEducationOrganizationId = target.ProgramEducationOrganizationId;
            }
            if (source.ProgramName != target.ProgramName)
            {
                source.ProgramName = target.ProgramName;
            }
            if (source.ProgramType != target.ProgramType)
            {
                source.ProgramType = target.ProgramType;
            }
            if (source.StudentUniqueId != target.StudentUniqueId)
            {
                source.StudentUniqueId = target.StudentUniqueId;
            }

            // Copy inherited non-PK properties


            if ((sourceSupport == null || sourceSupport.IsEndDateSupported)
                && target.EndDate != source.EndDate)
            {
                target.EndDate = source.EndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsReasonExitedDescriptorSupported)
                && target.ReasonExitedDescriptor != source.ReasonExitedDescriptor)
            {
                target.ReasonExitedDescriptor = source.ReasonExitedDescriptor;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsServedOutsideOfRegularSessionSupported)
                && target.ServedOutsideOfRegularSession != source.ServedOutsideOfRegularSession)
            {
                target.ServedOutsideOfRegularSession = source.ServedOutsideOfRegularSession;
                isModified = true;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsTitleIPartAParticipantTypeSupported)
                && target.TitleIPartAParticipantType != source.TitleIPartAParticipantType)
            {
                target.TitleIPartAParticipantType = source.TitleIPartAParticipantType;
                isModified = true;
            }

            // Synch inherited lists
            if (sourceSupport == null || sourceSupport.IsStudentProgramAssociationServicesSupported)
                isModified |= source.StudentProgramAssociationServices.SynchronizeListTo(target.StudentProgramAssociationServices, child => child.StudentProgramAssociation = target,
                                sourceSupport == null ? null : sourceSupport.IsStudentProgramAssociationServiceIncluded);



            // Sync lists

            return isModified;
        }



        internal static void MapDerivedTo(this IStudentTitleIPartAProgramAssociation source, IStudentTitleIPartAProgramAssociation target, Action<IStudentTitleIPartAProgramAssociation, IStudentTitleIPartAProgramAssociation> onMapped)
        {
            var sourceSynchSupport = source as IStudentTitleIPartAProgramAssociationSynchronizationSourceSupport;
            var targetSynchSupport = target as IStudentTitleIPartAProgramAssociationSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.BeginDate = source.BeginDate;
            target.EducationOrganizationId = source.EducationOrganizationId;
            target.ProgramEducationOrganizationId = source.ProgramEducationOrganizationId;
            target.ProgramName = source.ProgramName;
            target.ProgramType = source.ProgramType;
            target.StudentUniqueId = source.StudentUniqueId;

            // Copy inherited non-PK properties

            if (sourceSynchSupport.IsEndDateSupported)
                target.EndDate = source.EndDate;
            else
                targetSynchSupport.IsEndDateSupported = false;

            if (sourceSynchSupport.IsReasonExitedDescriptorSupported)
                target.ReasonExitedDescriptor = source.ReasonExitedDescriptor;
            else
                targetSynchSupport.IsReasonExitedDescriptorSupported = false;

            if (sourceSynchSupport.IsServedOutsideOfRegularSessionSupported)
                target.ServedOutsideOfRegularSession = source.ServedOutsideOfRegularSession;
            else
                targetSynchSupport.IsServedOutsideOfRegularSessionSupported = false;

            // Copy non-PK properties

            if (sourceSynchSupport.IsTitleIPartAParticipantTypeSupported)
                target.TitleIPartAParticipantType = source.TitleIPartAParticipantType;
            else
                targetSynchSupport.IsTitleIPartAParticipantTypeSupported = false;

            // Map inherited lists

            if (sourceSynchSupport.IsStudentProgramAssociationServicesSupported)
            {
                targetSynchSupport.IsStudentProgramAssociationServiceIncluded = sourceSynchSupport.IsStudentProgramAssociationServiceIncluded;
                source.StudentProgramAssociationServices.MapListTo(target.StudentProgramAssociationServices);
            }
            else
            {
                targetSynchSupport.IsStudentProgramAssociationServicesSupported = false;
            }

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IStudentTitleIPartAProgramAssociationSynchronizationSourceSupport
    {
        bool IsEndDateSupported { get; set; }
        bool IsReasonExitedDescriptorSupported { get; set; }
        bool IsServedOutsideOfRegularSessionSupported { get; set; }
        bool IsStudentProgramAssociationServicesSupported { get; set; }
        bool IsTitleIPartAParticipantTypeSupported { get; set; }
        Func<IStudentProgramAssociationService, bool> IsStudentProgramAssociationServiceIncluded { get; set; }
    }
 
}
// Aggregate: TeachingCredentialBasisType

namespace EdFi.Ods.Entities.Common //.TeachingCredentialBasisTypeAggregate
{ 
    public static class TeachingCredentialBasisTypeMapper 
    {
        public static bool SynchronizeTo(this ITeachingCredentialBasisType source, ITeachingCredentialBasisType target)
        {
            bool isModified = false;

            var sourceSupport = source as ITeachingCredentialBasisTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.TeachingCredentialBasisTypeId != target.TeachingCredentialBasisTypeId)
            {
                source.TeachingCredentialBasisTypeId = target.TeachingCredentialBasisTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ITeachingCredentialBasisType source, ITeachingCredentialBasisType target, Action<ITeachingCredentialBasisType, ITeachingCredentialBasisType> onMapped)
        {
            var sourceSynchSupport = source as ITeachingCredentialBasisTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as ITeachingCredentialBasisTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.TeachingCredentialBasisTypeId = source.TeachingCredentialBasisTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ITeachingCredentialBasisTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: TeachingCredentialDescriptor

namespace EdFi.Ods.Entities.Common //.TeachingCredentialDescriptorAggregate
{ 
    public static class TeachingCredentialDescriptorMapper 
    {
        public static bool SynchronizeTo(this ITeachingCredentialDescriptor source, ITeachingCredentialDescriptor target)
        {
            bool isModified = false;

            var sourceSupport = source as ITeachingCredentialDescriptorSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.TeachingCredentialDescriptorId != target.TeachingCredentialDescriptorId)
            {
                source.TeachingCredentialDescriptorId = target.TeachingCredentialDescriptorId;
            }

            // Copy inherited non-PK properties


            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveBeginDateSupported)
                && target.EffectiveBeginDate != source.EffectiveBeginDate)
            {
                target.EffectiveBeginDate = source.EffectiveBeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveEndDateSupported)
                && target.EffectiveEndDate != source.EffectiveEndDate)
            {
                target.EffectiveEndDate = source.EffectiveEndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNamespaceSupported)
                && target.Namespace != source.Namespace)
            {
                target.Namespace = source.Namespace;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPriorDescriptorIdSupported)
                && target.PriorDescriptorId != source.PriorDescriptorId)
            {
                target.PriorDescriptorId = source.PriorDescriptorId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsTeachingCredentialTypeSupported)
                && target.TeachingCredentialType != source.TeachingCredentialType)
            {
                target.TeachingCredentialType = source.TeachingCredentialType;
                isModified = true;
            }

            // Synch inherited lists


            // Sync lists

            return isModified;
        }



        public static void MapTo(this ITeachingCredentialDescriptor source, ITeachingCredentialDescriptor target, Action<ITeachingCredentialDescriptor, ITeachingCredentialDescriptor> onMapped)
        {
            var sourceSynchSupport = source as ITeachingCredentialDescriptorSynchronizationSourceSupport;
            var targetSynchSupport = target as ITeachingCredentialDescriptorSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.TeachingCredentialDescriptorId = source.TeachingCredentialDescriptorId;

            // Copy inherited non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsEffectiveBeginDateSupported)
                target.EffectiveBeginDate = source.EffectiveBeginDate;
            else
                targetSynchSupport.IsEffectiveBeginDateSupported = false;

            if (sourceSynchSupport.IsEffectiveEndDateSupported)
                target.EffectiveEndDate = source.EffectiveEndDate;
            else
                targetSynchSupport.IsEffectiveEndDateSupported = false;

            if (sourceSynchSupport.IsNamespaceSupported)
                target.Namespace = source.Namespace;
            else
                targetSynchSupport.IsNamespaceSupported = false;

            if (sourceSynchSupport.IsPriorDescriptorIdSupported)
                target.PriorDescriptorId = source.PriorDescriptorId;
            else
                targetSynchSupport.IsPriorDescriptorIdSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Copy non-PK properties

            if (sourceSynchSupport.IsTeachingCredentialTypeSupported)
                target.TeachingCredentialType = source.TeachingCredentialType;
            else
                targetSynchSupport.IsTeachingCredentialTypeSupported = false;

            // Map inherited lists

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ITeachingCredentialDescriptorSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsEffectiveBeginDateSupported { get; set; }
        bool IsEffectiveEndDateSupported { get; set; }
        bool IsNamespaceSupported { get; set; }
        bool IsPriorDescriptorIdSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
        bool IsTeachingCredentialTypeSupported { get; set; }
    }
 
}
// Aggregate: TeachingCredentialType

namespace EdFi.Ods.Entities.Common //.TeachingCredentialTypeAggregate
{ 
    public static class TeachingCredentialTypeMapper 
    {
        public static bool SynchronizeTo(this ITeachingCredentialType source, ITeachingCredentialType target)
        {
            bool isModified = false;

            var sourceSupport = source as ITeachingCredentialTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.TeachingCredentialTypeId != target.TeachingCredentialTypeId)
            {
                source.TeachingCredentialTypeId = target.TeachingCredentialTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ITeachingCredentialType source, ITeachingCredentialType target, Action<ITeachingCredentialType, ITeachingCredentialType> onMapped)
        {
            var sourceSynchSupport = source as ITeachingCredentialTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as ITeachingCredentialTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.TeachingCredentialTypeId = source.TeachingCredentialTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ITeachingCredentialTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: TelephoneNumberType

namespace EdFi.Ods.Entities.Common //.TelephoneNumberTypeAggregate
{ 
    public static class TelephoneNumberTypeMapper 
    {
        public static bool SynchronizeTo(this ITelephoneNumberType source, ITelephoneNumberType target)
        {
            bool isModified = false;

            var sourceSupport = source as ITelephoneNumberTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.TelephoneNumberTypeId != target.TelephoneNumberTypeId)
            {
                source.TelephoneNumberTypeId = target.TelephoneNumberTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ITelephoneNumberType source, ITelephoneNumberType target, Action<ITelephoneNumberType, ITelephoneNumberType> onMapped)
        {
            var sourceSynchSupport = source as ITelephoneNumberTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as ITelephoneNumberTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.TelephoneNumberTypeId = source.TelephoneNumberTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ITelephoneNumberTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: TermDescriptor

namespace EdFi.Ods.Entities.Common //.TermDescriptorAggregate
{ 
    public static class TermDescriptorMapper 
    {
        public static bool SynchronizeTo(this ITermDescriptor source, ITermDescriptor target)
        {
            bool isModified = false;

            var sourceSupport = source as ITermDescriptorSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.TermDescriptorId != target.TermDescriptorId)
            {
                source.TermDescriptorId = target.TermDescriptorId;
            }

            // Copy inherited non-PK properties


            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveBeginDateSupported)
                && target.EffectiveBeginDate != source.EffectiveBeginDate)
            {
                target.EffectiveBeginDate = source.EffectiveBeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveEndDateSupported)
                && target.EffectiveEndDate != source.EffectiveEndDate)
            {
                target.EffectiveEndDate = source.EffectiveEndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNamespaceSupported)
                && target.Namespace != source.Namespace)
            {
                target.Namespace = source.Namespace;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPriorDescriptorIdSupported)
                && target.PriorDescriptorId != source.PriorDescriptorId)
            {
                target.PriorDescriptorId = source.PriorDescriptorId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsTermTypeSupported)
                && target.TermType != source.TermType)
            {
                target.TermType = source.TermType;
                isModified = true;
            }

            // Synch inherited lists


            // Sync lists

            return isModified;
        }



        public static void MapTo(this ITermDescriptor source, ITermDescriptor target, Action<ITermDescriptor, ITermDescriptor> onMapped)
        {
            var sourceSynchSupport = source as ITermDescriptorSynchronizationSourceSupport;
            var targetSynchSupport = target as ITermDescriptorSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.TermDescriptorId = source.TermDescriptorId;

            // Copy inherited non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsEffectiveBeginDateSupported)
                target.EffectiveBeginDate = source.EffectiveBeginDate;
            else
                targetSynchSupport.IsEffectiveBeginDateSupported = false;

            if (sourceSynchSupport.IsEffectiveEndDateSupported)
                target.EffectiveEndDate = source.EffectiveEndDate;
            else
                targetSynchSupport.IsEffectiveEndDateSupported = false;

            if (sourceSynchSupport.IsNamespaceSupported)
                target.Namespace = source.Namespace;
            else
                targetSynchSupport.IsNamespaceSupported = false;

            if (sourceSynchSupport.IsPriorDescriptorIdSupported)
                target.PriorDescriptorId = source.PriorDescriptorId;
            else
                targetSynchSupport.IsPriorDescriptorIdSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Copy non-PK properties

            if (sourceSynchSupport.IsTermTypeSupported)
                target.TermType = source.TermType;
            else
                targetSynchSupport.IsTermTypeSupported = false;

            // Map inherited lists

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ITermDescriptorSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsEffectiveBeginDateSupported { get; set; }
        bool IsEffectiveEndDateSupported { get; set; }
        bool IsNamespaceSupported { get; set; }
        bool IsPriorDescriptorIdSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
        bool IsTermTypeSupported { get; set; }
    }
 
}
// Aggregate: TermType

namespace EdFi.Ods.Entities.Common //.TermTypeAggregate
{ 
    public static class TermTypeMapper 
    {
        public static bool SynchronizeTo(this ITermType source, ITermType target)
        {
            bool isModified = false;

            var sourceSupport = source as ITermTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.TermTypeId != target.TermTypeId)
            {
                source.TermTypeId = target.TermTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ITermType source, ITermType target, Action<ITermType, ITermType> onMapped)
        {
            var sourceSynchSupport = source as ITermTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as ITermTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.TermTypeId = source.TermTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ITermTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: TitleIPartAParticipantType

namespace EdFi.Ods.Entities.Common //.TitleIPartAParticipantTypeAggregate
{ 
    public static class TitleIPartAParticipantTypeMapper 
    {
        public static bool SynchronizeTo(this ITitleIPartAParticipantType source, ITitleIPartAParticipantType target)
        {
            bool isModified = false;

            var sourceSupport = source as ITitleIPartAParticipantTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.TitleIPartAParticipantTypeId != target.TitleIPartAParticipantTypeId)
            {
                source.TitleIPartAParticipantTypeId = target.TitleIPartAParticipantTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ITitleIPartAParticipantType source, ITitleIPartAParticipantType target, Action<ITitleIPartAParticipantType, ITitleIPartAParticipantType> onMapped)
        {
            var sourceSynchSupport = source as ITitleIPartAParticipantTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as ITitleIPartAParticipantTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.TitleIPartAParticipantTypeId = source.TitleIPartAParticipantTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ITitleIPartAParticipantTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: TitleIPartASchoolDesignationType

namespace EdFi.Ods.Entities.Common //.TitleIPartASchoolDesignationTypeAggregate
{ 
    public static class TitleIPartASchoolDesignationTypeMapper 
    {
        public static bool SynchronizeTo(this ITitleIPartASchoolDesignationType source, ITitleIPartASchoolDesignationType target)
        {
            bool isModified = false;

            var sourceSupport = source as ITitleIPartASchoolDesignationTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.TitleIPartASchoolDesignationTypeId != target.TitleIPartASchoolDesignationTypeId)
            {
                source.TitleIPartASchoolDesignationTypeId = target.TitleIPartASchoolDesignationTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this ITitleIPartASchoolDesignationType source, ITitleIPartASchoolDesignationType target, Action<ITitleIPartASchoolDesignationType, ITitleIPartASchoolDesignationType> onMapped)
        {
            var sourceSynchSupport = source as ITitleIPartASchoolDesignationTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as ITitleIPartASchoolDesignationTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.TitleIPartASchoolDesignationTypeId = source.TitleIPartASchoolDesignationTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface ITitleIPartASchoolDesignationTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: VisaType

namespace EdFi.Ods.Entities.Common //.VisaTypeAggregate
{ 
    public static class VisaTypeMapper 
    {
        public static bool SynchronizeTo(this IVisaType source, IVisaType target)
        {
            bool isModified = false;

            var sourceSupport = source as IVisaTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.VisaTypeId != target.VisaTypeId)
            {
                source.VisaTypeId = target.VisaTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IVisaType source, IVisaType target, Action<IVisaType, IVisaType> onMapped)
        {
            var sourceSynchSupport = source as IVisaTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IVisaTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.VisaTypeId = source.VisaTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IVisaTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
// Aggregate: WeaponDescriptor

namespace EdFi.Ods.Entities.Common //.WeaponDescriptorAggregate
{ 
    public static class WeaponDescriptorMapper 
    {
        public static bool SynchronizeTo(this IWeaponDescriptor source, IWeaponDescriptor target)
        {
            bool isModified = false;

            var sourceSupport = source as IWeaponDescriptorSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.WeaponDescriptorId != target.WeaponDescriptorId)
            {
                source.WeaponDescriptorId = target.WeaponDescriptorId;
            }

            // Copy inherited non-PK properties


            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveBeginDateSupported)
                && target.EffectiveBeginDate != source.EffectiveBeginDate)
            {
                target.EffectiveBeginDate = source.EffectiveBeginDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsEffectiveEndDateSupported)
                && target.EffectiveEndDate != source.EffectiveEndDate)
            {
                target.EffectiveEndDate = source.EffectiveEndDate;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsNamespaceSupported)
                && target.Namespace != source.Namespace)
            {
                target.Namespace = source.Namespace;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsPriorDescriptorIdSupported)
                && target.PriorDescriptorId != source.PriorDescriptorId)
            {
                target.PriorDescriptorId = source.PriorDescriptorId;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsWeaponTypeSupported)
                && target.WeaponType != source.WeaponType)
            {
                target.WeaponType = source.WeaponType;
                isModified = true;
            }

            // Synch inherited lists


            // Sync lists

            return isModified;
        }



        public static void MapTo(this IWeaponDescriptor source, IWeaponDescriptor target, Action<IWeaponDescriptor, IWeaponDescriptor> onMapped)
        {
            var sourceSynchSupport = source as IWeaponDescriptorSynchronizationSourceSupport;
            var targetSynchSupport = target as IWeaponDescriptorSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.WeaponDescriptorId = source.WeaponDescriptorId;

            // Copy inherited non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsEffectiveBeginDateSupported)
                target.EffectiveBeginDate = source.EffectiveBeginDate;
            else
                targetSynchSupport.IsEffectiveBeginDateSupported = false;

            if (sourceSynchSupport.IsEffectiveEndDateSupported)
                target.EffectiveEndDate = source.EffectiveEndDate;
            else
                targetSynchSupport.IsEffectiveEndDateSupported = false;

            if (sourceSynchSupport.IsNamespaceSupported)
                target.Namespace = source.Namespace;
            else
                targetSynchSupport.IsNamespaceSupported = false;

            if (sourceSynchSupport.IsPriorDescriptorIdSupported)
                target.PriorDescriptorId = source.PriorDescriptorId;
            else
                targetSynchSupport.IsPriorDescriptorIdSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Copy non-PK properties

            if (sourceSynchSupport.IsWeaponTypeSupported)
                target.WeaponType = source.WeaponType;
            else
                targetSynchSupport.IsWeaponTypeSupported = false;

            // Map inherited lists

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IWeaponDescriptorSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsEffectiveBeginDateSupported { get; set; }
        bool IsEffectiveEndDateSupported { get; set; }
        bool IsNamespaceSupported { get; set; }
        bool IsPriorDescriptorIdSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
        bool IsWeaponTypeSupported { get; set; }
    }
 
}
// Aggregate: WeaponType

namespace EdFi.Ods.Entities.Common //.WeaponTypeAggregate
{ 
    public static class WeaponTypeMapper 
    {
        public static bool SynchronizeTo(this IWeaponType source, IWeaponType target)
        {
            bool isModified = false;

            var sourceSupport = source as IWeaponTypeSynchronizationSourceSupport;

            // Back synch non-reference portion of PK (PK properties cannot be changed, therefore they can be omitted in the resource payload, but we need them for proper comparisons for persistence)
            if (source.WeaponTypeId != target.WeaponTypeId)
            {
                source.WeaponTypeId = target.WeaponTypeId;
            }

            // Copy non-PK properties

            if ((sourceSupport == null || sourceSupport.IsCodeValueSupported)
                && target.CodeValue != source.CodeValue)
            {
                target.CodeValue = source.CodeValue;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsDescriptionSupported)
                && target.Description != source.Description)
            {
                target.Description = source.Description;
                isModified = true;
            }

            if ((sourceSupport == null || sourceSupport.IsShortDescriptionSupported)
                && target.ShortDescription != source.ShortDescription)
            {
                target.ShortDescription = source.ShortDescription;
                isModified = true;
            }



            // Sync lists

            return isModified;
        }



        public static void MapTo(this IWeaponType source, IWeaponType target, Action<IWeaponType, IWeaponType> onMapped)
        {
            var sourceSynchSupport = source as IWeaponTypeSynchronizationSourceSupport;
            var targetSynchSupport = target as IWeaponTypeSynchronizationSourceSupport;

            // Copy resource Id
            target.Id = source.Id;

            // Copy contextual primary key values
            target.WeaponTypeId = source.WeaponTypeId;

            // Copy non-PK properties

            if (sourceSynchSupport.IsCodeValueSupported)
                target.CodeValue = source.CodeValue;
            else
                targetSynchSupport.IsCodeValueSupported = false;

            if (sourceSynchSupport.IsDescriptionSupported)
                target.Description = source.Description;
            else
                targetSynchSupport.IsDescriptionSupported = false;

            if (sourceSynchSupport.IsShortDescriptionSupported)
                target.ShortDescription = source.ShortDescription;
            else
                targetSynchSupport.IsShortDescriptionSupported = false;

            // Map lists

            var eTagProvider = new ETagProvider();

            // Convert value to ETag, if appropriate
            var entityWithETag = target as IHasETag;

            if (entityWithETag != null)
                entityWithETag.ETag = eTagProvider.GetETag(source);

            // Convert value to LastModifiedDate, if appropriate
            var dateVersionedEntity = target as IDateVersionedEntity;
            var etagSource = source as IHasETag;

            if (dateVersionedEntity != null && etagSource != null)
                dateVersionedEntity.LastModifiedDate = eTagProvider.GetDateTime(etagSource.ETag);
        }
    }

    /// <summary>
    /// Defines properties that indicate whether a particular property of the model abstraction 
    /// is supported by a model implementation being used as the source in a "synchronization"
    /// operation.
    /// </summary>
    public interface IWeaponTypeSynchronizationSourceSupport
    {
        bool IsCodeValueSupported { get; set; }
        bool IsDescriptionSupported { get; set; }
        bool IsShortDescriptionSupported { get; set; }
    }
 
}
